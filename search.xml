<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Guava Caches和Guava ListenableFuture学习]]></title>
    <url>%2F2020%2F07%2F27%2FGuava-Caches%E5%92%8CGuava-ListenableFuture%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1.Guava是什么?Guava是Google的一组核心Java库，其中包括新的集合类型（例如多图和多集），不可变的集合，图形库以及用于并发，I / O，哈希，缓存，原语，字符串等的实用程序！它广泛用于Google的大多数Java项目中，也被许多其他公司广泛使用。 它的github地址为: https://github.com/google/guava 本次主要参照官方文档,对项目中用到的guava caches和guava listenableFuture进行了学习. 2.Guava Caches2.1.为什么要用Guava Caches?基于内存的高速本地缓存在各种情况下都很用,我们在编程开发时,一定使用过HashMap或ConcurrentMap对数据进行过缓存.Guava Caches就与ConcurrentMap比较相似,最根本的区别就是ConcurrentMap会保存添加到其中的所有元素，直到调用代码将其明确删除为止。而Guava Caches则可以对存储的元素进行管理和剔除，以限制其内存占用量,而且它提供了LoadingCache，进行缓存的自动加载，非常的方便。 在官方文档上这样介绍Guava: Generally, the Guava caching utilities are applicable whenever: You are willing to spend some memory to improve speed. You expect that keys will sometimes get queried more than once. Your cache will not need to store more data than what would fit in RAM. (Guava caches are local to a single run of your application. They do not store data in files, or on outside servers. If this does not fit your needs, consider a tool like Memcached.) If each of these apply to your use case, then the Guava caching utilities could be right for you! 当然如果不需要Guava Caches的这些特性,那么ConcurrentHashMap的内存效率更高——但是用任何旧的ConcurrentMap来复制大多数Guava Cahces的特性是极其困难或不可能的(官网都这么说了,有现成的那就用吧). 2.2.Guava Caches的学习和使用首先把Guava的包引进来 123456&lt;!--guava--&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;29.0-jre&lt;/version&gt;&lt;/dependency&gt; 2.2.1.创建缓存和获取缓存基本用法123456789LoadingCache&lt;String, String&gt; graphs = CacheBuilder.newBuilder() .maximumSize(1) .expireAfterWrite(10, TimeUnit.MINUTES) .build( new CacheLoader&lt;String, String&gt;() &#123; public String load(String s) throws Exception &#123; return getRealCache(s); // 这个方法可以自己写 &#125; &#125;); 代码中的build中出现了CacheLoader这个东西,他的用处意思就是设置一个默认的方法,在取值的时候如果key对应的value不存在,那么就用这个方法获取value然后自动进行设置.当然我们也可以直接用graphs.put(k,v)来进行缓存的添加,但是建议用CacheLoader来自动加载设置缓存,可以保证缓存加载的统一性. 当我们不想用默认的CacheLoader来进行缓存加载时,我们可以在获取缓存时指定方法对默认加载方法进行覆盖,它使用原子性的“ get-if-absent-compute”语义，传递 Callable给get调用,此方法为常规的“如果已缓存，则返回；否则创建，缓存并返回”模式提供了简单的替代方法。如下面代码所示: 1234String noCacheValueCallable = graphs.get("helloCallable", () -&gt; &#123; return "helloCallableValue:Callable";&#125;);log.info("获取不存在的缓存调用Callable进行加载: &#123;&#125;", noCacheValueCallable); 其他API简单列举: get: 要么返回已经缓存的值，要么使用CacheLoader向缓存原子地加载新值； getUnchecked: CacheLoader 会抛异常，定义的CacheLoader没有声明任何检查型异常，则可以 getUnchecked 查找缓存；反之不能； getAll: 方法用来执行批量查询； put: 向缓存显式插入值，Cache.asMap()也能修改值，但不具原子性； getIfPresent: 该方法只是简单的把Guava Cache当作Map的替代品，不执行load方法； 2.2.2.清除key:我们几乎可以肯定没有足够的内存来缓存我们可以缓存的所有内容.所以必须决定：什么情况下不值得保留缓存对?Guava Caches提供了三种缓存清除类型: 基于大小的清除 基于时间的清除 基于引用的清除 基于大小的清除: 使用CacheBuilder.maximumSize(long)进行设置,缓存将清除最近没有使用或者不经常使用的缓存.值得注意的是,缓存会在这个数值接近设置值的时候就对缓存进行清除.除此之外,也可以用CacheBuilder.weigher(Weigher)来设置权重函数来进行清除的规则设置. 直接贴上一个伪代码帮助理解: 12345678910111213LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder() .maximumWeight(100000) .weigher(new Weigher&lt;Key, Graph&gt;() &#123; public int weigh(Key k, Graph g) &#123; return g.vertices().size(); &#125; &#125;) .build( new CacheLoader&lt;Key, Graph&gt;() &#123; public Graph load(Key key) &#123; // no checked exception return createExpensiveGraph(key); &#125; &#125;); 基于时间的清除: expireAfterAccess(long, TimeUnit)仅在自从上次通过读取或写入访问条目以来经过指定的持续时间后，条目才到期。请注意，逐出条目的顺序将类似于基于大小的逐出。 expireAfterWrite(long, TimeUnit)自创建条目以来经过指定的时间或该值的最新替换之后，使条目过期。如果经过一定时间后缓存的数据过时，则可能需要这样做。 请注意: 定时到期是在写入过程中进行定期维护的，偶尔在读取过程中进行维护,并不是实时的哦. 基于引用的清除: Guava允许您设置缓存，以通过对键或值使用弱引用，对值使用软引用来对条目进行垃圾回收。 CacheBuilder.weakKeys()使用弱引用存储密钥。如果没有其他（强或软）键引用，则可以垃圾回收条目。由于垃圾回收仅取决于身份相等性，因此导致整个缓存使用身份（==）相等性来比较键，而不是equals()。 CacheBuilder.weakValues()使用弱引用存储值。如果没有其他（强或软）值引用，则可以垃圾回收这些条目。由于垃圾回收仅取决于身份相等性，因此这导致整个缓存使用身份（==）相等性来比较值，而不是equals()。 CacheBuilder.softValues()将值包装在软引用中。响应内存需求，以全局最近最少使用的方式对软引用的对象进行垃圾回收。由于使用软引用会对性能产生影响，因此我们通常建议使用更可预测的最大高速缓存大小。使用softValues()会导致使用identity（==）相等而不是来比较值equals()。 其他的清除 API: guava cache 自带 清除机制，但仍旧可以手动清除： 个别清除：Cache.invalidate(key) 批量清除：Cache.invalidateAll(keys) 清除所有缓存项：Cache.invalidateAll() 缓存清除的监听器: 可以通过CacheBuilder.removalListener(RemovalListener)为缓存指定删除侦听器，以便在删除条目时执行某些操作。向 RemovalListener传递一个RemovalNotification，其中指定了 RemovalCause、键和值。 注意，RemovalListener抛出的任何异常都会被记录(使用日志记录器)并被吞噬。 然后直接上一下我写的一个测试用例代码,Guava Caches的最基本的使用就在这块代码里了,通过代码可以更直观的看到缓存的基本操作用法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.bestqiang.guava.cache;import com.google.common.cache.CacheBuilder;import com.google.common.cache.CacheLoader;import com.google.common.cache.LoadingCache;import lombok.extern.slf4j.Slf4j;import org.junit.Test;import java.util.concurrent.ExecutionException;import java.util.concurrent.TimeUnit;/** * GuavaCacheStudyTest * * @author bestqiang * @date 2020/7/27 10:51 */@Slf4jpublic class GuavaCacheStudyTest &#123; @Test public void testGuavaCaches() throws ExecutionException &#123; LoadingCache&lt;String, String&gt; graphs = CacheBuilder.newBuilder() .maximumSize(1) .removalListener((cache) -&gt; &#123; log.info("key为&#123;&#125;,value为&#123;&#125;的缓存被清除了...", cache.getKey(), cache.getValue()); &#125;) .expireAfterWrite(10, TimeUnit.MINUTES) .build( new CacheLoader&lt;String, String&gt;() &#123; public String load(String s) throws Exception &#123; return getRealCache(s); &#125; &#125;); // 可以直接用put,但是建议使用自动缓存加载,这样可以保证缓存加载的统一性 graphs.put("hello", "helloValue"); String hello = graphs.get("hello"); log.info("获取已有的缓存: &#123;&#125;", hello); String noCacheValue = graphs.get("helloCacheLoader"); log.info("获取不存在的缓存会自动调用load进行加载: &#123;&#125;", noCacheValue); // get时指定加载方法 String noCacheValueCallable = graphs.get("helloCallable", () -&gt; &#123; return "helloCallableValue:Callable"; &#125;); log.info("获取不存在的缓存调用Callable进行加载: &#123;&#125;", noCacheValueCallable); &#125; private String getRealCache(String s) &#123; return s + ":RealCache"; &#125;&#125; 代码运行结果: 123452020-07-27 21:07:23.631 INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest:38 say: 获取已有的缓存: helloValue2020-07-27 21:07:23.699 INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest:26 say: key为hello,value为helloValue的缓存被清除了...2020-07-27 21:07:23.700 INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest:41 say: 获取不存在的缓存会自动调用load进行加载: helloCacheLoader:RealCache2020-07-27 21:07:23.701 INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest:26 say: key为helloCacheLoader,value为helloCacheLoader:RealCache的缓存被清除了...2020-07-27 21:07:23.701 INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest:47 say: 获取不存在的缓存调用Callable进行加载: helloCallableValue:Callable 应该什么时候进行缓存清理: 使用CacheBuilder构建的缓存不会“自动”执行清理和逐出值，也不会在值过期后立即执行此类操作。相反，它在写操作期间执行少量维护，或者在偶尔的读操作(如果写操作很少)期间执行少量维护。 这样做的原因如下:如果我们想要持续地执行缓存维护，我们将需要创建一个线程，而它的操作将与用户操作竞争共享锁。此外，一些环境限制线程的创建，这将使CacheBuilder在该环境中不可用。 相反，我们把选择权放在你的手中。如果您的缓存是高吞吐量的，那么您就不必担心执行缓存维护来清除过期的条目等等。如果您的缓存写入很少，并且您不希望清理阻塞缓存读取，您可能希望创建自己的维护线程，定期调用cache.cleanup()。 如果您想为很少写入的缓存安排常规的缓存维护，只需使用ScheduledExecutorService来安排维护。 总结就是一句话:高吞吐量不用担心,缓存在写入或读取的时候就会自动完成清理操作.如果缓存的写操作很少,不希望清理操作阻塞缓存读取,那么开一个线程定期调用cache.cleanup()进行缓存清理就ok. Refresh操作: CacheBuilder.refreshAfterWrite(1, TimeUnit.MINUTES) 刷新操作,对于刷新不完全等同于清除。如LoadingCache.refresh(K)中所指定的,刷新一个键将为该键加载一个新值,可能是异步操作的.在键值刷新时,仍然返回旧的值(如果有的话),不会阻塞.这与清除相反,清除的话会进行强制检索等待,直到重新加载该值然后返回.如果在刷新时抛出异常,则保留旧值,并记录并排除异常.CacheLoader可以通过覆盖CacheLoader来指定刷新时使用的特定方法 reload(K, V). 举一个简单的测试用例: 1234567891011121314151617181920212223242526272829303132@Testpublic void testRefresh() throws ExecutionException, InterruptedException &#123; LoadingCache&lt;String, String&gt; graphs = CacheBuilder.newBuilder() .maximumSize(10) .removalListener((cache) -&gt; &#123; log.info("key为&#123;&#125;,value为&#123;&#125;的缓存被清除了...", cache.getKey(), cache.getValue()); &#125;) .refreshAfterWrite(1, TimeUnit.SECONDS) .build( new CacheLoader&lt;String, String&gt;() &#123; public String load(String s) throws Exception &#123; log.info("load进行重新加载key为: " + s + " 的value"); return getRealCache(s); &#125; public ListenableFuture&lt;String&gt; reload(String key, String value) &#123; log.info("reload进行重新加载key为: " + key + " 的value"); ListenableFutureTask&lt;String&gt; task = ListenableFutureTask.create(new Callable&lt;String&gt;() &#123; public String call() &#123; return "刷新方法异步执行了,key为: " + key; &#125; &#125;); new Thread(task).start(); return task; &#125; &#125;); String key1 = graphs.get("key1"); String key2 = graphs.get("key2"); Thread.sleep(2000); String key11 = graphs.get("key1");// 此时符合缓存刷新条件,缓存会进行刷新 log.info(key1);&#125; 输出结果: 12345020-07-27 22:23:15.641 INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest$1:36 say: load进行重新加载key为: key1 的value2020-07-27 22:23:15.658 INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest$1:36 say: load进行重新加载key为: key2 的value2020-07-27 22:23:17.659 INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest$1:40 say: reload进行重新加载key为: key1 的value2020-07-27 22:23:17.877 INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest:30 say: key为key1,value为key1:RealCache的缓存被清除了...2020-07-27 22:23:17.881 INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest:55 say: key1:RealCache 那么,我们在真实使用时用expire还是refresh呢?其实我们应该都用,这样，当缓存对符合刷新条件时，就不会盲目重置缓存对上的过期计时器，如果缓存对在符合刷新条件后没有查询，那么就让它过期。 2.3.统计:CacheBuilder.recordStats()用来开启Guava Cache的统计功能。统计打开后Cache.stats()方法返回如下统计信息： hitRate()：缓存命中率； hitMiss(): 缓存失误率； loadcount() ; 加载次数； averageLoadPenalty()：加载新值的平均时间，单位为纳秒； evictionCount()：缓存项被回收的总数，不包括显式清除。 唯一值得注意的一点是：当通过asmap（）方法查询key时，stat项是不作任何变化的，修改值时会有影响。此外，还有其他很多统计信息。这些统计信息对于调整缓存设置是至关重要的，在性能监控时可以依据的重要指标。 此外关于asmap还有几点注意事项: 您可以使用它的asMap视图将任何缓存看作是一个ConcurrentMap，但是asMap视图如何与缓存交互需要一些解释。 cache.asMap()包含当前在缓存中加载的所有条目。因此，例如，cache.asMap().keySet()包含所有当前加载的键。 asMap().get(key)本质上等效于cache.getIfPresent(key)，并且从不导致值被加载。这与Map 合同一致。 所有缓存读取和写入操作（包括Cache.asMap().get(Object)和Cache.asMap().put(K, V)）都会重置访问时间，但不会通过 containsKey(Object)，也不会通过对的集合视图进行的操作来重置访问时间 Cache.asMap()。因此，例如，遍历 cache.asMap().entrySet()不会重置您检索的条目的访问时间。 3.ListenableFuture3.1.为什么要用ListenableFuture?官方文档这样介绍它: 并发是一个困难的问题，但是通过使用功能强大且简单的抽象可以大大简化并发。为了简化问题，Guava使用扩展Future了JDK 的 接口ListenableFuture。 强烈建议您始终使用ListenableFuture而不是Future 在所有代码中使用，因为： 大多数Futures方法都需要它。 这比更改为ListenableFuture以后要容易。 实用方法提供商将不再需要提供Future与 ListenableFuture他们的方法变种。 其实它就是jdk的Future的一个扩展,在Java8里,汲取了Guava ListenableFuture的优点,CompleteFuture类诞生了.ListenableFuture在项目用到了,在这里主要简单看一下如何去使用它,之后如果有新的需求,可以尝试使用CompleteFuture来完成. 3.2.ListenableFuture的学习和使用ListenableFuture比原始的Future其实就是增加了一个回调操作,在执行完成后可以增加listener对执行进行监听,执行完毕后执行对应的方法,或者使用Futures.addCallback对不同的执行结果进行监听操作,根据执行结果的不同来进行不同的操作. 官方操作文档: https://github.com/google/guava/wiki/ListenableFutureExplained (操作相对全面,建议以此为准,但是测试用例有时不是很清晰) 对于这个工具方法的学习参考了博客: https://www.jianshu.com/p/9c57aa5e34af (说的比较通俗一点,下面的文章的测试用例和总结参考这篇博客) 3.2.1.创建和使用ListenableFuture的方法 使用create方法返回实例,这种就是简单的创建一个task,然后添加一个监听,当task执行完毕后监听执行后续方法,真实使用执行task的时候一定要用线程池,这里为了测试方便直接新开了一个线程执行task. 12345678910111213141516171819202122232425262728293031323334353637383940414243@Test public void test() &#123; //ListenableFutureTask通过静态create方法返回实例，还有一个重载方法，不太常用 ListenableFutureTask&lt;String&gt; task = ListenableFutureTask.create(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return "任务执行完毕"; &#125; &#125;); //启动任务(当然,这里为了测试方便,真实使用要用线程池) new Thread(task).start(); // 增加回调方法，MoreExecutors.directExecutor()返回guava默认的Executor， // 执行回调方法不会新开线程，所有回调方法都在当前线程做(可能是主线程或者执行ListenableFutureTask的线程，具体可以看最后面的代码)。 // guava异步模块中参数有Executor的方法，一般还会有一个没有Executor参数的重载方法，使用的就是MoreExecutors.directExecutor() task.addListener(new Runnable() &#123; @SneakyThrows @Override public void run() &#123; log.info(task.get()); log.info("回调方法执行"); &#125; &#125;, MoreExecutors.directExecutor()); &#125; //MoreExecutors.directExecutor()源码，execute方法就是直接运行，没有新开线程 public static Executor directExecutor() &#123; return DirectExecutor.INSTANCE; &#125; private enum DirectExecutor implements Executor &#123; INSTANCE; @Override public void execute(Runnable command) &#123; command.run(); &#125; @Override public String toString() &#123; return "MoreExecutors.directExecutor()"; &#125; &#125; 运行结果: 122020-07-28 10:54:33.350 INFO [main] com.bestqiang.guava.future.ListenableFutureStudyTest$2:61 say: 任务执行完毕2020-07-28 10:54:33.356 INFO [main] com.bestqiang.guava.future.ListenableFutureStudyTest$2:62 say: 回调方法执行 使用guava对ExecutorService的增强来创建线程池 123456789101112131415161718//真正干活的线程池ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor( 5, 5, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(100), new CustomizableThreadFactory("demo"), new ThreadPoolExecutor.DiscardPolicy());//guava的接口ListeningExecutorService继承了jdk原生ExecutorService接口，重写了submit方法，修改返回值类型为ListenableFutureListeningExecutorService listeningExecutor = MoreExecutors.listeningDecorator(poolExecutor);//获得一个随着jvm关闭而关闭的线程池，通过Runtime.getRuntime().addShutdownHook(hook)实现//修改ThreadFactory为创建守护线程，默认jvm关闭时最多等待120秒关闭线程池，重载方法可以设置时间ExecutorService newPoolExecutor = MoreExecutors.getExitingExecutorService(poolExecutor);//只增加关闭线程池的钩子，不改变ThreadFactoryMoreExecutors.addDelayedShutdownHook(poolExecutor, 120, TimeUnit.SECONDS); 其实就是调用工具类将原生ExecutorService进行转换,线程池进行submit时,会返回ListenableFuture对象. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//像线程池提交任务，并得到ListenableFutureListenableFuture&lt;String&gt; listenableFuture = listeningExecutor.submit(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return ""; &#125;&#125;);//可以通过addListener对listenableFuture注册回调，但是通常使用Futures中的工具方法Futures.addCallback(listenableFuture, new FutureCallback&lt;String&gt;() &#123; @Override public void onSuccess(String result) &#123; &#125; @Override public void onFailure(Throwable t) &#123; &#125;&#125;);/** * Futures.addCallback源码，其实就是包装了一层addListener，可以不加executor参数，使用上文说的DirectExecutor * 需要说明的是不加Executor的情况，只适用于轻型的回调方法，如果回调方法很耗时占资源，会造成线程阻塞 * 因为DirectExecutor有可能在主线程中执行回调 */public static &lt;V&gt; void addCallback(final ListenableFuture&lt;V&gt; future, final FutureCallback&lt;? super V&gt; callback, Executor executor) &#123; Preconditions.checkNotNull(callback); Runnable callbackListener = new Runnable() &#123; @Override public void run() &#123; final V value; try &#123; value = getDone(future); &#125; catch (ExecutionException e) &#123; callback.onFailure(e.getCause()); return; &#125; catch (RuntimeException e) &#123; callback.onFailure(e); return; &#125; catch (Error e) &#123; callback.onFailure(e); return; &#125; callback.onSuccess(value); &#125; &#125;; future.addListener(callbackListener, executor);&#125; 3.2.2.异步操作链使用ListenableFuture最重要的原因是,它可以拥有复杂的异步操作链,方便我们进行链式调用. 不用异步操作链,用addListener进行实现可以是这样: 12345678910111213141516171819202122232425ListenableFutureTask&lt;String&gt; task1 = ListenableFutureTask.create(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return ""; &#125;&#125;);new Thread(task1).start();task1.addListener(new Runnable() &#123; @Override public void run() &#123; ListenableFutureTask&lt;String&gt; task2 = ListenableFutureTask.create(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return ""; &#125; &#125;); task2.addListener(new Runnable() &#123; @Override public void run() &#123; ... &#125; &#125;, MoreExecutors.directExecutor()); new Thread(task2).start(); &#125;&#125;, MoreExecutors.directExecutor()); 上述代码,其实就是一层监听器套一层,实现了链式调用.使用Guava的异步链式调用,可以用两个API简单的实现: transformAsync(ListenableFuture, AsyncFunction, Executor) transform(ListenableFuture, Function, Executor) 上述两个API的区别顾名思义就是一个异步链式调用一个同步链式调用. 还有两个API也比较常用,可以对ListenableFuture进行批量的处理: allAsList(Iterable&gt;) 对多个ListenableFuture的合并，返回一个当所有Future成功时返回多个Future返回值组成的List对象。注：当其中一个Future失败或者取消的时候，将会进入失败或者取消。 successfulAsList(Iterable&gt;) 和allAsList相似，唯一差别是对于失败或取消的Future返回值用null代替。不会进入失败或者取消流程。 具体的链式调用代码可以参考下面的代码: 12345678910111213141516171819202122232425//当task1执行完毕会回调执行Function的apply方法，如果有task1有异常抛出，则task2也抛出相同异常，不执行applyListenableFuture&lt;String&gt; task2 = Futures.transform(task1, new Function&lt;String, String&gt;() &#123; @Override public String apply(String input) &#123; return ""; &#125;&#125;);ListenableFuture&lt;String&gt; task3 = Futures.transform(task2, new Function&lt;String, String&gt;() &#123; @Override public String apply(String input) &#123; return ""; &#125;&#125;);//处理最终的异步任务Futures.addCallback(task3, new FutureCallback&lt;String&gt;() &#123; @Override public void onSuccess(String result) &#123; &#125; @Override public void onFailure(Throwable t) &#123; &#125;&#125;); 上述代码Futures.transform()和Futures.addCallback()都是对addListener做了封装,进行回调的设置,但是transform更适合用在链式处理的中间过程,addCallback更适合用在处理最终的结果上.另外,它们的参数都是可以带上线程池的.具体的使用根据情况来定吧. 4.结语Guava的特性还有很多,这里主要结合官方文档,对Caches和ListenableFuture进行了学习,方便大家快速了解入门,建议大家学习时多去github看看官方文档,以官方文档为准,可以少走弯路.]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于@Autowired注入空指针问题的解决]]></title>
    <url>%2F2019%2F09%2F19%2F%E5%85%B3%E4%BA%8E-Autowired%E6%B3%A8%E5%85%A5%E7%A9%BA%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[如果对Spring的生命周期掌握的不熟,遇到此类问题那就难办啦! 今天做项目的时候遇到一个问题，需要将线程池的参数抽取到yml文件里进行设置。这不是so easy吗？于是我就写出了下面这样的代码进行抽取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;/** * @author BestQiang */@Component@ConfigurationProperties(prefix = "thread-pool")public class ThreadPool &#123; private int corePoolSize; private int maximumPoolSize; private long keepAliveTime; private int capacity; public int getCorePoolSize() &#123; return corePoolSize; &#125; public void setCorePoolSize(int corePoolSize) &#123; this.corePoolSize = corePoolSize; &#125; public int getMaximumPoolSize() &#123; return maximumPoolSize; &#125; public void setMaximumPoolSize(int maximumPoolSize) &#123; this.maximumPoolSize = maximumPoolSize; &#125; public long getKeepAliveTime() &#123; return keepAliveTime; &#125; public void setKeepAliveTime(long keepAliveTime) &#123; this.keepAliveTime = keepAliveTime; &#125; public int getCapacity() &#123; return capacity; &#125; public void setCapacity(int capacity) &#123; this.capacity = capacity; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637package cn.bestqiang.util;import cn.bestqiang.pojo.ThreadPool;import com.google.common.util.concurrent.ThreadFactoryBuilder;import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;import java.util.concurrent.*;/** * @author Yaqiang Chen */@Componentpublic class MyThreadUtils &#123; @Autowired ThreadPool threadPool1; private ExecutorService threadPool = new ThreadPoolExecutor( threadPool1.getCorePoolSize(), threadPool1.getMaximumPoolSize(), threadPool1.getKeepAliveTime(), TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(threadPool1.getCapacity()), namedThreadFactory, new ThreadPoolExecutor.DiscardPolicy() ); private ThreadFactory namedThreadFactory = new ThreadFactoryBuilder() .setNameFormat("pool-%d").build(); public void execute(Runnable runnable)&#123; threadPool.submit(runnable); &#125;&#125; 在yml文件的配置如下： 12345thread-pool: core-pool-size: 5 maximum-pool-size: 20 keep-alive-time: 1 capacity: 1024 本想应该毫无问题，但是，报错了： 123org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'myThreadUtils' defined in fileXXXXXXXXXX(省略)Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [cn.itcast.util.MyThreadUtils]: Constructor threw exception; nested exception is java.lang.NullPointerExceptionCaused by: java.lang.NullPointerException: null 空指针异常？检查好几遍配置没错。因为公司开发环境没法上网，只好拖到下班googel了一下，结合我比较深厚的基础（自恋一下），问题轻松解决： 这就是答案。上面说所有的Spring的@Autowired注解都在构造函数之后，而如果一个对象像下面代码一样声明（private XXX = new XXX() 直接在类中声明）的话，成员变量是在构造函数之前进行初始化的，甚至可以作为构造函数的参数。 即 成员变量初始化 -&gt; Constructor -&gt; @Autowired 所以，在这个时候如果成员变量初始化时调用了利用@Autowired注解初始化的对象时，必然会报空指针异常的啊。 真相大白了。如果解决呢？那就让上面我写的代码的成员变量threadPool在@Autowired之后执行就好了。 要想解决这个问题，首先要知道@Autowired的原理：AutowiredAnnotationBeanPostProcessor 这个类 其实看到这个继承结构，我心中已经有解决办法了。具体详细为什么，等997的工作结束（无奈）我会在后续博客里将Spring的注解配置详细的捋一遍，到时候会讲到Bean的生命周期的。 继承的BeanFactoryAware是在属性赋值完成，执行构造方法后,postProcessBeforeInitialization才执行,而且,是在其他生命周期之前，而@Autowired注解就是依靠这个原理进行的自动注入。想要解决这个问题很简单，就是把要赋值的成员变量放到其他生命周期中就可以。 下面介绍其中两种办法，第一种JSR250的@PostConstruct 1234@PostConstructpublic void init() &#123; // 这里放要执行的赋值&#125; 第二种是Spring的InitializingBean(定义初始化逻辑) ，继承接口实现方法即可，这种直接放上完整用法 1234567891011121314151617181920212223242526272829303132/** * @author Yaqiang Chen */@Componentpublic class MyThreadUtils implements InitializingBean &#123; @Autowired ThreadPool threadPool1; private ExecutorService threadPool; private ThreadFactory namedThreadFactory = new ThreadFactoryBuilder() .setNameFormat("pool-%d").build(); public void execute(Runnable runnable)&#123; threadPool.submit(runnable); &#125; @Override public void afterPropertiesSet() throws Exception &#123; threadPool = new ThreadPoolExecutor( threadPool1.getCorePoolSize(), threadPool1.getMaximumPoolSize(), threadPool1.getKeepAliveTime(), TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(threadPool1.getCapacity()), namedThreadFactory, new ThreadPoolExecutor.DiscardPolicy() ); &#125;&#125; 设置完成后，问题解决！]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeaFirst设计模式-单件模式[单例模式](Singleton Pattern)]]></title>
    <url>%2F2019%2F06%2F20%2FHeaFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton-Pattern%2F</url>
    <content type="text"><![CDATA[深入分析单件模式本次主要介绍的内容有 单件模式 单线程下的单件模式实现 多线程下实现单件模式出现的问题分析 JMM内存模型 多线程下的单件模式实现的三种方式 这些内容，可以从最根本理解单例模式的代码，不信你就来看看吧。 单件模式：确保一个类只有一个实例，并提供一个全局访问点。 单线程下的单件模式的实现在单线程下，不存在线程安全的问题，所以完成一个单件模式非常容易。Singleton 1234567891011121314151617181920package com.bestqiang.singleton;/** * @author BestQiang */public class Singleton &#123; private static Singleton uniqueInstance; // 这里是其他的有用实例化变量 private Singleton() &#123;&#125; // 用getInstance方法实例化对象，并返回这个实例。 public static Singleton getInstance() &#123; if(uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; // 不为空就直接返回，保证只有一个实例 return uniqueInstance; &#125;&#125; Main线程中调用getInstance方法获取实例 1234567891011121314package com.bestqiang.singleton;/** * @author BestQiang */public class Main &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; Singleton instance = Singleton.getInstance(); System.out.println(instance); &#125; &#125;&#125; 打印结果如下，这里可以看出，打印出的地址都是相同的，说明获取的是同一个实例。 12345678910com.bestqiang.singleton.Singleton@4554617ccom.bestqiang.singleton.Singleton@4554617ccom.bestqiang.singleton.Singleton@4554617ccom.bestqiang.singleton.Singleton@4554617ccom.bestqiang.singleton.Singleton@4554617ccom.bestqiang.singleton.Singleton@4554617ccom.bestqiang.singleton.Singleton@4554617ccom.bestqiang.singleton.Singleton@4554617ccom.bestqiang.singleton.Singleton@4554617ccom.bestqiang.singleton.Singleton@4554617c 多线程下实现单件模式出现的问题在这里我用线程池开启了10个线程，分别调用getInstance()方法获取对象，并打印响应的线程名和对象的地址： 123456789101112131415161718192021222324252627282930package com.bestqiang.multithreading;import com.bestqiang.singleton.Singleton;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author BestQiang */public class Main &#123; public static void main(String[] args) &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 10, 5L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(5)); try &#123; for (int i = 0; i &lt; 10; i++) &#123; threadPoolExecutor.execute(() -&gt; &#123; Singleton ins = Singleton.getInstance(); System.out.println(Thread.currentThread().getName() + "\t 对象地址: " + ins); &#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; threadPoolExecutor.shutdown(); &#125; &#125;&#125; 运行结果： 123456789101112pool-1-thread-8 对象地址: com.bestqiang.singleton.Singleton@4c680a74pool-1-thread-7 对象地址: com.bestqiang.singleton.Singleton@42970371pool-1-thread-5 对象地址: com.bestqiang.singleton.Singleton@4c680a74pool-1-thread-3 对象地址: com.bestqiang.singleton.Singleton@4c680a74pool-1-thread-4 对象地址: com.bestqiang.singleton.Singleton@4c680a74pool-1-thread-10 对象地址: com.bestqiang.singleton.Singleton@4c680a74pool-1-thread-1 对象地址: com.bestqiang.singleton.Singleton@3f41a236pool-1-thread-6 对象地址: com.bestqiang.singleton.Singleton@4c680a74pool-1-thread-9 对象地址: com.bestqiang.singleton.Singleton@4c680a74pool-1-thread-2 对象地址: com.bestqiang.singleton.Singleton@4c680a74Process finished with exit code 0 上图中，地址出现了不同的现象，这不是单例模式吗？为什么获取的对象会出现不同？ 内存不可见问题：当判断 if(uniqueInstance == null) 时，不同线程的本地内存都有uniqueInstance 的副本，这个副本可以理解为从主内存获取，然后放到本地内存，如下图JMM内存模型所示，注意这个本地内存是虚拟的，其实并不存在。 JMM内存模型：当线程更改本地内存中的值的时候，会刷新到主内存。使用的时候，本地内存有副本，那就不必再从主内存加载值了。比如现在线程A和线程B使用不同的CPU执行，第一种情况：现在线程A启动，发现本地内存没有uniqueInstance的副本，然后就从主内存获取，获取后，新建了Singleton对象，赋值给 uniqueInstance,然后刷新给主内存。线程B启动时发现自己本地内存没有uniqueInstance，然后从主内存获取，存在本地缓存中，此时这个变量已经被线程A赋值过了，不为空，就直接返回这个对象，这种情况下，是正常的。第二种情况，线程A启动，发现本地内存没有uniqueInstance的副本，然后就从主内存获取，获取后，新建了Singleton对象，赋值给 uniqueInstance,然后刷新给主内存。线程B启动的时候，发现本地内存没有uniqueInstance的副本，然后就从主内存获取，存在本地缓存中（此时线程A修改的值还没有刷新给主内存），获取后，新建了Singleton对象，赋值给 uniqueInstance,然后刷新给主内存。这样一来，就出现了单件模式出现不同对象的情况，造成这种情况的是内存不可见问题导致的。 原子性问题：如果内存不可见问题有人不了解，那么下面这个问题应该很多人都有所了解当判断 if(uniqueInstance == null) 时，假设现在uniqueInstance 不存在内存可见性的问题，这个操作包含两步，第一步是从主内存获取，第二部是进行比较，那么A线程获取的时候是null，接下来一瞬间此时B线程对uniqueInstance 进行了修改，产生了一个实例，并刷新到了主内存，但是A线程并不知道，紧接着继续比较，这时候为null，A线程会都执行到方法内部，创建对象，出现了两个实例，对于这种问题，可以使用加锁的方式来解决。 多线程下的单件模式实现的三种方式第一种：加锁解决线程安全问题从上面导致线程不安全的问题中，我们了解到单件模式中导致线程不安全的有两个重要因素，可见性和原子性，那么如何解决？加锁是一种较好的方式：代码如下： 12345678910111213141516171819202122package com.bestqiang.multithreading;import com.bestqiang.singleton.Singleton;/** * @author BestQiang */public class Singleton1 &#123; private static Singleton1 uniqueInstance; // 其他有用的实例化的变量 private Singleton1() &#123;&#125;; public static synchronized Singleton1 getInstance() &#123; if(uniqueInstance == null) &#123; uniqueInstance = new Singleton1(); &#125; return uniqueInstance; &#125; // 其他有用的方法&#125; 有同学在这里可能会疑惑，为什么加synchronized锁就解决了原子性和可见性的问题？这里我科普一下：synchronized块是Java提供的一种原子性内置锁，Java中的每个对象都可以把它单做一个同步锁来使用，这些Java内置的使用者看不到的锁被称为内部锁，也叫监视器锁。内置锁是排它锁，也就是当一个线程获取这个锁后，其他线程必须等待该线程释放锁后才能获取该锁。 synchronized的内存语义（重点）：进入synchronized块的内存语义是把在synchronized块内使用到的变量从线程的工作内存中清除，这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取，而是直接冲主内存中获取。退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存。 从它的内存语义中可得，它解决了变量的可见性的问题。它是Java提供的一种原子内置锁，解决了原子性的问题，二者都得到解决，所以，用它来实现同步方法，非常合适。 第二种：使用“急切”创建实例，而不用延迟实例化的做法上面的加同步锁的方法，会大大降低程序的性能，只有第一次执行此方法时，才真正需要同步。换句话说，一旦设置好uniqueInstance变量，就不再需要同步这个方法了。之后每次调用这个方法，同步都是一种累赘。如何改善呢？有一种方法简单有效，就是使用“急切”创建实例。话不多说，代码亮出来，就能明白了： 123456789101112131415package com.bestqiang.multithreading;import com.bestqiang.singleton.Singleton;/** * @author BestQiang */public class Singleton2 &#123; // 在静态初始化器中创建单件。这段代码保证了线程安全。 private static Singleton2 uniqueInstance = new Singleton2(); private Singleton2() &#123;&#125;; public static Singleton2 getInstance() &#123; return uniqueInstance; &#125;&#125; 其中静态单件在类的生命周期的连接的阶段创建，JVM在类的初始化方法\&lt;clinit>中创建。然后在jdk1.8的环境下存在堆中，类的元信息存在方法区。对于类的生命周期和JVM，可以从下面两篇文章做一下了解“init”与”clinit”的区别深入分析ClassLoader工作机制 因为uniqueInstance 创建过后就没有再改动，所以，不会出现线程安全的问题。 第三种：用“双重检查加锁”，在getInstance(）中减少使用同步利用双重检查加锁(double-checked locking),首先检查是否实例已经创建 了，如果尚未创建，”才”进行同步。这样一来，只有第一次会同步，这正是我们想要的。 代码如下： 12345678910111213141516171819202122232425262728package com.bestqiang.multithreading;import com.bestqiang.singleton.Singleton;/** * @author BestQiang */public class Singleton3 &#123; private volatile static Singleton3 uniqueInstance; // 这里是其他的有用实例化变量 private Singleton3() &#123;&#125; // 用getInstance方法实例化对象，并返回这个实例。 public static Singleton3 getInstance() &#123; // 检查实例，如果不存在，就进入同步区块，只有第一次，才彻底的执行这里的代码 if(uniqueInstance == null) &#123; // 进入区块后，再检查一次，如果仍是null，才创建实例 synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton3(); &#125; &#125; &#125; // 不为空就直接返回，保证只有一个实例 return uniqueInstance; &#125;&#125; 上面的代码中，为了解决对象创建时的指令重排序问题，使用了volatile关键字。为了解决原子性的问题，使用了synchronized 加锁。 volatile关键字（重要）关于Java中的volatile关键字，在这里做一下介绍：上面介绍了使用锁的方式可以解决共享变量内存可见性的问题，但是使用锁太笨重因为它会带来线程上下文的切换开销。对于解决内存可见性问题，Java还提供了一种弱形式的同步，也就是使用volatile关键字。该关键字可以确保对一个变量的更新对其他线程马上可见。当一个变量被声明为volatile时，线程在写入变量时不会吧值缓存再寄存器或者其他地方，而是会把值刷新回主内存。当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。volatile的内存语义和synchronized有相似之处，具体来说就是，当线程写入了volatile变量值时就等价于线程退出synchronized同步块(把写入工作内存的变量值同步到主内存)，读取volatile变量值时就相当于进入同步块( 先清空本地内存变量值，再从主内存获取最新值)。 第一个方法中提到，synchronized 可解决可见性和原子性的问题，为什么还要用双重锁呢，仔细看看，第一个 if(uniqueInstance == null) 判断存在原子性的问题，因为是先取，后比较，取过来之后可能又会更改，所以在里面嵌套一个 if(uniqueInstance == null)，里面这个是加锁的，加上happens-before规则可以保证原子性和可见性，保证uniqueInstance直接从主存中获取，而且，在第一次创建后，因为里面有原子性内置锁，所以uniqueInstance不会再更改，因此外面的 if(uniqueInstance == null) 其实是安全的了，因为获取后，可以保证不再更改，不会因为原子性而造成线程不安全的问题。这样，就做到了只在第一次同步一次，避免了锁影响性能，而又可以懒加载对象。 上面的操作乍一看是没问题的，但是其实存在问题。 对象创建分为三步： 分配对象的内存空间。memory = allocate(); 初始化对象。instance = memory; 设置instance指向内存空间。ctorInstance(memory); 这不是一个原子性操作，但即使不是原子性，这个操作也是没问题的，问题出在这个操作会进行重排序，可能第二部和第三步的顺序会发生变化，这时候第3步如果先执行，那么判断对象的值会依然为空，导致其他对象继续创建，导致单例模式的失败。 为什么要用volatile关键字呢？原因是volatile不仅仅可以保证程序的可见性，而且可以禁止指令重排序。至此，这个问题解决了。 注意： jdk 1.4 及更早的版本中，许多JVM对于volatile关键字的实现会导致双重检查加锁的失效。如果不能使用Java 1.4以上的版本，而必须使用旧版的Java，就请不要利用此技巧实现单件模式。 本次对单例模式的实现做了相对深入的分析，希望读完这篇文章的朋友都能有所收获，共同进步。 参考的书籍：《并发编程之美》，《HeadFirst设计模式》]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HeadFirst设计模式-工厂模式(基于汽车工厂和手机工厂)]]></title>
    <url>%2F2019%2F06%2F20%2FHeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E5%9F%BA%E4%BA%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E5%8E%82%E5%92%8C%E6%89%8B%E6%9C%BA%E5%B7%A5%E5%8E%82%2F</url>
    <content type="text"><![CDATA[工厂模式本次主要讲述三个内容： 简单工厂模式 工厂方法模式 抽象工厂模式 依赖倒置原则设计原则：要依赖抽象，不要依赖具体类。 不能让高层组件依赖底层组件，而且，不管高层或底层组件，“两者”都应该依赖于抽象。这个原则告诉我们，应该重写代码以便于我们依赖抽象类，而不依赖具体类。 指导方针： 变量不可以持有具体类的引用。（如果使用new，就会持有具体类的引用。你可以改用工厂类避开这样的做法。） 不要让类派生自具体类。（如果派生自具体类，你就会依赖具体类。请派生自一个抽象（接口或抽象类）） 不要覆盖基类中已实现的方法。（如果覆盖基类已经实现的方法，那么你的基类将就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享） 简单工厂模式简单工厂模式不是一个“真正的”设计模式，只能说是一种编程习惯。比如建立一个抽象类Car，然后用子类来继承。用SimpleCarFactory来生成对象（里面包含选择相应对象的逻辑处理），CarStrore直接调用SimpleCarFactory即可。如上图所示。代码实现如下：Car ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.bestqiang.easyfactory;/** * @author BestQiang */public abstract class Car &#123; private String color; private String price; private String speed; public abstract void go(); public abstract void clear(); @Override public String toString() &#123; return "Car&#123;" + "color='" + color + '\'' + ", price='" + price + '\'' + ", speed='" + speed + '\'' + '&#125;'; &#125; public void sayHello() &#123; System.out.println("我是" + color + "汽车," + " 我的价格是: " + price + "," + "速度是:" + speed); &#125; public String getSpeed() &#123; return speed; &#125; public void setSpeed(String speed) &#123; this.speed = speed; &#125; public String getColor() &#123; return color; &#125; public String getPrice() &#123; return price; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void setPrice(String price) &#123; this.price = price; &#125;&#125; BlueCar: 123456789101112131415161718192021package com.bestqiang.easyfactory;/** * @author BestQiang */public class BlueCar extends Car &#123; public BlueCar() &#123; super("blue","2000$", "888km/s"); &#125; @Override public void go() &#123; System.out.println("蓝汽车清洗完成了！"); &#125; @Override public void clear() &#123; System.out.println("蓝汽车可以开走了！"); &#125;&#125; RedCar: 123456789101112131415161718192021package com.bestqiang.easyfactory;/** * @author BestQiang */public class RedCar extends Car &#123; public RedCar() &#123; super("red","1000$", "999km/s"); &#125; @Override public void go() &#123; System.out.println("红汽车可以开走了！"); &#125; @Override public void clear() &#123; System.out.println("红汽车清洗完成了！"); &#125;&#125; SimpleFactory: 12345678910111213141516package com.bestqiang.easyfactory;/** * @author BestQiang */public class SimpleCarFactory &#123; public Car createCar(String type) &#123; Car car = null; if(type.equals("red")) &#123; return new RedCar(); &#125; else if (type.equals("blue")) &#123; return new BlueCar(); &#125; return car; &#125;&#125; CarStore: 12345678910111213141516package com.bestqiang.easyfactory;/** * @author BestQiang */public class CarStore &#123; SimpleCarFactory simpleCarFactory = new SimpleCarFactory(); public Car orderCar(String type) &#123; Car car = simpleCarFactory.createCar(type); car.sayHello(); car.clear(); car.go(); return car; &#125;&#125; Main: 123456789101112131415package com.bestqiang.easyfactory;/** * @author BestQiang */public class Main &#123; public static void main(String[] args) &#123; // 没有依赖抽象类，下面的工厂模式会对其改进 CarStore carStore = new CarStore(); Car blue = carStore.orderCar("blue"); Car red = carStore.orderCar("red"); System.out.println(blue); System.out.println(red); &#125;&#125; 运行结果： 12345678910我是blue汽车, 我的价格是: 2000$,速度是:888km/s蓝汽车可以开走了！蓝汽车清洗完成了！我是red汽车, 我的价格是: 1000$,速度是:999km/s红汽车清洗完成了！红汽车可以开走了！Car&#123;color='blue', price='2000$', speed='888km/s'&#125;Car&#123;color='red', price='1000$', speed='999km/s'&#125;Process finished with exit code 0 工厂方法模式刚才的简单工厂模式，只有一个工厂，不能动态的切换工厂。所有的工厂模式都用来封装对象的创建。工厂方法模式（Factory Method Pattern）通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。 简单工厂把全部的事情，在一个地方都处理完了，然而工厂方法却是创建一个框架，让子类决定要如何实现。等于说是如下图所示：简单工厂的做法，可以将对象的创建封装起来，但是简单工程不具备工厂方法的弹性，因为简单工厂不能变更正在创建的产品。Main新建工厂的时候直接new抽象类就ok了。 工厂类的实现代码：CarStoreF: 123456789101112131415161718192021package com.bestqiang.factory;import com.bestqiang.easyfactory.Car;import com.bestqiang.easyfactory.SimpleCarFactory;/** * @author BestQiang */public abstract class CarStoreF &#123; public Car orderCar(String type) &#123; Car car = createCar(type); car.sayHello(); car.clear(); car.go(); return car; &#125; protected abstract Car createCar(String type);&#125; HuaweiCarStore: 1234567891011121314151617181920212223package com.bestqiang.factory;import com.bestqiang.easyfactory.BlueCar;import com.bestqiang.easyfactory.Car;import com.bestqiang.easyfactory.RedCar;/** * @author BestQiang */public class HuaweiCarStore extends CarStoreF &#123; @Override protected Car createCar(String type) &#123; Car car = null; if(type.equals("red")) &#123; System.out.println("Huawei出品"); return new RedCar(); &#125; else if (type.equals("blue")) &#123; System.out.println("Huawei出品"); return new BlueCar(); &#125; return car; &#125;&#125; XiaomiCarStore: 1234567891011121314151617181920212223package com.bestqiang.factory;import com.bestqiang.easyfactory.BlueCar;import com.bestqiang.easyfactory.Car;import com.bestqiang.easyfactory.RedCar;/** * @author BestQiang */public class XiaomiCarStore extends CarStoreF &#123; @Override protected Car createCar(String type) &#123; Car car = null; if(type.equals("red")) &#123; System.out.println("小米出品"); return new RedCar(); &#125; else if (type.equals("blue")) &#123; System.out.println("小米出品"); return new BlueCar(); &#125; return car; &#125;&#125; Main: 123456789101112131415161718package com.bestqiang.factory;import com.bestqiang.easyfactory.Car;import com.bestqiang.easyfactory.CarStore;/** * @author BestQiang */public class Main &#123; public static void main(String[] args) &#123; // 依赖于抽象类 CarStoreF carStore = new HuaweiCarStore(); Car blue = carStore.orderCar("blue"); Car red = carStore.orderCar("red"); System.out.println(blue); System.out.println(red); &#125;&#125; 运行结果： 12345678910我是blue汽车, 我的价格是: 2000$,速度是:888km/s蓝汽车可以开走了！蓝汽车清洗完成了！我是red汽车, 我的价格是: 1000$,速度是:999km/s红汽车清洗完成了！红汽车可以开走了！Car&#123;color='blue', price='2000$', speed='888km/s'&#125;Car&#123;color='red', price='1000$', speed='999km/s'&#125;Process finished with exit code 0 抽象工厂模式抽象工程模式： 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道（或关心）实际产出的具体产品是什么。这样一来，客户就从具体的产品中被解耦。 抽象工厂定义了一个接口，所有的具体工程都必须实现此接口，这个接口包含一组方法用来生产产品。当要创建产品家族和想让制造的相关产品集合起来时，可以使用抽象工厂。 可以这样理解，现在汽车工厂只生产汽车，现在如果还想生产手机，再继承原来汽车的抽象类，复用抽象类的已有的方法，实现抽象方法，就不合适了。那就建立一个抽象工厂，而且把抽象工厂设置为接口，把所有涉及的产品都写进去，然后后面再实现这个接口。又可以这样理解，抽象工厂比工厂模式高一个级别，抽象工厂在乎的是生产的汽车还是手机，而工厂模式在乎的是生产的手机是什么样子的。在确定生产什么以后，工厂模式往往隐含在抽象工厂中。 下图中新增一个手机类，然后使用抽象工厂进行创建。实现代码如下：Phone： 1234567891011121314151617181920212223242526272829303132333435package com.bestqiang.AFactory;/** * @author BestQiang */public abstract class Phone &#123; private int color; private int price; @Override public String toString() &#123; return "Phone&#123;" + "color=" + color + ", price=" + price + '&#125;'; &#125; public int getColor() &#123; return color; &#125; public void setColor(int color) &#123; this.color = color; &#125; public int getPrice() &#123; return price; &#125; public void setPrice(int price) &#123; this.price = price; &#125; protected abstract void call();&#125; HuaweiPhone： 1234567891011package com.bestqiang.AFactory;/** * @author BestQiang */public class HuaweiPhone extends Phone &#123; @Override protected void call() &#123; System.out.println("华为，非一般的感觉！"); &#125;&#125; XiaomiPhone： 1234567891011package com.bestqiang.AFactory;/** * @author BestQiang */public class XiaomiPhone extends Phone &#123; @Override protected void call() &#123; System.out.println("小米，永不止步！"); &#125;&#125; Factory： 1234567891011package com.bestqiang.AFactory;import com.bestqiang.easyfactory.Car;/** * @author BestQiang */public abstract class Factory &#123; public abstract Phone phoneFactory(String type); public abstract Car carFactory(String type);&#125; FactoryA： 12345678910111213141516171819202122232425262728293031323334353637383940package com.bestqiang.AFactory;import com.bestqiang.easyfactory.BlueCar;import com.bestqiang.easyfactory.Car;import com.bestqiang.easyfactory.RedCar;/** * @author BestQiang */public class FactoryA extends Factory &#123; @Override public Phone phoneFactory(String type) &#123; if(type.equals("huawei")) &#123; print(); return new HuaweiPhone(); &#125; if (type.equals("XiaomiPhone")) &#123; print(); return new XiaomiPhone(); &#125; return null; &#125; @Override public Car carFactory(String type) &#123; if(type.equals("red")) &#123; print(); return new RedCar(); &#125; if (type.equals("blue")) &#123; print(); return new BlueCar(); &#125; return null; &#125; private void print() &#123; System.out.println("A工厂出品"); &#125;&#125; FactoryB： 123456789101112131415161718192021222324252627282930313233343536373839package com.bestqiang.AFactory;import com.bestqiang.easyfactory.BlueCar;import com.bestqiang.easyfactory.Car;import com.bestqiang.easyfactory.RedCar;/** * @author BestQiang */public class FactoryB extends Factory &#123; @Override public Phone phoneFactory(String type) &#123; if(type.equals("huawei")) &#123; print(); return new HuaweiPhone(); &#125; if (type.equals("XiaomiPhone")) &#123; print(); return new XiaomiPhone(); &#125; return null; &#125; @Override public Car carFactory(String type) &#123; if(type.equals("red")) &#123; print(); return new RedCar(); &#125; if(type.equals("blue")) &#123; print(); return new BlueCar(); &#125; return null; &#125; private void print() &#123; System.out.println("B工厂出品"); &#125;&#125; 1234567891011121314package com.bestqiang.AFactory;import com.bestqiang.easyfactory.Car;/** * @author BestQiang */public class Main &#123; public static void main(String[] args) &#123; Factory factory = new FactoryA(); Car red = factory.carFactory("red"); System.out.println(red); &#125;&#125; 运行结果： 1234A工厂出品Car&#123;color='red', price='1000$', speed='999km/s'&#125;Process finished with exit code 0 三种工厂模式算是介绍完了，总结一下， 简单工厂模式不能动态切换工厂，不依赖与抽象。 工厂方法模式创建一个抽象的工厂类，子类进行继承实现，可以动态切换工厂，适合同一种类。 抽象工厂模式把多个工厂隐含在里面，可以把相关的产品集合起来。是工厂模式的升级。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J2EE基础知识总结]]></title>
    <url>%2F2019%2F06%2F19%2FJ2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Servlet总结 阐述Servlet和CGI的区别? CGI的不足之处: Servlet的优点： Servlet接口中有哪些方法及Servlet生命周期探秘 get和post请求的区别 什么情况下调用doGet()和doPost() 转发（Forward）和重定向（Redirect）的区别 自动刷新(Refresh) Servlet与线程安全 JSP和Servlet是什么关系 JSP工作原理 JSP有哪些内置对象、作用分别是什么 Request对象的主要方法有哪些 request.getAttribute()和 request.getParameter()有何区别 include指令include的行为的区别 JSP九大内置对象，七大动作，三大指令 讲解JSP中的四种作用域 如何实现JSP或Servlet的单线程模式 实现会话跟踪的技术有哪些 Cookie和Session的的区别 Servlet总结在Java Web程序中，Servlet主要负责接收用户请求 HttpServletRequest,在doGet(),doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户。Servlet 可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用init()方法，销毁时调用destroy()方法。Servlet需要在web.xml中配置（MyEclipse中创建Servlet会自动配置），一个Servlet可以设置多个URL访问。Servlet不是线程安全，因此要谨慎使用类变量。 阐述Servlet和CGI的区别?CGI的不足之处:1，需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。 2，需要为每个请求加载和运行一个CGI程序，这将带来很大的开销 3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。 Servlet的优点:1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销 2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销 3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。 4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。 补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。 参考：《javaweb整合开发王者归来》P7 Servlet接口中有哪些方法及Servlet生命周期探秘Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关： void init(ServletConfig config) throws ServletException void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException void destory() java.lang.String getServletInfo() ServletConfig getServletConfig() 生命周期： Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。 参考：《javaweb整合开发王者归来》P81 get和post请求的区别 网上也有文章说：get和post请求实际上是没有区别，大家可以自行查询相关文章（参考文章：https://www.cnblogs.com/logsharing/p/8448446.html，知乎对应的问题链接：get和post区别？）！我下面给出的只是一种常见的答案。 ①get请求用来从服务器上获得资源，而post是用来向服务器提交数据； ②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL； ③get传输的数据要受到URL长度限制（最大长度是 2048 个字符）；而post可以传输大量的数据，上传文件通常要使用post方式； ④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post； ⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。 补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。 还有另外一种回答。推荐大家看一下： https://www.zhihu.com/question/28586791 https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd 什么情况下调用doGet()和doPost()Form标签里的method的属性为get时调用doGet()，为post时调用doPost()。 转发(Forward)和重定向(Redirect)的区别转发是服务器行为，重定向是客户端行为。 转发（Forward）通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。 1request.getRequestDispatcher("login_success.jsp").forward(request, response); 重定向（Redirect） 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 HttpServletResponse 的 setStatus(int status) 方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。 从地址栏显示来说 forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL. 从数据共享来说 forward:转发页面和转发到的页面可以共享request里面的数据.redirect:不能共享数据. 从运用地方来说 forward:一般用于用户登陆的时候,根据角色转发到相应的模块.redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等 从效率来说 forward:高.redirect:低. 自动刷新(Refresh)自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如： 1Response.setHeader("Refresh","5;URL=http://localhost:8080/servlet/example.htm"); 其中5为时间，单位为秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现每过5秒自动刷新本页面一次） Servlet与线程安全Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。 解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。 参考：《javaweb整合开发王者归来》P92 JSP和Servlet是什么关系其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。 JSP工作原理JSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。工程JspLoginDemo下有一个名为login.jsp的Jsp文件，把工程第一次部署到服务器上后访问这个Jsp文件，我们发现这个目录下多了下图这两个东东。.class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。由于JSP只会在客户端第一次请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP。 开发Web程序时经常需要修改JSP。Tomcat能够自动检测到JSP程序的改动。如果检测到JSP源代码发生了改动。Tomcat会在下次客户端请求JSP时重新编译JSP，而不需要重启Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署Web应用的时候可以在web.xml中将它关掉。 参考：《javaweb整合开发王者归来》P97 JSP有哪些内置对象、作用分别是什么JSP内置对象 - CSDN博客 JSP有9个内置对象： request：封装客户端的请求，其中包含来自GET或POST请求的参数； response：封装服务器对客户端的响应； pageContext：通过该对象可以获取其他对象； session：封装用户会话的对象； application：封装服务器运行环境的对象； out：输出服务器响应的输出流对象； config：Web应用的配置对象； page：JSP页面本身（相当于Java程序中的this）； exception：封装页面抛出异常的对象。 Request对象的主要方法有哪些 setAttribute(String name,Object)：设置名字为name的request 的参数值 getAttribute(String name)：返回由name指定的属性值 getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例 getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组 getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度 getHeader(String name) ：获得HTTP协议定义的文件头信息 getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例 getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例 getInputStream() ：返回请求的输入流，用于获得请求中的数据 getMethod() ：获得客户端向服务器端传送数据的方法 getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值 getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例 getParameterValues(String name)：获得有name指定的参数的所有值 getProtocol()：获取客户端向服务器端传送数据所依据的协议名称 getQueryString() ：获得查询字符串 getRequestURI() ：获取发出请求字符串的客户端地址 getRemoteAddr()：获取客户端的 IP 地址 getRemoteHost() ：获取客户端的名字 getSession([Boolean create]) ：返回和请求相关 Session getServerName() ：获取服务器的名字 getServletPath()：获取客户端所请求的脚本文件的路径 getServerPort()：获取服务器的端口号 removeAttribute(String name)：删除请求中的一个属性 request.getAttribute()和 request.getParameter()有何区别从获取方向来看： getParameter()是获取 POST/GET 传递的参数值； getAttribute()是获取对象容器中的数据值； 从用途来看： getParameter()用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。 getAttribute() 用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。 另外，可以用 setAttribute(),getAttribute() 发送接收对象.而 getParameter() 显然只能传字符串。setAttribute() 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样getAttribute()就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。getParameter()只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。 总结： getParameter()返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等） getAttribute()返回的是Object，需进行转换,可用setAttribute()设置成任意对象，使用很灵活，可随时用 include指令include的行为的区别include指令： JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 语法格式如下：&lt;%@ include file=”文件相对 url 地址” %&gt; include动作： &lt;jsp:include&gt;动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下：&lt;jsp:include page=”相对 URL 地址” flush=”true” /&gt; JSP九大内置对象，七大动作，三大指令JSP九大内置对象，七大动作，三大指令总结 讲解JSP中的四种作用域JSP中的四种作用域包括page、request、session和application，具体来说： page代表与一个页面相关的对象和属性。 request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。 session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。 application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。 如何实现JSP或Servlet的单线程模式对于JSP页面，可以通过page指令进行设置。&lt;%@page isThreadSafe=”false”%&gt; 对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。 说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。 实现会话跟踪的技术有哪些 使用Cookie 向客户端发送Cookie 123Cookie c =new Cookie("name","value"); //创建Cookie c.setMaxAge(60*60*24); //设置最大时效，此处设置的最大时效为一天response.addCookie(c); //把Cookie放入到HTTP响应中 从客户端读取Cookie 123456789101112String name ="name"; Cookie[]cookies =request.getCookies(); if(cookies !=null)&#123; for(int i= 0;i&lt;cookies.length;i++)&#123; Cookie cookie =cookies[i]; if(name.equals(cookis.getName())) //something is here. //you can get the value cookie.getValue(); &#125; &#125; 优点: 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value 缺点: 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。 URL 重写 在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。 优点： 在Cookie被禁用的时候依然可以使用 缺点： 必须对网站的URL进行编码，所有页面必须动态生成，不能用预先记录下来的URL进行访问。 3.隐藏的表单域 1&lt;input type="hidden" name ="session" value="..."/&gt; 优点： Cookie被禁时可以使用 缺点： 所有页面必须是表单提交之后的结果。 HttpSession 在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。 Cookie和Session的的区别Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。 Cookie 一般用来保存用户信息 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。 Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。 Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>J2EE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NIO源码分析之Selector]]></title>
    <url>%2F2019%2F06%2F08%2FNIO%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BSelector%2F</url>
    <content type="text"><![CDATA[NIO源码分析之SelectorNIO的Selector源码第一句话就是 A multiplexor of {@link SelectableChannel} objects. 即 SelectableChannel对象的多路复用器。这很清楚的说明了Selector的作用。 这篇文章主要从以下几个点对Selector进行分析： 选择器（Selector） 可选择通道（SelectableChannel） 选择键（SelectionKey） Selector完整实例 SelectorSelector选择器类管理着一个被注册的通道集合的信息和它们的就绪状态。通道是和选择器一起被注册的，并且使用选择器来更新通道的就绪状态。当这么做的时候，可以选择将被激发的线程挂起，直到有就绪的的通道。 下面是使用Selector管理多个channel的结构图： Selector的创建 A selector may be created by invoking the open method of this class, which will use the system’s default selector provider to create a new selector. A selector may also be created by invoking the openSelector method of a custom selector provider. A selector remains open until it is closed via its close method. 可以通过调用此类的open方法来创建选择器，该方法将使用系统的默认选择器提供程序来创建新的选择器。 还可以通过调用自定义选择器提供程序的openSelector方法来创建选择器。 选择器保持打开状态，直到通过其关闭方法关闭。 Selector可以调用静态方法open()来创建Selector 1Selector Selector=Selector.open()； openSelector() 是通过系统的默认获取 123456789101112131415java.nio.channels.spi.SelectorProvider public static SelectorProvider provider()Returns the system-wide default selector provider for this invocation of the Java virtual machine.The first invocation of this method locates the default provider object as follows:If the system property java.nio.channels.spi.SelectorProvider is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named java.nio.channels.spi.SelectorProvider in the resource directory META-INF/services, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.Finally, if no provider has been specified by any of the above means then the system-default provider class is instantiated and the result is returned.Subsequent invocations of this method return the provider that was returned by the first invocation.java.nio.channels.spi.SelectorProvider public static SelectorProvider provider（）返回此Java虚拟机调用的系统范围默认选择器提供程序。第一次调用此方法将按如下方式定位默认提供程序对象：如果定义了系统属性java.nio.channels.spi.SelectorProvider，那么它将被视为具体提供程序类的完全限定名称。该类被加载并实例化;如果此过程失败，则抛出未指定的错误。如果提供程序类已安装在对系统类加载器可见的jar文件中，并且该jar文件在资源目录META-INF / services中包含名为java.nio.channels.spi.SelectorProvider的提供程序配置文件，然后获取该文件中指定的第一个类名。该类被加载并实例化;如果此过程失败，则抛出未指定的错误。最后，如果没有通过上述任何方式指定提供程序，则实例化系统缺省提供程序类并返回结果。此方法的后续调用将返回第一次调用返回的提供程序。 为provider的类。 由以上的源码可见它加了锁，是线程安全的 SelectableChannel SelectableChannel这个抽象类提供了实现通道的可选择性所需要的公共方法。它是所有支持就绪检查的通道类的父类。因为FileChannel类没有继承SelectableChannel因此是不是可选通道，而所有socket通道都是可选择的，包括从管道(Pipe)对象的中获得的通道。SelectableChannel可以被注册到Selector对象上，同时可以指定对那个选择器而言，那种操作是感兴趣的。一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。 源码上对它的介绍： 1234567891011121314151617A channel that can be multiplexed via a Selector.In order to be used with a selector, an instance of this class must first be registered via the register method. This method returns a new SelectionKey object that represents the channel&apos;s registration with the selector.Once registered with a selector, a channel remains registered until it is deregistered. This involves deallocating whatever resources were allocated to the channel by the selector.A channel cannot be deregistered directly; instead, the key representing its registration must be cancelled. Cancelling a key requests that the channel be deregistered during the selector&apos;s next selection operation. A key may be cancelled explicitly by invoking its cancel method. All of a channel&apos;s keys are cancelled implicitly when the channel is closed, whether by invoking its close method or by interrupting a thread blocked in an I/O operation upon the channel.If the selector itself is closed then the channel will be deregistered, and the key representing its registration will be invalidated, without further delay.A channel may be registered at most once with any particular selector.Whether or not a channel is registered with one or more selectors may be determined by invoking the isRegistered method.Selectable channels are safe for use by multiple concurrent threads.可以通过选择器进行多路复用的通道。为了与选择器一起使用，必须首先通过register方法注册该类的实例。此方法返回一个新的SelectionKey对象，该对象表示通道与选择器的注册。一旦注册选择器，通道将保持注册状态，直到它被注销。这涉及解除分配选择器分配给通道的任何资源。渠道不能直接注销;相反，必须取消代表其注册的密钥。取消密钥请求在选择器的下一个选择操作期间取消注册该通道。可以通过调用其cancel方法显式取消密钥。当通道关闭时，无论是通过调用其close方法还是通过中断在通道上的I / O操作中阻塞的线程，所有通道的键都会被隐式取消。如果选择器本身已关闭，则将取消注册该通道，并且表示其注册的密钥将无效，而不会有进一步的延迟。一个频道最多可以与任何特定选择器一起注册一次。可以通过调用isRegistered方法来确定是否向一个或多个选择器注册了频道。多个并发线程可以安全地使用可选择的通道。 SelectableChannel中有两个个方法为register，但是其实是一个方法 因为底层实现都是一样的，只不过第一个方法调用时第三个参数设置为null。 它的抽象类AbstractSelectableChannel实现了这个抽象方法，注释为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475使用给定的选择器注册此通道，返回选择键。此方法首先验证此通道是否已打开，以及给定的初始兴趣集是否有效。如果此通道已在给定选择器中注册，则在将其兴趣设置为给定值后，将返回表示该注册的选择键。否则，此通道尚未在给定的选择器中注册，因此在保持适当的锁定时调用选择器的register方法。返回后，生成的密钥将添加到此通道的密钥集中。具体说明：在SelectableChannel类中注册PARAMS：sel - 要注册此通道的选择器ops - 为结果密钥设置的兴趣att - 生成密钥的附件;可能是null返回：表示使用给定选择器注册此通道的键抛出：ClosedSelectorException - 如果选择器已关闭IllegalBlockingModeException - 如果此通道处于阻塞模式IllegalSelectorException - 如果此通道不是由与给定选择器相同的提供程序创建的CancelledKeyException - 如果此通道当前已在给定选择器中注册，但相应的键已被取消IllegalArgumentException - 如果ops set中的某个位与此通道支持的操作不对应，即，如果set＆~validOps（）！= 0ClosedChannelException - 如果此通道已关闭 /** * Registers this channel with the given selector, returning a selection key. * * &lt;p&gt; This method first verifies that this channel is open and that the * given initial interest set is valid. * * &lt;p&gt; If this channel is already registered with the given selector then * the selection key representing that registration is returned after * setting its interest set to the given value. * * &lt;p&gt; Otherwise this channel has not yet been registered with the given * selector, so the &#123;@link AbstractSelector#register register&#125; method of * the selector is invoked while holding the appropriate locks. The * resulting key is added to this channel's key set before being returned. * &lt;/p&gt; * * @throws ClosedSelectorException &#123;@inheritDoc&#125; * * @throws IllegalBlockingModeException &#123;@inheritDoc&#125; * * @throws IllegalSelectorException &#123;@inheritDoc&#125; * * @throws CancelledKeyException &#123;@inheritDoc&#125; * * @throws IllegalArgumentException &#123;@inheritDoc&#125; */ public final SelectionKey register(Selector sel, int ops, Object att) throws ClosedChannelException &#123; synchronized (regLock) &#123; if (!isOpen()) throw new ClosedChannelException(); if ((ops &amp; ~validOps()) != 0) throw new IllegalArgumentException(); if (blocking) throw new IllegalBlockingModeException(); SelectionKey k = findKey(sel); if (k != null) &#123; k.interestOps(ops); k.attach(att); &#125; if (k == null) &#123; // New registration synchronized (keyLock) &#123; if (!isOpen()) throw new ClosedChannelException(); k = ((AbstractSelector)sel).register(this, ops, att); addKey(k); &#125; &#125; return k; &#125; &#125; 要实现Selector管理Channel，需要将channel注册到相应的Selector上，如下： 12channel.configureBlocking(false);SelectionKey key= channel.register(selector,SelectionKey.OP_READ); 通过调用通道的register()方法会将它注册到一个选择器上。与Selector一起使用时，Channel必须处于非阻塞模式下，否则将抛出IllegalBlockingModeException异常，这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式，而套接字通道都可以。另外通道一旦被注册，将不能再回到阻塞状态，此时若调用通道的configureBlocking(true)将抛出BlockingModeException异常。 register()方法的第二个参数是“interest集合”，表示选择器所关心的通道操作，它实际上是一个表示选择器在检查通道就绪状态时需要关心的操作的比特掩码。比如一个选择器对通道的read和write操作感兴趣，那么选择器在检查该通道时，只会检查通道的read和write操作是否已经处在就绪状态。它有以下四种操作类型： Connect 连接 Accept 接受 Read 读 Write 写 需要注意并非所有的操作在所有的可选择通道上都能被支持，比如ServerSocketChannel支持Accept，而SocketChannel中不支持。我们可以通过通道上的validOps()方法来获取特定通道下所有支持的操作集合。 JAVA中定义了四个常量来表示这四种操作类型： SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 如果Selector对通道的多操作类型感兴趣，可以用“位或”操作符来实现： int interestSet=SelectionKey.OP_READ|SelectionKey.OP_WRITE;当通道触发了某个操作之后，表示该通道的某个操作已经就绪，可以被操作。因此，某个SocketChannel成功连接到另一个服务器称为“连接就绪”(OP_CONNECT)。一个ServerSocketChannel准备好接收新进入的连接称为“接收就绪”（OP_ACCEPT）。一个有数据可读的通道可以说是“读就绪”(OP_READ)。等待写数据的通道可以说是“写就绪”(OP_WRITE)。 我们注意到register（）方法会返回一个SelectionKey对象，我们称之为键对象。下面会对键对象详细说明。 ServerSocketChannel 源码上的介绍： 1234567891011121314151617181920212223A selectable channel for stream-oriented listening sockets.A server-socket channel is created by invoking the open method of this class. It is not possible to create a channel for an arbitrary, pre-existing ServerSocket. A newly-created server-socket channel is open but not yet bound. An attempt to invoke the accept method of an unbound server-socket channel will cause a NotYetBoundException to be thrown. A server-socket channel can be bound by invoking one of the bind methods defined by this class.Socket options are configured using the setOption method. Server-socket channels support the following options:Option NameDescriptionSO_RCVBUFThe size of the socket receive bufferSO_REUSEADDRRe-use addressAdditional (implementation specific) options may also be supported.Server-socket channels are safe for use by multiple concurrent threads.面向流的侦听套接字的可选通道。通过调用此类的open方法创建服务器套接字通道。 无法为任意预先存在的ServerSocket创建通道。 新创建的服务器套接字通道已打开但尚未绑定。 尝试调用未绑定的服务器套接字通道的accept方法将导致抛出NotYetBoundException。 可以通过调用此类定义的绑定方法之一来绑定服务器套接字通道。使用setOption方法配置套接字选项。 服务器套接字通道支持以下选项：选项名称描述SO_RCVBUF套接字接收缓冲区的大小SO_REUSEADDR重复使用地址还可以支持其他（特定于实现的）选项。服务器套接字通道可供多个并发线程使用。 ServerSocketChannel继承了AbstractSelectableChannel AbstractSelectableChannel继承了SelectableChannel,所以，ServerSocketChannel注册到Selector上 SocketChannel 源码上的介绍： 12345678910111213141516171819202122232425262728293031323334353637383940414243A selectable channel for stream-oriented connecting sockets.A socket channel is created by invoking one of the open methods of this class. It is not possible to create a channel for an arbitrary, pre-existing socket. A newly-created socket channel is open but not yet connected. An attempt to invoke an I/O operation upon an unconnected channel will cause a NotYetConnectedException to be thrown. A socket channel can be connected by invoking its connect method; once connected, a socket channel remains connected until it is closed. Whether or not a socket channel is connected may be determined by invoking its isConnected method.Socket channels support non-blocking connection: A socket channel may be created and the process of establishing the link to the remote socket may be initiated via the connect method for later completion by the finishConnect method. Whether or not a connection operation is in progress may be determined by invoking the isConnectionPending method.Socket channels support asynchronous shutdown, which is similar to the asynchronous close operation specified in the Channel class. If the input side of a socket is shut down by one thread while another thread is blocked in a read operation on the socket&apos;s channel, then the read operation in the blocked thread will complete without reading any bytes and will return -1. If the output side of a socket is shut down by one thread while another thread is blocked in a write operation on the socket&apos;s channel, then the blocked thread will receive an AsynchronousCloseException.Socket options are configured using the setOption method. Socket channels support the following options:Option NameDescriptionSO_SNDBUFThe size of the socket send bufferSO_RCVBUFThe size of the socket receive bufferSO_KEEPALIVEKeep connection aliveSO_REUSEADDRRe-use addressSO_LINGERLinger on close if data is present (when configured in blocking mode only)TCP_NODELAYDisable the Nagle algorithmAdditional (implementation specific) options may also be supported.Socket channels are safe for use by multiple concurrent threads. They support concurrent reading and writing, though at most one thread may be reading and at most one thread may be writing at any given time. The connect and finishConnect methods are mutually synchronized against each other, and an attempt to initiate a read or write operation while an invocation of one of these methods is in progress will block until that invocation is complete.用于面向流的连接套接字的可选通道。通过调用此类的一个打开方法来创建套接字通道。无法为任意预先存在的套接字创建通道。新创建的套接字通道已打开但尚未连接。尝试在未连接的通道上调用I / O操作将导致抛出NotYetConnectedException。可以通过调用connect方法连接套接字通道;连接后，插座通道保持连接状态，直到它关闭。是否连接套接字通道可以通过调用其isConnected方法来确定。套接字通道支持非阻塞连接：可以创建套接字通道，并且可以通过connect方法启动建立到远程套接字的链接的过程，以便稍后通过finishConnect方法完成。可以通过调用isConnectionPending方法来确定连接操作是否正在进行。套接字通道支持异步关闭，这类似于Channel类中指定的异步关闭操作。如果套接字的输入端被一个线程关闭而另一个线程在套接字通道上的读操作中被阻塞，那么被阻塞线程中的读操作将完成而不读取任何字节并返回-1。如果套接字的输出端被一个线程关闭而另一个线程在套接字通道上的写操作中被阻塞，则被阻塞的线程将收到AsynchronousCloseException。使用setOption方法配置套接字选项。套接字通道支持以下选项：选项名称描述SO_SNDBUF套接字发送缓冲区的大小SO_RCVBUF套接字接收缓冲区的大小SO_KEEPALIVE保持连接活着SO_REUSEADDR重复使用地址SO_LINGER如果存在数据则关闭（仅在阻止模式下配置时）TCP_NODELAY禁用Nagle算法还可以支持其他（特定于实现的）选项。套接字通道可以安全地由多个并发线程使用。它们支持并发读写，但最多只有一个线程可能正在读取，并且最多一个线程可能在任何给定时间写入。 connect和finishConnect方法彼此相互同步，并且在调用其中一个方法时尝试启动读取或写入操作将阻塞，直到该调用完成。 SocketChannel 继承了AbstractSelectableChannel，同ServerSocketChannel一样，可以注册到Selector。 SelectionKey选择键封装了特定的通道与特定的选择器的注册关系。选择键对象被SelectableChannel.register()返回并提供一个表示这种注册关系的标记。选择键包含了两个比特集(以整数的形式进行编码)，指示了该注册关系所关心的通道操作，以及通道已经准备好的操作。 源码中这样说： 12345678910111213141516171819A token representing the registration of a SelectableChannel with a Selector.A selection key is created each time a channel is registered with a selector. A key remains valid until it is cancelled by invoking its cancel method, by closing its channel, or by closing its selector. Cancelling a key does not immediately remove it from its selector; it is instead added to the selector&apos;s cancelled-key set for removal during the next selection operation. The validity of a key may be tested by invoking its isValid method. A selection key contains two operation sets represented as integer values. Each bit of an operation set denotes a category of selectable operations that are supported by the key&apos;s channel.The interest set determines which operation categories will be tested for readiness the next time one of the selector&apos;s selection methods is invoked. The interest set is initialized with the value given when the key is created; it may later be changed via the interestOps(int) method.The ready set identifies the operation categories for which the key&apos;s channel has been detected to be ready by the key&apos;s selector. The ready set is initialized to zero when the key is created; it may later be updated by the selector during a selection operation, but it cannot be updated directly.That a selection key&apos;s ready set indicates that its channel is ready for some operation category is a hint, but not a guarantee, that an operation in such a category may be performed by a thread without causing the thread to block. A ready set is most likely to be accurate immediately after the completion of a selection operation. It is likely to be made inaccurate by external events and by I/O operations that are invoked upon the corresponding channel.This class defines all known operation-set bits, but precisely which bits are supported by a given channel depends upon the type of the channel. Each subclass of SelectableChannel defines an validOps() method which returns a set identifying just those operations that are supported by the channel. An attempt to set or test an operation-set bit that is not supported by a key&apos;s channel will result in an appropriate run-time exception.It is often necessary to associate some application-specific data with a selection key, for example an object that represents the state of a higher-level protocol and handles readiness notifications in order to implement that protocol. Selection keys therefore support the attachment of a single arbitrary object to a key. An object can be attached via the attach method and then later retrieved via the attachment method.Selection keys are safe for use by multiple concurrent threads. The operations of reading and writing the interest set will, in general, be synchronized with certain operations of the selector. Exactly how this synchronization is performed is implementation-dependent: In a naive implementation, reading or writing the interest set may block indefinitely if a selection operation is already in progress; in a high-performance implementation, reading or writing the interest set may block briefly, if at all. In any case, a selection operation will always use the interest-set value that was current at the moment that the operation began.表示SelectableChannel与Selector注册的标记。每次向选择器注册通道时，都会创建一个选择键。密钥保持有效，直到通过调用其取消方法，关闭其通道或关闭其选择器来取消密钥。取消密钥不会立即将其从选择器中删除;而是将其添加到选择器的已取消键集中，以便在下一个选择操作期间将其删除。可以通过调用其isValid方法来测试密钥的有效性。选择键包含表示为整数值的两个操作集。操作集的每个位表示密钥通道支持的可选操作的类别。- 兴趣集确定下次调用选择器的一个选择方法时将测试哪些操作类别的准备情况。利息集初始化为创建密钥时给定的值;稍后可以通过interestOps（int）方法进行更改。就绪集合通过键的选择器识别检测到键的通道准备就绪的操作类别。创建密钥时，就绪集初始化为零;稍后可以在选择操作期间由选择器更新，但不能直接更新。- 选择键的就绪集指示其通道已准备好用于某些操作类别是提示但不保证这样的类别中的操作可由线程执行而不会导致线程阻塞。在完成选择操作之后，就绪设置最有可能是准确的。外部事件和在相应通道上调用的I / O操作可能会使其不准确。该类定义了所有已知的操作集位，但是精确地由给定通道支持哪些位取决于通道的类型。 SelectableChannel的每个子类定义一个validOps（）方法，该方法返回一个集合，该集合仅标识通道支持的那些操作。尝试设置或测试密钥通道不支持的操作设置位将导致适当的运行时异常。通常需要将一些特定于应用程序的数据与选择键相关联，例如，表示更高级别协议状态的对象，并处理准备就绪通知以实现该协议。因此，选择键支持将单个任意对象附加到键。可以通过attach方法附加对象，然后通过附加方法检索。选择键可安全地供多个并发线程使用。通常，读取和写入兴趣集的操作将与选择器的某些操作同步。具体如何执行此同步依赖于实现：在一个简单的实现中，如果选择操作已在进行中，则读取或写入兴趣集可能会无限期地阻塞;在高性能实现中，如果有的话，读取或写入兴趣集可能会暂时阻止。在任何情况下，选择操作将始终使用操作开始时当前的兴趣设定值。 下图格式较为清晰： 可见interestOps() 和 readyOps()都是返回的int类型，其实他们返回的是上面OP_READ等四个常量的 “|”。 判断集合中是否有某一个常量，可以使用“&amp;”来判断，如 1(interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT 返回值为true则代表存在。 该对象可以获取以下四种属性： interest集合（其实是int类型，上面解释过了） ready集合（其实是int类型，上面解释过了） Channel Selector interest集合是Selector感兴趣的集合，用于指示选择器对通道关心的操作，可通过SelectionKey对象的interestOps()获取。最初，该兴趣集合是通道被注册到Selector时传进来的值。该集合不会被选择器改变，但是可通过interestOps()改变。 我们可以通过以下方法来判断Selector是否对Channel的某种事件感兴趣： 12int interestSet=selectionKey.interestOps();boolean isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT； ready 集合是通道已经就绪的操作的集合，表示一个通道准备好要执行的操作了,可通过SelctionKey对象的readyOps()来获取相关通道已经就绪的操作。它是interest集合的子集，并且表示了interest集合中从上次调用select()以后已经就绪的那些操作。（比如选择器对通道的ready,write操作感兴趣，而某时刻通道的read操作已经准备就绪可以被选择器获知了，前一种就是interest集合，后一种则是ready集合。）。JAVA中定义以下几个方法用来检查这些操作是否就绪： 12345//int readSet=selectionKey.readOps();selectionKey.isAcceptable();//等价于selectionKey.readyOps()&amp;SelectionKey.OP_ACCEPTselectionKey.isConnectable();selectionKey.isReadable();selectionKey.isWritable(); 需要注意的是，通过相关的选择键的readyOps()方法返回的就绪状态指示只是一个提示，底层的通道在任何时候都会不断改变，而其他线程也可能在通道上执行操作并影响到它的就绪状态。另外，我们不能直接修改ready集合。 取出SelectionKey所关联的Selector和Channel通过SelectionKey访问对应的Selector和Channel： 12Channel channel =selectionKey.channel();Selector selector=selectionKey.selector(); 关于取消SelectionKey对象的那点事 我们可以通过SelectionKey对象的cancel()方法来取消特定的注册关系。 该方法调用之后，该SelectionKey对象将会被”拷贝”至已取消键的集合中，该键此时已经失效，但是该注册关系并不会立刻终结。在下一次select()时，已取消键的集合中的元素会被清除，相应的注册关系也真正终结。 为SelectionKey绑定附加对象 可以将一个或者多个附加对象绑定到SelectionKey上，以便容易的识别给定的通道。通常有两种方式： 在注册的时候直接绑定： 1SelectionKey key=channel.register(selector,SelectionKey.OP_READ,theObject); 在绑定完成之后附加： 1selectionKey.attach(theObject);//绑定 绑定之后，可通过对应的SelectionKey取出该对象:selectionKey.attachment();。如果要取消该对象，则可以通过该种方式:selectionKey.attach(null). 需要注意的是如果附加的对象不再使用，一定要人为清除，因为垃圾回收器不会回收该对象，若不清除的话会成内存泄漏。 一个单独的通道可被注册到多个选择器中，有些时候我们需要通过isRegistered（）方法来检查一个通道是否已经被注册到任何一个选择器上。 通常来说，我们并不会这么做。 通过Selector选择通道 我们知道选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中。接下来我们简单的了解一下Selector维护的三种类型SelectionKey集合： 我们知道选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中。接下来我们简单的了解一下 Selector维护的三种类型SelectionKey集合：（重点）源码中已经说明了一切： 123456789101112131415161718192021A multiplexor of SelectableChannel objects.A selector may be created by invoking the open method of this class, which will use the system&apos;s default selector provider to create a new selector. A selector may also be created by invoking the openSelector method of a custom selector provider. A selector remains open until it is closed via its close method. A selectable channel&apos;s registration with a selector is represented by a SelectionKey object. A selector maintains three sets of selection keys:The key set contains the keys representing the current channel registrations of this selector. This set is returned by the keys method.The selected-key set is the set of keys such that each key&apos;s channel was detected to be ready for at least one of the operations identified in the key&apos;s interest set during a prior selection operation. This set is returned by the selectedKeys method. The selected-key set is always a subset of the key set.The cancelled-key set is the set of keys that have been cancelled but whose channels have not yet been deregistered. This set is not directly accessible. The cancelled-key set is always a subset of the key set.All three sets are empty in a newly-created selector.A key is added to a selector&apos;s key set as a side effect of registering a channel via the channel&apos;s register method. Cancelled keys are removed from the key set during selection operations. The key set itself is not directly modifiable.A key is added to its selector&apos;s cancelled-key set when it is cancelled, whether by closing its channel or by invoking its cancel method. Cancelling a key will cause its channel to be deregistered during the next selection operation, at which time the key will removed from all of the selector&apos;s key sets. Keys are added to the selected-key set by selection operations. A key may be removed directly from the selected-key set by invoking the set&apos;s remove method or by invoking the remove method of an iterator obtained from the set. Keys are never removed from the selected-key set in any other way; they are not, in particular, removed as a side effect of selection operations. Keys may not be added directly to the selected-key set.SelectableChannel对象的多路复用器。- 可以通过调用此类的open方法来创建选择器，该方法将使用系统的默认选择器提供程序来创建新的选择器。还可以通过调用自定义选择器提供程序的openSelector方法来创建选择器。选择器保持打开状态，直到通过其关闭方法关闭。可选择通道的选择器注册由SelectionKey对象表示。选择器维护三组选择键：重点： 密钥集包含表示此选择器的当前通道注册的键。该方法由keys方法返回。重点： 所选择的密钥集是一组密钥，使得检测到每个密钥的信道准备好用于在先前选择操作期间在密钥的兴趣集中识别的至少一个操作。这个集由selectedKeys方法返回。选定键集始终是键集的子集。重点： 取消密钥集是已取消但其通道尚未取消注册的密钥集。此套装无法直接访问。取消密钥集始终是密钥集的子集。在新创建的选择器中，所有三个组都是空的。将一个键添加到选择器的键集中，作为通过通道的寄存器方法注册通道的副作用。在选择操作期间，取消的密钥将从密钥集中删除。密钥集本身不能直接修改。无论是通过关闭其通道还是通过调用其cancel方法，都会在取消选择器的取消键集时添加一个键。取消密钥将导致其通道在下一个选择操作期间取消注册，此时密钥将从所有选择器的密钥集中删除。通过选择操作将键添加到选定键集。可以通过调用set的remove方法或通过调用从set中获取的迭代器的remove方法，直接从selected-key集中删除键。密钥永远不会以任何其他方式从选定密钥集中删除;特别是，它们不会作为选择操作的副作用而被删除。密钥可能无法直接添加到选定密钥集。 密钥集（key set）包含表示此选择器的当前通道注册的键。该方法由keys方法返回。 所选择的密钥集（selected-key set）是一组密钥，使得检测到每个密钥的信道准备好用于在先前选择操作期间在密钥的兴趣集中识别的至少一个操作。这个集由selectedKeys方法返回。选定键集始终是键集的子集。 取消密钥集（ cancelled-key set）是已取消但其通道尚未取消注册的密钥集。此套装无法直接访问。取消密钥集始终是密钥集的子集。 在刚初始化的Selector对象中，这三个集合都是空的。通过Selector的select（）方法可以选择已经准备就绪的通道（这些通道包含你感兴趣的的事件）。比如你对读就绪的通道感兴趣，那么select（）方法就会返回读事件已经就绪的那些通道。下面是Selector几个重载的select()方法：select():阻塞到至少有一个通道在你注册的事件上就绪了。select(long timeout)：和select()一样，但最长阻塞事件为timeout毫秒。selectNow():非阻塞，只要有通道就绪就立刻返回。 select()方法返回的int值表示有多少通道已经就绪,是自上次调用select()方法后有多少通道变成就绪状态。之前在select（）调用时进入就绪的通道不会在本次调用中被记入，而在前一次select（）调用进入就绪但现在已经不在处于就绪的通道也不会被记入。例如：首次调用select()方法，如果有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。 一旦调用select()方法，并且返回值不为0时，则可以通过调用Selector的selectedKeys()方法来访问已选择键集合。如下： 1Set selectedKeys=selector.selectedKeys(); 进而可以放到和某SelectionKey关联的Selector和Channel。如下所示： 123456789101112131415Set selectedKeys = selector.selectedKeys();Iterator keyIterator = selectedKeys.iterator();while(keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if(key.isAcceptable()) &#123; // a connection was accepted by a ServerSocketChannel. &#125; else if (key.isConnectable()) &#123; // a connection was established with a remote server. &#125; else if (key.isReadable()) &#123; // a channel is ready for reading &#125; else if (key.isWritable()) &#123; // a channel is ready for writing &#125; keyIterator.remove();&#125; 关于Selector执行选择的过程（重点）我们知道调用select（）方法进行通道，现在我们再来深入一下选择的过程，也就是select（）执行过程。当select（）被调用时将执行以下几步： 首先检查已取消键集合，也就是通过cancle()取消的键。如果该集合不为空，则清空该集合里的键，同时该集合中每个取消的键也将从已注册键集合和已选择键集合中移除。（注意：一个键被取消时，并不会立刻从集合中移除，而是将该键“拷贝”至已取消键集合中，这种取消策略就是我们常提到的“延迟取消”。） 再次检查已注册键集合（准确说是该集合中每个键的interest集合）。系统底层会依次询问每个已经注册的通道是否准备好选择器所感兴趣的某种操作，一旦发现某个通道已经就绪了，则会首先判断该通道是否已经存在在已选择键集合当中，如果已经存在，则更新该通道在已注册键集合中对应的键的ready集合，如果不存在，则首先清空该通道的对应的键的ready集合，然后重设ready集合，最后将该键存至已注册键集合中。这里需要明白，当更新ready集合时，在上次select（）中已经就绪的操作不会被删除，也就是ready集合中的元素是累积的，比如在第一次的selector对某个通道的read和write操作感兴趣，在第一次执行select（）时，该通道的read操作就绪，此时该通道对应的键中的ready集合存有read元素，在第二次执行select()时，该通道的write操作也就绪了，此时该通道对应的ready集合中将同时有read和write元素。 深入已注册键集合的管理（重点）由上面贴出的源码可以知道。通过选择操作将键添加到选定键集。可以通过调用set的remove方法或通过调用从set中获取的迭代器的remove方法，直接从selected-key集中删除键。密钥永远不会以任何其他方式从选定密钥集中删除;特别是，它们不会作为选择操作的副作用而被删除。密钥可能无法直接添加到选定密钥集。 首先要记住：选择器不会主动删除被添加到已选择键集合中的键，而且被添加到已选择键集合中的键的ready集合只能被设置，而不能被清理。如果我们希望清空已选择键集合中某个键的ready集合该怎么办？我们知道一个键在新加入已选择键集合之前会首先置空该键的ready集合，这样的话我们可以人为的将某个键从已注册键集合中移除最终实现置空某个键的ready集合。被移除的键如果在下一次的select（）中再次就绪，它将会重新被添加到已选择的键的集合中。这就是为什么要在每次迭代的末尾调用 1keyIterator.remove() 停止选择选择器执行选择的过程，系统底层会依次询问每个通道是否已经就绪，这个过程可能会造成调用线程进入阻塞状态,那么我们有以下三种方式可以唤醒在select（）方法中阻塞的线程。 通过调用Selector对象的wakeup（）方法让处在阻塞状态的select()方法立刻返回 该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中的选择操作，那么下一次对select()方法的一次调用将立即返回。 通过close（）方法关闭Selector 该方法使得任何一个在选择操作中阻塞的线程都被唤醒（类似wakeup（）），同时使得注册到该Selector的所有Channel被注销，所有的键将被取消，但是Channel本身并不会关闭。 调用interrupt() 调用该方法会使睡眠的线程抛出InterruptException异常，捕获该异常并在调用wakeup() Selector完整实例这里我们结合ServerSocketChannel和Selector构建简单的服务器，下面是完整的代码示例。服务端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class ServerSocketChannelTest &#123; private int size = 1024; private ServerSocketChannel socketChannel; private ByteBuffer byteBuffer; private Selector selector; private final int port = 8998; private int remoteClientNum=0; public ServerSocketChannelTest() &#123; try &#123; initChannel(); &#125; catch (Exception e) &#123; e.printStackTrace(); System.exit(-1); &#125; &#125; public void initChannel() throws Exception &#123; socketChannel = ServerSocketChannel.open(); socketChannel.configureBlocking(false); socketChannel.bind(new InetSocketAddress(port)); System.out.println("listener on port:" + port); selector = Selector.open(); socketChannel.register(selector, SelectionKey.OP_ACCEPT); byteBuffer = ByteBuffer.allocateDirect(size); byteBuffer.order(ByteOrder.BIG_ENDIAN); &#125; private void listener() throws Exception &#123; while (true) &#123; int n = selector.select(); if (n == 0) &#123; continue; &#125; Iterator&lt;SelectionKey&gt; ite = selector.selectedKeys().iterator(); while (ite.hasNext()) &#123; SelectionKey key = ite.next(); //a connection was accepted by a ServerSocketChannel. if (key.isAcceptable()) &#123; ServerSocketChannel server = (ServerSocketChannel) key.channel(); SocketChannel channel = server.accept(); registerChannel(selector, channel, SelectionKey.OP_READ); remoteClientNum++; System.out.println("online client num="+remoteClientNum); replyClient(channel); &#125; //a channel is ready for reading if (key.isReadable()) &#123; readDataFromSocket(key); &#125; ite.remove();//must &#125; &#125; &#125; protected void readDataFromSocket(SelectionKey key) throws Exception &#123; SocketChannel socketChannel = (SocketChannel) key.channel(); int count; byteBuffer.clear(); while ((count = socketChannel.read(byteBuffer)) &gt; 0) &#123; byteBuffer.flip(); // Make buffer readable // Send the data; don't assume it goes all at once while (byteBuffer.hasRemaining()) &#123; socketChannel.write(byteBuffer); &#125; byteBuffer.clear(); // Empty buffer &#125; if (count &lt; 0) &#123; socketChannel.close(); &#125; &#125; private void replyClient(SocketChannel channel) throws IOException &#123; byteBuffer.clear(); byteBuffer.put("hello client!\r\n".getBytes()); byteBuffer.flip(); channel.write(byteBuffer); &#125; private void registerChannel(Selector selector, SocketChannel channel, int ops) throws Exception &#123; if (channel == null) &#123; return; &#125; channel.configureBlocking(false); channel.register(selector, ops); &#125; public static void main(String[] args) &#123; try &#123; new ServerSocketChannelTest().listener(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 客户端代码： 12345678910111213141516171819202122232425262728293031323334353637383940public class SocketChannelTest &#123; private int size = 1024; private ByteBuffer byteBuffer; private SocketChannel socketChannel; public void connectServer() throws IOException &#123; socketChannel = SocketChannel.open(); socketChannel.connect(new InetSocketAddress("127.0.0.1", 8998)); byteBuffer = ByteBuffer.allocate(size); byteBuffer.order(ByteOrder.BIG_ENDIAN); receive(); &#125; private void receive() throws IOException &#123; while (true) &#123; int count; byteBuffer.clear(); while ((count = socketChannel.read(byteBuffer)) &gt; 0) &#123; byteBuffer.flip(); while (byteBuffer.hasRemaining()) &#123; System.out.print((char) byteBuffer.get()); &#125; //send("send data to server\r\n".getBytes()); byteBuffer.clear(); &#125; &#125; &#125; private void send(byte[] data) throws IOException &#123; byteBuffer.clear(); byteBuffer.put(data); byteBuffer.flip(); socketChannel.write(byteBuffer); &#125; public static void main(String[] args) throws IOException &#123; new SocketChannelTest().connectServer(); &#125;&#125; 本文参考了：https://blog.csdn.net/dd864140130/article/details/50299687，修正了其中的错误，并以源代码为依据，重新梳理了整个Selector。整个过程花费时间长，收获也很多，特别是对Selector，SelectorKey有了更深一个层次的了解。]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NIO源码分析之Buffer]]></title>
    <url>%2F2019%2F06%2F07%2FNIO%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BBuffer%2F</url>
    <content type="text"><![CDATA[NIO源码分析之BufferNIO博大精深，探寻NIO的源码后收获很多，在此进行记录。这次主要分析Buffer的源码，主要有以下几个内容。 绝对方法和相对方法（position，limit，capacity属性的含义） Clearing，flipping，and rewinding 的作用 线程不安全 链式调用 常用API源码分析 绝对方法和相对方法 相对方法: limit值与position值会在操作时被考虑到. 绝对方法,完全忽略掉limit值与position值. 三个重要属性的含义： position， limit， capacity源码中的解析：A buffer’s capacity is the number of elements it contains. The capacity of a buffer is never negative and never changes. 一个buffer的capacity是它锁包含的元素的数量。buffer的capacity不为负而且不能改变。 A buffer’s limit is the index of the first element that should not be read or written. A buffer’s limit is never negative and is never greater than its capacity. 一个buffer的limit是第一个不能被读写的元素的索引。一个buffer的limit不能为负而且不能大于它的capacity。 A buffer’s position is the index of the next element to be read or written. A buffer’s position is never negative and is never greater than its limit. 一个buffer 的position是下一个被读写的元素的索引。一个buffer 的position不能为负而且不能大于limit。 创建时调用Buffer的一个子类ByteBuffer的 allocate申请空间。返回的是HeapByteBuffer(capacity, capacity) 层层跟进 它调用了父类ByteBuffer中的构造方法 由此可得出cpacity和limit的初始值是相同的，position为0。 另外调用ByteBuffer的allocateDirect，为 它调用了DirectByteBuffer的构造方法来进行初始化。 可见limit和capacity依然是相同的。position为0。 所以初始时为： 其中capacity永不变。读了四个以后为： flip方法：将p指向0，将limit指向原来position的位置。 这样进行写或者读的时候，随着position向limit的移动就可以成功读取响应的数据。mark作用为进行标记，以便返回标记处。0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity Clearing, flipping, and rewinding clear makes a buffer ready for a new sequence of channel-read or relative put operations: It sets the limit to the capacity and the position to zero.使得limit和capacity归零，相当于重置。 flip makes a buffer ready for a new sequence of channel-write or relative get operations: It sets the limit to the current position and then sets the position to zero.使得limit放在position的位置，使position归零，用于下一次读写。 rewind makes a buffer ready for re-reading the data that it already contains: It leaves the limit unchanged and sets the position to zero.使得position归零，进行新的读写相当于恢复为上一次读写前的状态，进行新的读写 线程不安全Thread safetyBuffers are not safe for use by multiple concurrent threads. If a buffer is to be used by more than one thread then access to the buffer should be controlled by appropriate synchronization. 使用多线程的时候Buffer不是多线程的，如果Buffer要在多于一个线程中使用，需要进行适当的同步。 链式调用Invocation chainingMethods in this class that do not otherwise have a value to return are specified to return the buffer upon which they are invoked. This allows method invocations to be chained; for example, the sequence of statements 此类中没有要返回的值的方法被指定为返回调用它们的缓冲区。这允许将方法调用链接起来；例如，语句序列 b.flip(); b.position(23); b.limit(42);can be replaced by the single, more compact statement b.flip().position(23).limit(42); 常用API源码分析 allocate() HeapIntBuffer与IntBuffer为父子关系。 IntBuffer调用父类 IntBuffer的构造方法进行初始化 allocateDerect() 零拷贝 直接申请堆外内存.实现了零拷贝.之前为什么要拷贝?因为直接操作堆上的内存（可以看做用户空间的内存）,然后分配一个address给buffer的话，期间可能会出现GC等,导致数据内存地址发生改变.所以只好把内容拷贝给buffer。直接操作堆外内存（内核空间的内存）的话，不会出现GC，所以把地址直接给buffer，可以实现零拷贝。 进入DerecByteBuffer()方法,如下图,以看出里面用JNI,unsafe的方法直接申请内存 在Buffer类中可以找到address变量,表示在对外内存分配的内存的地址,为什么不直接放在DerectByteBuffer呢,上面注释说了,为了加快GetDirectBufferAddress的调用方法. mark() 将mark标记设置为position处 reset() 重新设置position位置为之前标记的m处 clear() 清空buffer,想象一下,即将position置零(最左端),limit被赋值为capacity(limit和capacity在最右端),一切都回到了最开始的地方.注意: 这个数组不会理所当然的被抹去,这个数组会随着之后的写入而把之前的值给覆盖. flip() 翻转,意思就是把limit置为position,position置为0,mark置为-1(代表丢弃),准备给channel进行读写. rewind() 非常好理解,倒带,就是把position置为0,重复利用buffer,解进行下一次channel-write或者get操作.它和flip()的区别是,flip操作了limit,而这个limit是定的,只是为了再次重复利用buffer. remaining()&amp;&amp;hasRemaining() remaining意思为剩余,顾名思义,remaining()方法利用limit - position成功得出剩余的处理的数量.hasRemaining返回一个boolean值,表示是否还有剩余. slice() Slice Buffer 和 原有 Buffer 共享相同的底层数组,但是不共享limit和position asReadOnlyBuffer() 点开实现类,为 HeapByteBufferR, 它的put方法全都抛出ReadOnlyBufferException()异常. 以上解析了部分核心API的源码，更多的源码，原理大概相似，可以自行看源码进行理解。下面会分析Selector的相关源码，对其进行更深入的理解。]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存结构 VS Java内存模型 VS Java对象模型]]></title>
    <url>%2F2019%2F05%2F30%2FJVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-VS-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-VS-Java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JVM内存结构 VS Java内存模型 VS Java对象模型Java作为一种面向对象的，跨平台语言，其对象、内存等一直是比较难的知识点。而且很多概念的名称看起来又那么相似，很多人会傻傻分不清楚。比如本文我们要讨论的JVM内存结构、Java内存模型和Java对象模型，这就是三个截然不同的概念，但是很多人容易弄混。 可以这样说，很多高级开发甚至都搞不不清楚JVM内存结构、Java内存模型和Java对象模型这三者的概念及其间的区别。甚至我见过有些面试官自己也搞的不是太清楚。不信的话，你去网上搜索Java内存模型，还会有很多文章的内容其实介绍的是JVM内存结构。 首先，这三个概念是完全不同的三个概念。本文主要对这三个概念加以区分以及简单介绍。 JVM内存结构我们都知道，Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。在《Java虚拟机规范（Java SE 8）》中描述了JVM运行时内存区域结构如下： 各个区域的功能不是本文重点，就不在这里详细介绍了。这里简单提几个需要特别注意的点： 以上是Java虚拟机规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。 规范中定义的方法区，只是一种概念上的区域，并说明了其应该具有什么功能。但是并没有规定这个区域到底应该处于何处。所以，对于不同的虚拟机实现来说，是由一定的自由度的。 不同版本的方法区所处位置不同，上图中划分的是逻辑区域，并不是绝对意义上的物理区域。因为某些版本的JDK中方法区其实是在堆中实现的。 运行时常量池用于存放编译期生成的各种字面量和符号应用。但是，Java语言并不要求常量只有在编译期才能产生。比如在运行期，String.intern也会把新的常量放入池中。 除了以上介绍的JVM运行时内存外，还有一块内存区域可供使用，那就是直接内存。Java虚拟机规范并没有定义这块内存区域，所以他并不由JVM管理，是利用本地方法库直接在堆外申请的内存区域。 堆和栈的数据划分也不是绝对的，如HotSpot的JIT会针对对象分配做相应的优化。 如上，做个总结，JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。 Java内存模型Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事儿，这也就导致面试过程中经常答非所为。 在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。 Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。JSR-133: Java Memory Model and Thread Specification中描述了，JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。 那么，简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。 在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。这里就不对Java内存模型做更加详细的介绍了，想了解更多的朋友可以参考《Java并发编程的艺术》。 Java对象模型Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。 HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。 每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。 这就是一个简单的Java对象的OOP-Klass模型，即Java对象模型。 总结我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。 JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。 关于这三部分内容，本文并未分别展开，因为涉及到的知识点实在太多，如果读者感兴趣，可以自行学习。 特别感谢https://www.hollischuang.com/的总结，很专业，很清晰！]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM优化基础和JDK工具的使用]]></title>
    <url>%2F2019%2F05%2F30%2FJVM%E4%BC%98%E5%8C%96%E5%9F%BA%E7%A1%80%E5%92%8CJDK%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[JVM优化基础和JDK工具的使用 了解下我们为什么要学习JVM优化 掌握jvm的运行参数以及参数的设置 掌握jvm的内存结构（堆内存） 掌握jamp命令的使用以及通过MAT工具进行分析 掌握定位分析内存溢出的方法 掌握jstack命令的使用 掌握VisualJVM工具的使用 1、我们为什么要对jvm做优化？在本地开发环境中我们很少会遇到需要对jvm进行优化的需求，但是到了生产环境，我们可能将有下面的需求： 运行的应用“卡住了”，日志不输出，程序没有反应 服务器的CPU负载突然升高 在多线程应用下，如何分配线程的数量？ …… 在本次课程中，我们将对jvm有更深入的学习，我们不仅要让程序能跑起来，而且是可以跑的更快！可以分析解决在生产环境中所遇到的各种“棘手”的问题。 说明：本套课程使用的jdk版本为1.8。 2、jvm的运行参数在jvm中有很多的参数可以进行设置，这样可以让jvm在各种环境中都能够高效的运行。绝大部分的参数保持默认即可。 2.1、三种参数类型jvm的参数类型分为三类，分别是： 标准参数 -help -version -X参数 （非标准参数） -Xint -Xcomp -XX参数（使用率较高） -XX:newSize -XX:+UseSerialGC 2.2、标准参数jvm的标准参数，一般都是很稳定的，在未来的JVM版本中不会改变，可以使用java -help检索出所有的标准参数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[root@node01 ~]# java -help用法: java [-options] class [args...] (执行类) 或 java [-options] -jar jarfile [args...] (执行 jar 文件)其中选项包括: -d32 使用 32 位数据模型 (如果可用) -d64 使用 64 位数据模型 (如果可用) -server 选择 "server" VM 默认 VM 是 server, 因为您是在服务器类计算机上运行。 -cp &lt;目录和 zip/jar 文件的类搜索路径&gt; -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt; 用 : 分隔的目录, JAR 档案 和 ZIP 档案列表, 用于搜索类文件。 -D&lt;名称&gt;=&lt;值&gt; 设置系统属性 -verbose:[class|gc|jni] 启用详细输出 -version 输出产品版本并退出 -version:&lt;值&gt; 警告: 此功能已过时, 将在 未来发行版中删除。 需要指定的版本才能运行 -showversion 输出产品版本并继续 -jre-restrict-search | -no-jre-restrict-search 警告: 此功能已过时, 将在 未来发行版中删除。 在版本搜索中包括/排除用户专用 JRE -? -help 输出此帮助消息 -X 输出非标准选项的帮助 -ea[:&lt;packagename&gt;...|:&lt;classname&gt;] -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;] 按指定的粒度启用断言 -da[:&lt;packagename&gt;...|:&lt;classname&gt;] -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;] 禁用具有指定粒度的断言 -esa | -enablesystemassertions 启用系统断言 -dsa | -disablesystemassertions 禁用系统断言 -agentlib:&lt;libname&gt;[=&lt;选项&gt;] 加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof 另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help -agentpath:&lt;pathname&gt;[=&lt;选项&gt;] 按完整路径名加载本机代理库 -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;] 加载 Java 编程语言代理, 请参阅 java.lang.instrument -splash:&lt;imagepath&gt; 使用指定的图像显示启动屏幕 2.2.1、实战 实战1：查看jvm版本 123456[root@node01 ~]# java -versionjava version "1.8.0_141"Java(TM) SE Runtime Environment (build 1.8.0_141-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)# -showversion参数是表示，先打印版本信息，再执行后面的命令，在调试时非常有用，后面会使用到。 实战2：通过-D设置系统属性参数 1234567891011public class TestJVM &#123; public static void main(String[] args) &#123; String str = System.getProperty("str"); if (str == null) &#123; System.out.println("bestqiang"); &#125; else &#123; System.out.println(str); &#125; &#125;&#125; 进行编译、测试： 12345678#编译[root@node01 test]# javac TestJVM.java#测试[root@node01 test]# java TestJVMbestqiang[root@node01 test]# java -Dstr=123 TestJVM123 2.2.2、-server与-client参数可以通过-server或-client设置jvm的运行参数。 它们的区别是Server VM的初始堆空间会大一些，默认使用的是并行垃圾回收器，启动慢运行快。 Client VM相对来讲会保守一些，初始堆空间会小一些，使用串行的垃圾回收器，它的目标是为了让JVM的启动速度更快，但运行速度会比Serverm模式慢些。 JVM在启动的时候会根据硬件和操作系统自动选择使用Server还是Client类型的JVM。 32位操作系统 如果是Windows系统，不论硬件配置如何，都默认使用Client类型的JVM。 如果是其他操作系统上，机器配置有2GB以上的内存同时有2个以上CPU的话默认使用server模式，否则使用client模式。 64位操作系统 只有server类型，不支持client类型。 测试： 123456789101112131415[root@node01 test]# java -client -showversion TestJVMjava version "1.8.0_141"Java(TM) SE Runtime Environment (build 1.8.0_141-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)bestqiang[root@node01 test]# java -server -showversion TestJVMjava version "1.8.0_141"Java(TM) SE Runtime Environment (build 1.8.0_141-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)bestqiang#由于机器是64位系统，所以不支持client模式 2.3、-X参数jvm的-X参数是非标准参数，在不同版本的jvm中，参数可能会有所不同，可以通过java -X查看非标准参数。 12345678910111213141516171819202122232425262728293031323334[root@node01 test]# java -X -Xmixed 混合模式执行 (默认) -Xint 仅解释模式执行 -Xbootclasspath:&lt;用 : 分隔的目录和 zip/jar 文件&gt; 设置搜索路径以引导类和资源 -Xbootclasspath/a:&lt;用 : 分隔的目录和 zip/jar 文件&gt; 附加在引导类路径末尾 -Xbootclasspath/p:&lt;用 : 分隔的目录和 zip/jar 文件&gt; 置于引导类路径之前 -Xdiag 显示附加诊断消息 -Xnoclassgc 禁用类垃圾收集 -Xincgc 启用增量垃圾收集 -Xloggc:&lt;file&gt; 将 GC 状态记录在文件中 (带时间戳) -Xbatch 禁用后台编译 -Xms&lt;size&gt; 设置初始 Java 堆大小 -Xmx&lt;size&gt; 设置最大 Java 堆大小 -Xss&lt;size&gt; 设置 Java 线程堆栈大小 -Xprof 输出 cpu 配置文件数据 -Xfuture 启用最严格的检查, 预期将来的默认值 -Xrs 减少 Java/VM 对操作系统信号的使用 (请参阅文档) -Xcheck:jni 对 JNI 函数执行其他检查 -Xshare:off 不尝试使用共享类数据 -Xshare:auto 在可能的情况下使用共享类数据 (默认) -Xshare:on 要求使用共享类数据, 否则将失败。 -XshowSettings 显示所有设置并继续 -XshowSettings:all 显示所有设置并继续 -XshowSettings:vm 显示所有与 vm 相关的设置并继续 -XshowSettings:properties 显示所有属性设置并继续 -XshowSettings:locale 显示所有与区域设置相关的设置并继续-X 选项是非标准选项, 如有更改, 恕不另行通知。 2.3.1、-Xint、-Xcomp、-Xmixed 在解释模式(interpreted mode)下，-Xint标记会强制JVM执行所有的字节码，当然这会降低运行速度，通常低10倍或更多。 -Xcomp参数与它（-Xint）正好相反，JVM在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。 然而，很多应用在使用-Xcomp也会有一些性能损失，当然这比使用-Xint损失的少，原因是-xcomp没有让JVM启用JIT编译器的全部功能。JIT编译器可以对是否需要编译做判断，如果所有代码都进行编译的话，对于一些只执行一次的代码就没有意义了。 -Xmixed是混合模式，将解释模式与编译模式进行混合使用，由jvm自己决定，这是jvm默认的模式，也是推荐使用的模式。 示例：强制设置运行模式 1234567891011121314151617181920212223242526#强制设置为解释模式[root@node01 test]# java -showversion -Xint TestJVMjava version "1.8.0_141"Java(TM) SE Runtime Environment (build 1.8.0_141-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, interpreted mode)bestqiang#强制设置为编译模式[root@node01 test]# java -showversion -Xcomp TestJVMjava version "1.8.0_141"Java(TM) SE Runtime Environment (build 1.8.0_141-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, compiled mode)bestqiang#注意：编译模式下，第一次执行会比解释模式下执行慢一些，注意观察。#默认的混合模式[root@node01 test]# java -showversion TestJVMjava version "1.8.0_141"Java(TM) SE Runtime Environment (build 1.8.0_141-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)bestqiang 2.4、-XX参数-XX参数也是非标准参数，主要用于jvm的调优和debug操作。 -XX参数的使用有2种方式，一种是boolean类型，一种是非boolean类型： boolean类型 格式：-XX:[+-]\ 表示启用或禁用\属性 如：-XX:+DisableExplicitGC 表示禁用手动调用gc操作，也就是说调用System.gc()无效 非boolean类型 格式：-XX:\=\ 表示\属性的值为\ 如：-XX:NewRatio=1 表示新生代和老年代的比值 用法： 123456[root@node01 test]# java -showversion -XX:+DisableExplicitGC TestJVMjava version "1.8.0_141"Java(TM) SE Runtime Environment (build 1.8.0_141-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)bestqiang 2.5、-Xms与-Xmx参数-Xms与-Xmx分别是设置jvm的堆内存的初始大小和最大大小。 -Xmx2048m：等价于-XX:MaxHeapSize，设置JVM最大堆内存为2048M。 -Xms512m：等价于-XX:InitialHeapSize，设置JVM初始堆内存为512M。 适当的调整jvm的内存大小，可以充分利用服务器资源，让程序跑的更快。 示例： 12[root@node01 test]# java -Xms512m -Xmx2048m TestJVMbestqiang 2.6、查看jvm的运行参数有些时候我们需要查看jvm的运行参数，这个需求可能会存在2种情况： 第一，运行java命令时打印出运行参数； 第二，查看正在运行的java进程的参数； 2.6.1、运行java命令时打印参数运行java命令时打印参数，需要添加-XX:+PrintFlagsFinal参数即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344[root@node01 test]# java -XX:+PrintFlagsFinal -version[Global flags] uintx AdaptiveSizeDecrementScaleFactor = 4 &#123;product&#125; uintx AdaptiveSizeMajorGCDecayTimeScale = 10 &#123;product&#125; uintx AdaptiveSizePausePolicy = 0 &#123;product&#125; uintx AdaptiveSizePolicyCollectionCostMargin = 50 &#123;product&#125; uintx AdaptiveSizePolicyInitializingSteps = 20 &#123;product&#125; uintx AdaptiveSizePolicyOutputInterval = 0 &#123;product&#125; uintx AdaptiveSizePolicyWeight = 10 &#123;product&#125; uintx AdaptiveSizeThroughPutPolicy = 0 &#123;product&#125; uintx AdaptiveTimeWeight = 25 &#123;product&#125; bool AdjustConcurrency = false &#123;product&#125; bool AggressiveOpts = false &#123;product&#125; intx AliasLevel = 3 &#123;C2 product&#125; bool AlignVector = true &#123;C2 product&#125; intx AllocateInstancePrefetchLines = 1 &#123;product&#125; intx AllocatePrefetchDistance = 256 &#123;product&#125; intx AllocatePrefetchInstr = 0 &#123;product&#125; …………………………略………………………………………… bool UseXmmI2D = false &#123;ARCH product&#125; bool UseXmmI2F = false &#123;ARCH product&#125; bool UseXmmLoadAndClearUpper = true &#123;ARCH product&#125; bool UseXmmRegToRegMoveAll = true &#123;ARCH product&#125; bool VMThreadHintNoPreempt = false &#123;product&#125; intx VMThreadPriority = -1 &#123;product&#125; intx VMThreadStackSize = 1024 &#123;pd product&#125; intx ValueMapInitialSize = 11 &#123;C1 product&#125; intx ValueMapMaxLoopSize = 8 &#123;C1 product&#125; intx ValueSearchLimit = 1000 &#123;C2 product&#125; bool VerifyMergedCPBytecodes = true &#123;product&#125; bool VerifySharedSpaces = false &#123;product&#125; intx WorkAroundNPTLTimedWaitHang = 1 &#123;product&#125; uintx YoungGenerationSizeIncrement = 20 &#123;product&#125; uintx YoungGenerationSizeSupplement = 80 &#123;product&#125; uintx YoungGenerationSizeSupplementDecay = 8 &#123;product&#125; uintx YoungPLABSize = 4096 &#123;product&#125; bool ZeroTLAB = false &#123;product&#125; intx hashCode = 5 &#123;product&#125;java version "1.8.0_141"Java(TM) SE Runtime Environment (build 1.8.0_141-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode) 由上述的信息可以看出，参数有boolean类型和数字类型，值的操作符是=或:=，分别代表默认值和被修改的值。 示例： 12345678910111213141516171819java -XX:+PrintFlagsFinal -XX:+VerifySharedSpaces -version intx ValueMapInitialSize = 11 &#123;C1 product&#125; intx ValueMapMaxLoopSize = 8 &#123;C1 product&#125; intx ValueSearchLimit = 1000 &#123;C2 product&#125; bool VerifyMergedCPBytecodes = true &#123;product&#125; bool VerifySharedSpaces := true &#123;product&#125; intx WorkAroundNPTLTimedWaitHang = 1 &#123;product&#125; uintx YoungGenerationSizeIncrement = 20 &#123;product&#125; uintx YoungGenerationSizeSupplement = 80 &#123;product&#125; uintx YoungGenerationSizeSupplementDecay = 8 &#123;product&#125; uintx YoungPLABSize = 4096 &#123;product&#125; bool ZeroTLAB = false &#123;product&#125; intx hashCode = 5 &#123;product&#125;java version "1.8.0_141"Java(TM) SE Runtime Environment (build 1.8.0_141-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)#可以看到VerifySharedSpaces这个参数已经被修改了。 2.6.2、查看正在运行的jvm参数如果想要查看正在运行的jvm就需要借助于jinfo命令查看。 首先，启动一个tomcat用于测试，来观察下运行的jvm参数。 12345678cd /tmp/rz 上传tar -xvf apache-tomcat-7.0.57.tar.gz cd apache-tomcat-7.0.57cd bin/./startup.sh#http://192.168.40.133:8080/ 进行访问 访问成功： 12345678910111213141516171819202122#查看所有的参数，用法：jinfo -flags &lt;进程id&gt;#通过jps 或者 jps -l 查看java进程[root@node01 bin]# jps6346 Jps6219 Bootstrap[root@node01 bin]# jps -l6358 sun.tools.jps.Jps6219 org.apache.catalina.startup.Bootstrap[root@node01 bin]#[root@node01 bin]# jinfo -flags 6219Attaching to process ID 6219, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.141-b15Non-default VM flags: -XX:CICompilerCount=2 -XX:InitialHeapSize=31457280 -XX:MaxHeapSize=488636416 -XX:MaxNewSize=162529280 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=10485760 -XX:OldSize=20971520 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC Command line: -Djava.util.logging.config.file=/tmp/apache-tomcat-7.0.57/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djava.endorsed.dirs=/tmp/apache-tomcat-7.0.57/endorsed -Dcatalina.base=/tmp/apache-tomcat-7.0.57 -Dcatalina.home=/tmp/apache-tomcat-7.0.57 -Djava.io.tmpdir=/tmp/apache-tomcat-7.0.57/temp#查看某一参数的值，用法：jinfo -flag &lt;参数名&gt; &lt;进程id&gt;[root@node01 bin]# jinfo -flag MaxHeapSize 6219-XX:MaxHeapSize=488636416 3、jvm的内存结构jvm的内存结构在1.7和1.8有较大的区别，虽然本套课程是以1.8为例进行讲解，但是我们也是需要对1.7的内存结构有所了解，所以接下里，我们将先学习1.7再学习1.8的内存结构。 3.1、jdk1.7的堆内存结构 Young 年轻区（代） Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用，在Eden区间变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。 Tenured 年老区 Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区，一般如果系统中用了application级别的缓存，缓存中的对象往往会被转移到这一区间。 Perm 永久区 Perm代主要保存class,method,filed对象，这部份的空间一般不会溢出，除非一次性加载了很多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到java.lang.OutOfMemoryError : PermGen space 的错误，造成这个错误的很大原因就有可能是每次都重新部署，但是重新部署后，类的class没有被卸载掉，这样就造成了大量的class对象保存在了perm中，这种情况下，一般重新启动应用服务器可以解决问题。 Virtual区： 最大内存和初始内存的差值，就是Virtual区。 3.2、jdk1.8的堆内存结构 由上图可以看出，jdk1.8的内存结构是由2部分组成，年轻代 + 年老代。 年轻代：Eden + 2*Survivor 年老代：OldGen 在jdk1.8中变化最大的Perm区，用Metaspace（元数据空间）进行了替换。 需要特别说明的是：Metaspace所占用的内存空间不是在虚拟机内部，而是在本地内存空间中，这也是与1.7的永久代最大的区别所在。 ![1536507420882](JVM优化基础和JDK工具的使用/1536507420882.png) 3.3、为什么要废弃1.7中的永久区？官网给出了解释：http://openjdk.java.net/jeps/122 123This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。 现实使用中，由于永久代内存经常不够用或发生内存泄露，爆出异常java.lang.OutOfMemoryError: PermGen。 基于此，将永久区废弃，而改用元空间，改为了使用本地内存空间。 3.4、通过jstat命令进行查看堆内存使用情况jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下： jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数] 3.4.1、查看class加载统计1234567[root@node01 ~]# jps7080 Jps6219 Bootstrap[root@node01 ~]# jstat -class 6219Loaded Bytes Unloaded Bytes Time 3273 7122.3 0 0.0 3.98 说明： Loaded：加载class的数量 Bytes：所占用空间大小 Unloaded：未加载数量 Bytes：未加载占用空间 Time：时间 3.4.2、查看编译统计123[root@node01 ~]# jstat -compiler 6219Compiled Failed Invalid Time FailedType FailedMethod 2376 1 0 8.04 1 org/apache/tomcat/util/IntrospectionUtils setProperty 说明： Compiled：编译数量。 Failed：失败数量 Invalid：不可用数量 Time：时间 FailedType：失败类型 FailedMethod：失败的方法 3.4.3、垃圾回收统计123456789101112[root@node01 ~]# jstat -gc 6219 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT 9216.0 8704.0 0.0 6127.3 62976.0 3560.4 33792.0 20434.9 23808.0 23196.1 2560.0 2361.6 7 1.078 1 0.244 1.323#也可以指定打印的间隔和次数，每1秒中打印一次，共打印5次[root@node01 ~]# jstat -gc 6219 1000 5 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT 9216.0 8704.0 0.0 6127.3 62976.0 3917.3 33792.0 20434.9 23808.0 23196.1 2560.0 2361.6 7 1.078 1 0.244 1.3239216.0 8704.0 0.0 6127.3 62976.0 3917.3 33792.0 20434.9 23808.0 23196.1 2560.0 2361.6 7 1.078 1 0.244 1.3239216.0 8704.0 0.0 6127.3 62976.0 3917.3 33792.0 20434.9 23808.0 23196.1 2560.0 2361.6 7 1.078 1 0.244 1.3239216.0 8704.0 0.0 6127.3 62976.0 3917.3 33792.0 20434.9 23808.0 23196.1 2560.0 2361.6 7 1.078 1 0.244 1.3239216.0 8704.0 0.0 6127.3 62976.0 3917.3 33792.0 20434.9 23808.0 23196.1 2560.0 2361.6 7 1.078 1 0.244 1.323 说明： S0C：第一个Survivor区的大小（KB） S1C：第二个Survivor区的大小（KB） S0U：第一个Survivor区的使用大小（KB） S1U：第二个Survivor区的使用大小（KB） EC：Eden区的大小（KB） EU：Eden区的使用大小（KB） OC：Old区大小（KB） OU：Old使用大小（KB） MC：方法区大小（KB） MU：方法区使用大小（KB） CCSC：压缩类空间大小（KB） CCSU：压缩类空间使用大小（KB） YGC：年轻代垃圾回收次数 YGCT：年轻代垃圾回收消耗时间 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间 4、jmap的使用以及内存溢出分析前面通过jstat可以对jvm堆的内存进行统计分析，而jmap可以获取到更加详细的内容，如：内存使用情况的汇总、对内存溢出的定位与分析。 4.1、查看内存使用情况1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[root@node01 ~]# jmap -heap 6219Attaching to process ID 6219, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.141-b15using thread-local object allocation.Parallel GC with 2 thread(s)Heap Configuration: #堆内存配置信息 MinHeapFreeRatio = 0 MaxHeapFreeRatio = 100 MaxHeapSize = 488636416 (466.0MB) NewSize = 10485760 (10.0MB) MaxNewSize = 162529280 (155.0MB) OldSize = 20971520 (20.0MB) NewRatio = 2 SurvivorRatio = 8 MetaspaceSize = 21807104 (20.796875MB) CompressedClassSpaceSize = 1073741824 (1024.0MB) MaxMetaspaceSize = 17592186044415 MB G1HeapRegionSize = 0 (0.0MB)Heap Usage: # 堆内存的使用情况PS Young Generation #年轻代Eden Space: capacity = 123731968 (118.0MB) used = 1384736 (1.320587158203125MB) free = 122347232 (116.67941284179688MB) 1.1191416594941737% usedFrom Space: capacity = 9437184 (9.0MB) used = 0 (0.0MB) free = 9437184 (9.0MB) 0.0% usedTo Space: capacity = 9437184 (9.0MB) used = 0 (0.0MB) free = 9437184 (9.0MB) 0.0% usedPS Old Generation #年老代 capacity = 28311552 (27.0MB) used = 13698672 (13.064071655273438MB) free = 14612880 (13.935928344726562MB) 48.38545057508681% used13648 interned Strings occupying 1866368 bytes. 4.2、查看内存中对象数量及大小12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#查看所有对象，包括活跃以及非活跃的jmap -histo &lt;pid&gt; | more#查看活跃对象jmap -histo:live &lt;pid&gt; | more[root@node01 ~]# jmap -histo:live 6219 | more num #instances #bytes class name---------------------------------------------- 1: 37437 7914608 [C 2: 34916 837984 java.lang.String 3: 884 654848 [B 4: 17188 550016 java.util.HashMap$Node 5: 3674 424968 java.lang.Class 6: 6322 395512 [Ljava.lang.Object; 7: 3738 328944 java.lang.reflect.Method 8: 1028 208048 [Ljava.util.HashMap$Node; 9: 2247 144264 [I 10: 4305 137760 java.util.concurrent.ConcurrentHashMap$Node 11: 1270 109080 [Ljava.lang.String; 12: 64 84128 [Ljava.util.concurrent.ConcurrentHashMap$Node; 13: 1714 82272 java.util.HashMap 14: 3285 70072 [Ljava.lang.Class; 15: 2888 69312 java.util.ArrayList 16: 3983 63728 java.lang.Object 17: 1271 61008 org.apache.tomcat.util.digester.CallMethodRule 18: 1518 60720 java.util.LinkedHashMap$Entry 19: 1671 53472 com.sun.org.apache.xerces.internal.xni.QName 20: 88 50880 [Ljava.util.WeakHashMap$Entry; 21: 618 49440 java.lang.reflect.Constructor 22: 1545 49440 java.util.Hashtable$Entry 23: 1027 41080 java.util.TreeMap$Entry 24: 846 40608 org.apache.tomcat.util.modeler.AttributeInfo 25: 142 38032 [S 26: 946 37840 java.lang.ref.SoftReference 27: 226 36816 [[C 。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。 #对象说明B byteC charD doubleF floatI intJ longZ boolean[ 数组，如[I表示int[][L+类名 其他对象 4.3、将内存使用情况dump到文件中有些时候我们需要将jvm当前内存中的情况dump到文件中，然后对它进行分析，jmap也是支持dump到文件中的。 12345#用法：jmap -dump:format=b,file=dumpFileName &lt;pid&gt;#示例jmap -dump:format=b,file=/tmp/dump.dat 6219 可以看到已经在/tmp下生成了dump.dat的文件。 4.4、通过jhat对dump文件进行分析在上一小节中，我们将jvm的内存dump到文件中，这个文件是一个二进制的文件，不方便查看，这时我们可以借助于jhat工具进行查看。 1234567891011121314#用法：jhat -port &lt;port&gt; &lt;file&gt;#示例：[root@node01 tmp]# jhat -port 9999 /tmp/dump.dat Reading from /tmp/dump.dat...Dump file created Mon Sep 10 01:04:21 CST 2018Snapshot read, resolving...Resolving 204094 objects...Chasing references, expect 40 dots........................................Eliminating duplicate references........................................Snapshot resolved.Started HTTP server on port 9999Server is ready. 打开浏览器进行访问：http://192.168.40.133:9999/ 在最后面有OQL查询功能。 4.5、通过MAT工具对dump文件进行分析4.5.1、MAT工具介绍MAT(Memory Analyzer Tool)，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的JAVA heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。 官网地址：https://www.eclipse.org/mat/ 4.5.2、下载安装下载地址：https://www.eclipse.org/mat/downloads.php 将下载得到的MemoryAnalyzer-1.8.0.20180604-win32.win32.x86_64.zip进行解压： 4.5.3、使用 查看对象以及它的依赖： 查看可能存在内存泄露的分析： 5、实战：内存溢出的定位与分析内存溢出在实际的生产环境中经常会遇到，比如，不断的将数据写入到一个集合中，出现了死循环，读取超大的文件等等，都可能会造成内存溢出。 如果出现了内存溢出，首先我们需要定位到发生内存溢出的环节，并且进行分析，是正常还是非正常情况，如果是正常的需求，就应该考虑加大内存的设置，如果是非正常需求，那么就要对代码进行修改，修复这个bug。 首先，我们得先学会如何定位问题，然后再进行分析。如何定位问题呢，我们需要借助于jmap与MAT工具进行定位分析。 接下来，我们模拟内存溢出的场景。 5.1、模拟内存溢出编写代码，向List集合中添加100万个字符串，每个字符串由1000个UUID组成。如果程序能够正常执行，最后打印ok。 1234567891011121314151617181920package cn.bestqiang.jvm;import java.util.ArrayList;import java.util.List;import java.util.UUID;public class TestJvmOutOfMemory &#123; public static void main(String[] args) &#123; List&lt;Object&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10000000; i++) &#123; String str = ""; for (int j = 0; j &lt; 1000; j++) &#123; str += UUID.randomUUID().toString(); &#125; list.add(str); &#125; System.out.println("ok"); &#125;&#125; 为了演示效果，我们将设置执行的参数，这里使用的是Idea编辑器。 12#参数如下：-Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError 5.2、运行测试测试结果如下： 1234567891011java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid5348.hprof ...Heap dump file created [8137186 bytes in 0.032 secs]Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124) at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448) at java.lang.StringBuilder.append(StringBuilder.java:136) at cn.bestqiang.jvm.TestJvmOutOfMemory.main(TestJvmOutOfMemory.java:14)Process finished with exit code 1 可以看到，当发生内存溢出时，会dump文件到java_pid5348.hprof。 5.3、导入到MAT工具中进行分析 可以看到，有91.03%的内存由Object[]数组占有，所以比较可疑。 分析：这个可疑是正确的，因为已经有超过90%的内存都被它占有，这是非常有可能出现内存溢出的。 查看详情： 可以看到集合中存储了大量的uuid字符串。 6、jstack的使用有些时候我们需要查看下jvm中的线程执行情况，比如，发现服务器的CPU的负载突然增高了、出现了死锁、死循环等，我们该如何分析呢？ 由于程序是正常运行的，没有任何的输出，从日志方面也看不出什么问题，所以就需要看下jvm的内部线程的执行情况，然后再进行分析查找出原因。 这个时候，就需要借助于jstack命令了，jstack的作用是将正在运行的jvm的线程情况进行快照，并且打印出来： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#用法：jstack &lt;pid&gt;[root@node01 bin]# jstack 2203Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.141-b15 mixed mode):"Attach Listener" #24 daemon prio=9 os_prio=0 tid=0x00007fabb4001000 nid=0x906 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE"http-bio-8080-exec-5" #23 daemon prio=5 os_prio=0 tid=0x00007fabb057c000 nid=0x8e1 waiting on condition [0x00007fabd05b8000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for &lt;0x00000000f8508360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039) at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32) at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748)"http-bio-8080-exec-4" #22 daemon prio=5 os_prio=0 tid=0x00007fab9c113800 nid=0x8e0 waiting on condition [0x00007fabd06b9000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for &lt;0x00000000f8508360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039) at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32) at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748)"http-bio-8080-exec-3" #21 daemon prio=5 os_prio=0 tid=0x0000000001aeb800 nid=0x8df waiting on condition [0x00007fabd09ba000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for &lt;0x00000000f8508360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039) at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32) at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748)"http-bio-8080-exec-2" #20 daemon prio=5 os_prio=0 tid=0x0000000001aea000 nid=0x8de waiting on condition [0x00007fabd0abb000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for &lt;0x00000000f8508360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039) at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32) at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748)"http-bio-8080-exec-1" #19 daemon prio=5 os_prio=0 tid=0x0000000001ae8800 nid=0x8dd waiting on condition [0x00007fabd0bbc000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for &lt;0x00000000f8508360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039) at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104) at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32) at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748)"ajp-bio-8009-AsyncTimeout" #17 daemon prio=5 os_prio=0 tid=0x00007fabe8128000 nid=0x8d0 waiting on condition [0x00007fabd0ece000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method) at org.apache.tomcat.util.net.JIoEndpoint$AsyncTimeout.run(JIoEndpoint.java:152) at java.lang.Thread.run(Thread.java:748)"ajp-bio-8009-Acceptor-0" #16 daemon prio=5 os_prio=0 tid=0x00007fabe82d4000 nid=0x8cf runnable [0x00007fabd0fcf000] java.lang.Thread.State: RUNNABLE at java.net.PlainSocketImpl.socketAccept(Native Method) at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409) at java.net.ServerSocket.implAccept(ServerSocket.java:545) at java.net.ServerSocket.accept(ServerSocket.java:513) at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket(DefaultServerSocketFactory.java:60) at org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:220) at java.lang.Thread.run(Thread.java:748)"http-bio-8080-AsyncTimeout" #15 daemon prio=5 os_prio=0 tid=0x00007fabe82d1800 nid=0x8ce waiting on condition [0x00007fabd10d0000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method) at org.apache.tomcat.util.net.JIoEndpoint$AsyncTimeout.run(JIoEndpoint.java:152) at java.lang.Thread.run(Thread.java:748)"http-bio-8080-Acceptor-0" #14 daemon prio=5 os_prio=0 tid=0x00007fabe82d0000 nid=0x8cd runnable [0x00007fabd11d1000] java.lang.Thread.State: RUNNABLE at java.net.PlainSocketImpl.socketAccept(Native Method) at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409) at java.net.ServerSocket.implAccept(ServerSocket.java:545) at java.net.ServerSocket.accept(ServerSocket.java:513) at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket(DefaultServerSocketFactory.java:60) at org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:220) at java.lang.Thread.run(Thread.java:748)"ContainerBackgroundProcessor[StandardEngine[Catalina]]" #13 daemon prio=5 os_prio=0 tid=0x00007fabe82ce000 nid=0x8cc waiting on condition [0x00007fabd12d2000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method) at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1513) at java.lang.Thread.run(Thread.java:748)"GC Daemon" #10 daemon prio=2 os_prio=0 tid=0x00007fabe83b4000 nid=0x8b3 in Object.wait() [0x00007fabd1c2f000] java.lang.Thread.State: TIMED_WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000000e315c2d0&gt; (a sun.misc.GC$LatencyLock) at sun.misc.GC$Daemon.run(GC.java:117) - locked &lt;0x00000000e315c2d0&gt; (a sun.misc.GC$LatencyLock)"Service Thread" #7 daemon prio=9 os_prio=0 tid=0x00007fabe80c3800 nid=0x8a5 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE"C1 CompilerThread1" #6 daemon prio=9 os_prio=0 tid=0x00007fabe80b6800 nid=0x8a4 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE"C2 CompilerThread0" #5 daemon prio=9 os_prio=0 tid=0x00007fabe80b3800 nid=0x8a3 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE"Signal Dispatcher" #4 daemon prio=9 os_prio=0 tid=0x00007fabe80b2000 nid=0x8a2 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE"Finalizer" #3 daemon prio=8 os_prio=0 tid=0x00007fabe807f000 nid=0x8a1 in Object.wait() [0x00007fabd2a67000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000000e3162918&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143) - locked &lt;0x00000000e3162918&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164) at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)"Reference Handler" #2 daemon prio=10 os_prio=0 tid=0x00007fabe807a800 nid=0x8a0 in Object.wait() [0x00007fabd2b68000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000000e3162958&gt; (a java.lang.ref.Reference$Lock) at java.lang.Object.wait(Object.java:502) at java.lang.ref.Reference.tryHandlePending(Reference.java:191) - locked &lt;0x00000000e3162958&gt; (a java.lang.ref.Reference$Lock) at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)"main" #1 prio=5 os_prio=0 tid=0x00007fabe8009000 nid=0x89c runnable [0x00007fabed210000] java.lang.Thread.State: RUNNABLE at java.net.PlainSocketImpl.socketAccept(Native Method) at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409) at java.net.ServerSocket.implAccept(ServerSocket.java:545) at java.net.ServerSocket.accept(ServerSocket.java:513) at org.apache.catalina.core.StandardServer.await(StandardServer.java:453) at org.apache.catalina.startup.Catalina.await(Catalina.java:777) at org.apache.catalina.startup.Catalina.start(Catalina.java:723) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:321) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:455)"VM Thread" os_prio=0 tid=0x00007fabe8073000 nid=0x89f runnable "GC task thread#0 (ParallelGC)" os_prio=0 tid=0x00007fabe801e000 nid=0x89d runnable "GC task thread#1 (ParallelGC)" os_prio=0 tid=0x00007fabe8020000 nid=0x89e runnable "VM Periodic Task Thread" os_prio=0 tid=0x00007fabe80d6800 nid=0x8a6 waiting on condition JNI global references: 43 6.1、线程的状态 在Java中线程的状态一共被分成6种： 初始态（NEW） 创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。 运行态（RUNNABLE），在Java中，运行态包括 就绪态 和 运行态。 就绪态 该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。 所有就绪态的线程存放在就绪队列中。 运行态 获得CPU执行权，正在执行的线程。 由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。 阻塞态（BLOCKED） 当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。 而在Java中，阻塞态专指请求锁失败时进入的状态。 由一个阻塞队列存放所有阻塞态的线程。 处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。 等待态（WAITING） 当前线程中调用wait、join、park函数时，当前线程就会进入等待态。 也有一个等待队列存放所有等待态的线程。 线程处于等待态表示它需要等待其他线程的指示才能继续运行。 进入等待态的线程会释放CPU执行权，并释放资源（如：锁） 超时等待态（TIMED_WAITING） 当运行中的线程调用sleep(time)、wait、join、parkNanos、parkUntil时，就会进入该状态； 它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒； 进入该状态后释放CPU执行权 和 占有的资源。 与等待态的区别：到了超时时间后自动进入阻塞队列，开始竞争锁。 终止态（TERMINATED） 线程执行结束后的状态。 6.2、实战：死锁问题如果在生产环境发生了死锁，我们将看到的是部署的程序没有任何反应了，这个时候我们可以借助jstack进行分析，下面我们实战下查找死锁的原因。 6.2.1、构造死锁编写代码，启动2个线程，Thread1拿到了obj1锁，准备去拿obj2锁时，obj2已经被Thread2锁定，所以发送了死锁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class TestDeadLock &#123; private static Object obj1 = new Object(); private static Object obj2 = new Object(); public static void main(String[] args) &#123; new Thread(new Thread1()).start(); new Thread(new Thread2()).start(); &#125; private static class Thread1 implements Runnable&#123; @Override public void run() &#123; synchronized (obj1)&#123; System.out.println("Thread1 拿到了 obj1 的锁！"); try &#123; // 停顿2秒的意义在于，让Thread2线程拿到obj2的锁 Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (obj2)&#123; System.out.println("Thread1 拿到了 obj2 的锁！"); &#125; &#125; &#125; &#125; private static class Thread2 implements Runnable&#123; @Override public void run() &#123; synchronized (obj2)&#123; System.out.println("Thread2 拿到了 obj2 的锁！"); try &#123; // 停顿2秒的意义在于，让Thread1线程拿到obj1的锁 Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (obj1)&#123; System.out.println("Thread2 拿到了 obj1 的锁！"); &#125; &#125; &#125; &#125;&#125; 6.2.2、在linux上运行123456789101112131415[root@node01 test]# javac TestDeadLock.java [root@node01 test]# ll总用量 28-rw-r--r--. 1 root root 184 9月 11 10:39 TestDeadLock$1.class-rw-r--r--. 1 root root 843 9月 11 10:39 TestDeadLock.class-rw-r--r--. 1 root root 1567 9月 11 10:39 TestDeadLock.java-rw-r--r--. 1 root root 1078 9月 11 10:39 TestDeadLock$Thread1.class-rw-r--r--. 1 root root 1078 9月 11 10:39 TestDeadLock$Thread2.class-rw-r--r--. 1 root root 573 9月 9 10:21 TestJVM.class-rw-r--r--. 1 root root 261 9月 9 10:21 TestJVM.java[root@node01 test]# java TestDeadLockThread1 拿到了 obj1 的锁！Thread2 拿到了 obj2 的锁！#这里发生了死锁，程序一直将等待下去 6.2.3、使用jstack进行分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687[root@node01 ~]# jstack 3256Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.141-b15 mixed mode):"Attach Listener" #11 daemon prio=9 os_prio=0 tid=0x00007f5bfc001000 nid=0xcff waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE"DestroyJavaVM" #10 prio=5 os_prio=0 tid=0x00007f5c2c008800 nid=0xcb9 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE"Thread-1" #9 prio=5 os_prio=0 tid=0x00007f5c2c0e9000 nid=0xcc5 waiting for monitor entry [0x00007f5c1c7f6000] java.lang.Thread.State: BLOCKED (on object monitor) at TestDeadLock$Thread2.run(TestDeadLock.java:47) - waiting to lock &lt;0x00000000f655dc40&gt; (a java.lang.Object) - locked &lt;0x00000000f655dc50&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:748)"Thread-0" #8 prio=5 os_prio=0 tid=0x00007f5c2c0e7000 nid=0xcc4 waiting for monitor entry [0x00007f5c1c8f7000] java.lang.Thread.State: BLOCKED (on object monitor) at TestDeadLock$Thread1.run(TestDeadLock.java:27) - waiting to lock &lt;0x00000000f655dc50&gt; (a java.lang.Object) - locked &lt;0x00000000f655dc40&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:748)"Service Thread" #7 daemon prio=9 os_prio=0 tid=0x00007f5c2c0d3000 nid=0xcc2 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE"C1 CompilerThread1" #6 daemon prio=9 os_prio=0 tid=0x00007f5c2c0b6000 nid=0xcc1 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE"C2 CompilerThread0" #5 daemon prio=9 os_prio=0 tid=0x00007f5c2c0b3000 nid=0xcc0 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE"Signal Dispatcher" #4 daemon prio=9 os_prio=0 tid=0x00007f5c2c0b1800 nid=0xcbf runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE"Finalizer" #3 daemon prio=8 os_prio=0 tid=0x00007f5c2c07e800 nid=0xcbe in Object.wait() [0x00007f5c1cdfc000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000000f6508ec8&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143) - locked &lt;0x00000000f6508ec8&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164) at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)"Reference Handler" #2 daemon prio=10 os_prio=0 tid=0x00007f5c2c07a000 nid=0xcbd in Object.wait() [0x00007f5c1cefd000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000000f6506b68&gt; (a java.lang.ref.Reference$Lock) at java.lang.Object.wait(Object.java:502) at java.lang.ref.Reference.tryHandlePending(Reference.java:191) - locked &lt;0x00000000f6506b68&gt; (a java.lang.ref.Reference$Lock) at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)"VM Thread" os_prio=0 tid=0x00007f5c2c072800 nid=0xcbc runnable "GC task thread#0 (ParallelGC)" os_prio=0 tid=0x00007f5c2c01d800 nid=0xcba runnable "GC task thread#1 (ParallelGC)" os_prio=0 tid=0x00007f5c2c01f800 nid=0xcbb runnable "VM Periodic Task Thread" os_prio=0 tid=0x00007f5c2c0d6800 nid=0xcc3 waiting on condition JNI global references: 6Found one Java-level deadlock:============================="Thread-1": waiting to lock monitor 0x00007f5c080062c8 (object 0x00000000f655dc40, a java.lang.Object), which is held by "Thread-0""Thread-0": waiting to lock monitor 0x00007f5c08004e28 (object 0x00000000f655dc50, a java.lang.Object), which is held by "Thread-1"Java stack information for the threads listed above:==================================================="Thread-1": at TestDeadLock$Thread2.run(TestDeadLock.java:47) - waiting to lock &lt;0x00000000f655dc40&gt; (a java.lang.Object) - locked &lt;0x00000000f655dc50&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:748)"Thread-0": at TestDeadLock$Thread1.run(TestDeadLock.java:27) - waiting to lock &lt;0x00000000f655dc50&gt; (a java.lang.Object) - locked &lt;0x00000000f655dc40&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:748)Found 1 deadlock. 在输出的信息中，已经看到，发现了1个死锁，关键看这个： 12345678910"Thread-1": at TestDeadLock$Thread2.run(TestDeadLock.java:47) - waiting to lock &lt;0x00000000f655dc40&gt; (a java.lang.Object) - locked &lt;0x00000000f655dc50&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:748)"Thread-0": at TestDeadLock$Thread1.run(TestDeadLock.java:27) - waiting to lock &lt;0x00000000f655dc50&gt; (a java.lang.Object) - locked &lt;0x00000000f655dc40&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:748) 可以清晰的看到： Thread2获取了 的锁，等待获取 这个锁 Thread1获取了 的锁，等待获取 这个锁 由此可见，发生了死锁。 7、VisualVM工具的使用VisualVM，能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈(如100个String对象分别由哪几个对象分配出来的)。 VisualVM使用简单，几乎0配置，功能还是比较丰富的，几乎囊括了其它JDK自带命令的所有功能。 内存信息 线程信息 Dump堆（本地进程） Dump线程（本地进程） 打开堆Dump。堆Dump可以用jmap来生成。 打开线程Dump 生成应用快照（包含内存信息、线程信息等等） 性能分析。CPU分析（各个方法调用时间，检查哪些方法耗时多），内存分析（各类对象占用的内存，检查哪些类占用内存多） …… 7.1、启动在jdk的安装目录的bin目录下，找到jvisualvm.exe，双击打开即可。 7.2、查看本地进程 7.3、查看CPU、内存、类、线程运行信息 7.4、查看线程详情 也可以点击右上角Dump按钮，将线程的信息导出，其实就是执行的jstack命令。 发现，显示的内容是一样的。 7.5、抽样器抽样器可以对CPU、内存在一段时间内进行抽样，以供分析。 7.6、监控远程的jvmVisualJVM不仅是可以监控本地jvm进程，还可以监控远程的jvm进程，需要借助于JMX技术实现。 7.6.1、什么是JMX？JMX（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。 7.6.2、监控远程的tomcat想要监控远程的tomcat，就需要在远程的tomcat进行对JMX配置，方法如下： 123456789#在tomcat的bin目录下，修改catalina.sh，添加如下的参数JAVA_OPTS="-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false"#这几个参数的意思是：#-Dcom.sun.management.jmxremote ：允许使用JMX远程管理#-Dcom.sun.management.jmxremote.port=9999 ：JMX远程连接端口#-Dcom.sun.management.jmxremote.authenticate=false ：不进行身份认证，任何用户都可以连接#-Dcom.sun.management.jmxremote.ssl=false ：不使用ssl 保存退出，重启tomcat。 7.6.3、使用VisualJVM连接远程tomcat添加远程主机： 在一个主机下可能会有很多的jvm需要监控，所以接下来要在该主机上添加需要监控的jvm： 连接成功。使用方法和前面就一样了，就可以和监控本地jvm进程一样，监控远程的tomcat进程。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM优化+Tomcat优化]]></title>
    <url>%2F2019%2F05%2F30%2FJVM%E4%BC%98%E5%8C%96-Tomcat%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[JVM优化+Tomcat优化 Tomcat8的优化 看懂Java底层字节码 编码的优化建议 1、Tomcat8优化tomcat服务器在JavaEE项目中使用率非常高，所以在生产环境对tomcat的优化也变得非常重要了。 对于tomcat的优化，主要是从2个方面入手，一是，tomcat自身的配置，另一个是tomcat所运行的jvm虚拟机的调优。 下面我们将从这2个方面进行讲解。 1.1、Tomcat配置优化1.1.1、部署安装tomcat8下载并安装： https://tomcat.apache.org/download-80.cgi 1234567891011121314151617181920212223242526272829303132cd /tmpwget http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.34/bin/apache-tomcat-8.5.34.tar.gztar -xvf apache-tomcat-8.5.34.tar.gzcd apache-tomcat-8.5.34/conf#修改配置文件，配置tomcat的管理用户vim tomcat-users.xml#写入如下内容：&lt;role rolename="manager"/&gt;&lt;role rolename="manager-gui"/&gt;&lt;role rolename="admin"/&gt;&lt;role rolename="admin-gui"/&gt;&lt;user username="tomcat" password="tomcat" roles="admin-gui,admin,manager-gui,manager"/&gt;#保存退出#如果是tomcat7，配置了tomcat用户就可以登录系统了，但是tomcat8中不行，还需要修改另一个配置文件，否则访问不了，提示403vim webapps/manager/META-INF/context.xml#将&lt;Valve的内容注释掉&lt;Context antiResourceLocking="false" privileged="true" &gt; &lt;!-- &lt;Valve className="org.apache.catalina.valves.RemoteAddrValve" allow="127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1" /&gt; --&gt; &lt;Manager sessionAttributeValueClassNameFilter="java\.lang\.(?:Boolean|Integer|Long|Number|String)|org\.apache\.catalina\.filters\.CsrfPreventionFilter\$LruCache(?:\$1)?|java\.util\.(?:Linked)?HashMap"/&gt;&lt;/Context&gt;#保存退出即可#启动tomcatcd /tmp/apache-tomcat-8.5.34/bin/./startup.sh &amp;&amp; tail -f ../logs/catalina.out#打开浏览器进行测试访问http://192.168.40.133:8080/ 点击“Server Status”，输入用户名、密码进行登录，tomcat/tomcat 进入之后即可看到服务的信息。 1.1.2、禁用AJP连接在服务状态页面中可以看到，默认状态下会启用AJP服务，并且占用8009端口。 什么是AJP呢？ AJP（Apache JServer Protocol）AJPv13协议是面向包的。WEB服务器和Servlet容器通过TCP连接来交互；为了节省SOCKET创建的昂贵代价，WEB服务器会尝试维护一个永久TCP连接到servlet容器，并且在多个请求和响应周期过程会重用连接。 我们一般是使用Nginx+tomcat的架构，所以用不着AJP协议，所以把AJP连接器禁用。 修改conf下的server.xml文件，将AJP服务禁用掉即可。 1&lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt; 重启tomcat，查看效果。 可以看到AJP服务以及不存在了。 1.1.3、执行器（线程池）在tomcat中每一个用户请求都是一个线程，所以可以使用线程池提高性能。 修改server.xml文件： 123456789101112131415&lt;!--将注释打开--&gt;&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="500" minSpareThreads="50" prestartminSpareThreads="true" maxQueueSize="100"/&gt;&lt;!--参数说明：maxThreads：最大并发数，默认设置 200，一般建议在 500 ~ 1000，根据硬件设施和业务来判断minSpareThreads：Tomcat 初始化时创建的线程数，默认设置 25prestartminSpareThreads： 在 Tomcat 初始化的时候就初始化 minSpareThreads 的参数值，如果不等于 true，minSpareThreads 的值就没啥效果了maxQueueSize，最大的等待队列数，超过则拒绝请求--&gt;&lt;!--在Connector中设置executor属性指向上面的执行器--&gt;&lt;Connector executor="tomcatThreadPool" port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 保存退出，重启tomcat，查看效果。 在页面中显示最大线程数为-1，这个是正常的，仅仅是显示的问题，实际使用的指定的值。 也有人遇到这样的问题：https://blog.csdn.net/weixin_38278878/article/details/80144397 1.1.4、3种运行模式tomcat的运行模式有3种： bio默认的模式,性能非常低下,没有经过任何优化处理和支持. nionio(new I/O)，是Java SE 1.4及后续版本提供的一种新的I/O操作方式(即java.nio包及其子包)。Java nio是一个基于缓冲区、并能提供非阻塞I/O操作的Java API，因此nio也被看成是non-blocking I/O的缩写。它拥有比传统I/O操作(bio)更好的并发运行性能。 apr安装起来最困难,但是从操作系统级别来解决异步的IO问题,大幅度的提高性能. 推荐使用nio，不过，在tomcat8中有最新的nio2，速度更快，建议使用nio2. 设置nio2： 123&lt;Connector executor="tomcatThreadPool" port="8080" protocol="org.apache.coyote.http11.Http11Nio2Protocol" connectionTimeout="20000" redirectPort="8443" /&gt; 可以看到已经设置为nio2了。 1.2、部署测试用的java web项目为了方便测试性能，我们将部署一个java web项目，这个项目本身和本套课程没有什么关系，仅仅用于测试。 注意：这里在测试时，我们使用一个新的tomcat，进行测试，后面再对其进行优化调整，再测试。 1.2.1、创建dashboard数据库在资料中找到sql脚本文件dashboard.sql，在linux服务器上执行。 1cat dashboard.sql | mysql -uroot -proot 创建完成后，可以看到有3张表。 1.2.2、部署web应用在资料中找到itcat-dashboard-web.war，上传到linux服务器，进行部署安装。 12345678910111213141516171819cd /tmp/apache-tomcat-8.5.34/webappsrm -rf *mkdir ROOTcd ROOT/rz上传war包jar -xvf itcat-dashboard-web.warrm -rf itcat-dashboard-web.war#修改数据库配置文件cd /tmp/apache-tomcat-8.5.34/webapps/ROOT/WEB-INF/classesvim jdbc.properties#这里根据自己的实际情况进行配置jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://node01:3306/dashboard?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=truejdbc.username=rootjdbc.password=root 重新启动tomcat。 访问首页，查看是否已经启动成功：http://192.168.40.133:8080/index 1.3、使用Apache JMeter进行测试Apache Jmeter是开源的压力测试工具，我们借助于此工具进行测试，将测试出tomcat的吞吐量等信息。 1.3.1、下载安装下载地址：http://jmeter.apache.org/download_jmeter.cgi 安装：直接将下载好的zip压缩包进行解压即可。 进入bin目录，找到jmeter.bat文件，双机打开即可启动。 1.3.2、修改主题和语言默认的主题是黑色风格的主题并且语言是英语，这样不太方便使用，所以需要修改下主题和中文语言。 主题修改完成。 接下来设置语言为简体中文。 语言修改完成。 1.3.3、创建首页的测试用例第一步：保存测试用例 第二步：添加线程组，使用线程模拟用户的并发 1000个线程，每个线程循环10次，也就是tomcat会接收到10000个请求。 第三步：添加http请求 第四步：添加请求监控 1.3.4、启动、进行测试 1.3.5、聚合报告在聚合报告中，重点看吞吐量。 1.4、调整tomcat参数进行优化通过上面测试可以看出，tomcat在不做任何调整时，吞吐量为73次/秒。 1.4.1、禁用AJP服务 可以看到，禁用AJP服务后，吞吐量会有所提升。 当然了，测试不一定准确，需要多测试几次才能看出是否有提升。 1.4.2、设置线程池通过设置线程池，调整线程池相关的参数进行测试tomcat的性能。 1.4.2.1、最大线程数为500，初始为5012&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="500" minSpareThreads="50" prestartminSpareThreads="true"/&gt; 测试结果： 吞吐量为128次/秒，性能有所提升。 1.4.2.2、最大线程数为1000，初始为20012&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="1000" minSpareThreads="200" prestartminSpareThreads="true"/&gt; 吞吐量为151，性能有所提升。 1.4.2.3、最大线程数为5000，初始为1000是否是线程数最多，速度越快呢？ 我们来测试下。 12&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="5000" minSpareThreads="1000" prestartminSpareThreads="true"/&gt; 可以看到，虽然最大线程已经设置到5000，但是实际测试效果并不理想，并且平均的响应时间也边长了，所以单纯靠提升线程数量是不能一直得到性能提升的。 1.4.2.4、设置最大等待队列数默认情况下，请求发送到tomcat，如果tomcat正忙，那么该请求会一直等待。这样虽然可以保证每个请求都能请求到，但是请求时间就会边长。 有些时候，我们也不一定要求请求一定等待，可以设置最大等待队列大小，如果超过就不等待了。这样虽然有些请求是失败的，但是请求时间会虽短。典型的应用：12306。 123&lt;!--最大等待数为100--&gt;&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="500" minSpareThreads="100" prestartminSpareThreads="true" maxQueueSize="100"/&gt; 测试结果： 平均响应时间：3.1秒 响应时间明显缩短 错误率：49.88% 错误率提升到一半，也可以理解，最大线程为500，测试的并发为1000 吞吐量：238次/秒 吞吐量明显提升 结论：响应时间、吞吐量这2个指标需要找到平衡才能达到更好的性能。 1.4.3、设置nio2的运行模式将最大线程设置为500进行测试： 1234567&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-" maxThreads="500" minSpareThreads="50" prestartminSpareThreads="true"/&gt;&lt;!-- 设置nio2 --&gt;&lt;Connector executor="tomcatThreadPool" port="8080" protocol="org.apache.coyote.http11.Http11Nio2Protocol" connectionTimeout="20000" redirectPort="8443" /&gt; 可以看到，平均响应时间有缩短，吞吐量有提升，可以得出结论：nio2的性能要高于nio。 1.5、调整JVM参数进行优化接下来，测试通过jvm参数进行优化，为了测试一致性，依然将最大线程数设置为500，启用nio2运行模式。 1.5.1、设置并行垃圾回收器12#年轻代、老年代均使用并行收集器，初始堆内存64M，最大堆内存512MJAVA_OPTS="-XX:+UseParallelGC -XX:+UseParallelOldGC -Xms64m -Xmx512m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:../logs/gc.log" 测试结果与默认的JVM参数结果接近。（执行了2次测试，结果是第二次测试的结果） 1.5.2、查看gc日志文件将gc.log文件上传到gceasy.io查看gc中是否存在问题。 问题一： 在报告中显示，在5次GC时，系统所消耗的时间大于用户时间，这反应出的服务器的性能存在瓶颈，调度CPU等资源所消耗的时间要长一些。 问题二： 可以关键指标中可以看出，吞吐量表现不错，但是gc时，线程的暂停时间稍有点长。 问题三： 通过GC的统计可以看出： 年轻代的gc有74次，次数稍有多，说明年轻代设置的大小不合适需要调整 FullGC有8次，说明堆内存的大小不合适，需要调整 问题四： 从GC原因的可以看出，年轻代大小设置不合理，导致了多次GC。 1.5.3、调整年轻代大小1JAVA_OPTS="-XX:+UseParallelGC -XX:+UseParallelOldGC -Xms128m -Xmx1024m -XX:NewSize=64m -XX:MaxNewSize=256m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:../logs/gc.log" 将初始堆大小设置为128m，最大为1024m 初始年轻代大小64m，年轻代最大256m 从测试结果来看，吞吐量以及响应时间均有提升。 查看gc日志： 可以看到GC次数要明显减少，说明调整是有效的。 1.5.4、设置G1垃圾回收器12#设置了最大停顿时间100毫秒，初始堆内存128m，最大堆内存1024mJAVA_OPTS="-XX:+UseG1GC -XX:MaxGCPauseMillis=100 -Xms128m -Xmx1024m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:../logs/gc.log" 测试结果： 可以看到，吞吐量有所提升，评价响应时间也有所缩短。 1.5.5、小结通过上述的测试，可以总结出，对tomcat性能优化就是需要不断的进行调整参数，然后测试结果，可能会调优也可能会调差，这时就需要借助于gc的可视化工具来看gc的情况。再帮我我们做出决策应该调整哪些参数。 2、JVM字节码前面我们通过tomcat本身的参数以及jvm的参数对tomcat做了优化，其实要想将应用程序跑的更快、效率更高，除了对tomcat容器以及jvm优化外，应用程序代码本身如果写的效率不高的，那么也是不行的，所以，对于程序本身的优化也就很重要了。 对于程序本身的优化，可以借鉴很多前辈们的经验，但是有些时候，在从源码角度方面分析的话，不好鉴别出哪个效率高，如对字符串拼接的操作，是直接“+”号拼接效率高还是使用StringBuilder效率高？ 这个时候，就需要通过查看编译好的class文件中字节码，就可以找到答案。 我们都知道，java编写应用，需要先通过javac命令编译成class文件，再通过jvm执行，jvm执行时是需要将class文件中的字节码载入到jvm进行运行的。 2.1、通过javap命令查看class文件的字节码内容首先，看一个简单的Test1类的代码： 123456789101112package cn.itcast.jvm;public class Test1 &#123; public static void main(String[] args) &#123; int a = 2; int b = 5; int c = b - a; System.out.println(c); &#125;&#125; 通过javap命令查看class文件中的字节码内容： 123456789101112131415161718192021javap -v Test1.class &gt; Test1.txtjavap用法: javap &lt;options&gt; &lt;classes&gt;其中, 可能的选项包括: -help --help -? 输出此用法消息 -version 版本信息 -v -verbose 输出附加信息 -l 输出行号和本地变量表 -public 仅显示公共类和成员 -protected 显示受保护的/公共类和成员 -package 显示程序包/受保护的/公共类 和成员 (默认) -p -private 显示所有类和成员 -c 对代码进行反汇编 -s 输出内部类型签名 -sysinfo 显示正在处理的类的 系统信息 (路径, 大小, 日期, MD5 散列) -constants 显示最终常量 -classpath &lt;path&gt; 指定查找用户类文件的位置 -cp &lt;path&gt; 指定查找用户类文件的位置 -bootclasspath &lt;path&gt; 覆盖引导类文件的位置 查看Test1.txt文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990Classfile /F:/code/bestqiang-jvm/bestqiang-jvm-test/target/classes/cn/bestqiang/jvm/Test1.class Last modified 2018-9-27; size 577 bytes MD5 checksum 4214859db3543c0c783ec8a216a4795f Compiled from "Test1.java"public class cn.bestqiang.jvm.Test1 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #5.#23 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #24.#25 // java/lang/System.out:Ljava/io/PrintStream; #3 = Methodref #26.#27 // java/io/PrintStream.println:(I)V #4 = Class #28 // cn/bestqiang/jvm/Test1 #5 = Class #29 // java/lang/Object #6 = Utf8 &lt;init&gt; #7 = Utf8 ()V #8 = Utf8 Code #9 = Utf8 LineNumberTable #10 = Utf8 LocalVariableTable #11 = Utf8 this #12 = Utf8 Lcn/bestqiang/jvm/Test1; #13 = Utf8 main #14 = Utf8 ([Ljava/lang/String;)V #15 = Utf8 args #16 = Utf8 [Ljava/lang/String; #17 = Utf8 a #18 = Utf8 I #19 = Utf8 b #20 = Utf8 c #21 = Utf8 SourceFile #22 = Utf8 Test1.java #23 = NameAndType #6:#7 // "&lt;init&gt;":()V #24 = Class #30 // java/lang/System #25 = NameAndType #31:#32 // out:Ljava/io/PrintStream; #26 = Class #33 // java/io/PrintStream #27 = NameAndType #34:#35 // println:(I)V #28 = Utf8 cn/bestqiang/jvm/Test1 #29 = Utf8 java/lang/Object #30 = Utf8 java/lang/System #31 = Utf8 out #32 = Utf8 Ljava/io/PrintStream; #33 = Utf8 java/io/PrintStream #34 = Utf8 println #35 = Utf8 (I)V&#123; public cn.bestqiang.jvm.Test1(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcn/bestqiang/jvm/Test1; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: iconst_2 1: istore_1 2: iconst_5 3: istore_2 4: iload_2 5: iload_1 6: isub 7: istore_3 8: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 11: iload_3 12: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 15: return LineNumberTable: line 6: 0 line 7: 2 line 8: 4 line 9: 8 line 10: 15 LocalVariableTable: Start Length Slot Name Signature 0 16 0 args [Ljava/lang/String; 2 14 1 a I 4 12 2 b I 8 8 3 c I&#125;SourceFile: "Test1.java" 内容大致分为4个部分： 第一部分：显示了生成这个class的java源文件、版本信息、生成时间等。 第二部分：显示了该类中所涉及到常量池，共35个常量。 第三部分：显示该类的构造器，编译器自动插入的。 第四部分：显示了main方的信息。（这个是需要我们重点关注的） 2.2、常量池官网文档： https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4-140 Constant Type Value 说明 CONSTANT_Class 7 类或接口的符号引用 CONSTANT_Fieldref 9 字段的符号引用 CONSTANT_Methodref 10 类中方法的符号引用 CONSTANT_InterfaceMethodref 11 接口中方法的符号引用 CONSTANT_String 8 字符串类型常量 CONSTANT_Integer 3 整形常量 CONSTANT_Float 4 浮点型常量 CONSTANT_Long 5 长整型常量 CONSTANT_Double 6 双精度浮点型常量 CONSTANT_NameAndType 12 字段或方法的符号引用 CONSTANT_Utf8 1 UTF-8编码的字符串 CONSTANT_MethodHandle 15 表示方法句柄 CONSTANT_MethodType 16 标志方法类型 CONSTANT_InvokeDynamic 18 表示一个动态方法调用点 2.3、描述符2.3.1、字段描述符官网：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2 FieldType term Type Interpretation B byte signed byte C char Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16 D double double-precision floating-point value F float single-precision floating-point value I int integer J long long integer LClassName; reference an instance of class ClassName S short signed short Z boolean true or false [ reference one array dimension 2.3.2、方法描述符官网：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3 示例： The method descriptor for the method: 1Object m(int i, double d, Thread t) &#123;...&#125; is: 1(IDLjava/lang/Thread;)Ljava/lang/Object; 2.4、解读方法字节码12345678910111213141516171819202122232425262728293031323334 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V //方法描述，V表示该方法的放回值为void flags: ACC_PUBLIC, ACC_STATIC // 方法修饰符，public、static的 Code: // stack=2,操作栈的大小为2、locals=4，本地变量表大小，args_size=1, 参数的个数 stack=2, locals=4, args_size=1 0: iconst_2 //将数字2值压入操作栈，位于栈的最上面 1: istore_1 //从操作栈中弹出一个元素(数字2)，放入到本地变量表中，位于下标为1的位置（下标为0的是this） 2: iconst_5 //将数字5值压入操作栈，位于栈的最上面 3: istore_2 //从操作栈中弹出一个元素(5)，放入到本地变量表中，位于第下标为2个位置 4: iload_2 //将本地变量表中下标为2的位置元素压入操作栈（5） 5: iload_1 //将本地变量表中下标为1的位置元素压入操作栈（2） 6: isub //操作栈中的2个数字相减 7: istore_3 // 将相减的结果压入到本地本地变量表中，位于下标为3的位置 // 通过#2号找到对应的常量，即可找到对应的引用 8: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 11: iload_3 //将本地变量表中下标为3的位置元素压入操作栈（3） // 通过#3号找到对应的常量，即可找到对应的引用，进行方法调用 12: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 15: return //返回 LineNumberTable: //行号的列表 line 6: 0 line 7: 2 line 8: 4 line 9: 8 line 10: 15 LocalVariableTable: // 本地变量表 Start Length Slot Name Signature 0 16 0 args [Ljava/lang/String; 2 14 1 a I 4 12 2 b I 8 8 3 c I&#125;SourceFile: "Test1.java" 2.4.1、图解 2.5、研究 i++ 与 ++i 的不同我们都知道，i++表示，先返回再+1，++i表示，先+1再返回。它的底层是怎么样的呢? 我们一起探究下。 编写测试代码： 1234567891011121314151617181920public class Test2 &#123; public static void main(String[] args) &#123; new Test2().method1(); new Test2().method2(); &#125; public void method1()&#123; int i = 1; int a = i++; System.out.println(a); //打印1 &#125; public void method2()&#123; int i = 1; int a = ++i; System.out.println(a);//打印2 &#125;&#125; 2.5.1、查看class字节码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137Classfile /F:/code/bestqiang-jvm/bestqiang-jvm-test/target/classes/cn/bestqiang/jvm/Test2.class MD5 checksum 901660fc11c43b6daadd0942150960ed Compiled from "Test2.java"public class cn.bestqiang.jvm.Test2 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #8.#27 // java/lang/Object."&lt;init&gt;":()V #2 = Class #28 // cn/bestqiang/jvm/Test2 #3 = Methodref #2.#27 // cn/bestqiang/jvm/Test2."&lt;init&gt;":()V #4 = Methodref #2.#29 // cn/bestqiang/jvm/Test2.method1:()V #5 = Methodref #2.#30 // cn/bestqiang/jvm/Test2.method2:()V #6 = Fieldref #31.#32 // java/lang/System.out:Ljava/io/PrintStream; #7 = Methodref #33.#34 // java/io/PrintStream.println:(I)V #8 = Class #35 // java/lang/Object #9 = Utf8 &lt;init&gt; #10 = Utf8 ()V #11 = Utf8 Code #12 = Utf8 LineNumberTable #13 = Utf8 LocalVariableTable #14 = Utf8 this #15 = Utf8 Lcn/bestqiang/jvm/Test2; #16 = Utf8 main #17 = Utf8 ([Ljava/lang/String;)V #18 = Utf8 args #19 = Utf8 [Ljava/lang/String; #20 = Utf8 method1 #21 = Utf8 i #22 = Utf8 I #23 = Utf8 a #24 = Utf8 method2 #25 = Utf8 SourceFile #26 = Utf8 Test2.java #27 = NameAndType #9:#10 // "&lt;init&gt;":()V #28 = Utf8 cn/bestqiang/jvm/Test2 #29 = NameAndType #20:#10 // method1:()V #30 = NameAndType #24:#10 // method2:()V #31 = Class #36 // java/lang/System #32 = NameAndType #37:#38 // out:Ljava/io/PrintStream; #33 = Class #39 // java/io/PrintStream #34 = NameAndType #40:#41 // println:(I)V #35 = Utf8 java/lang/Object #36 = Utf8 java/lang/System #37 = Utf8 out #38 = Utf8 Ljava/io/PrintStream; #39 = Utf8 java/io/PrintStream #40 = Utf8 println #41 = Utf8 (I)V&#123; public cn.bestqiang.jvm.Test2(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcn/bestqiang/jvm/Test2; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: new #2 // class cn/bestqiang/jvm/Test2 3: dup 4: invokespecial #3 // Method "&lt;init&gt;":()V 7: invokevirtual #4 // Method method1:()V 10: new #2 // class cn/bestqiang/jvm/Test2 13: dup 14: invokespecial #3 // Method "&lt;init&gt;":()V 17: invokevirtual #5 // Method method2:()V 20: return LineNumberTable: line 6: 0 line 7: 10 line 8: 20 LocalVariableTable: Start Length Slot Name Signature 0 21 0 args [Ljava/lang/String; public void method1(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: iconst_1 1: istore_1 2: iload_1 3: iinc 1, 1 6: istore_2 7: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 10: iload_2 11: invokevirtual #7 // Method java/io/PrintStream.println:(I)V 14: return LineNumberTable: line 11: 0 line 12: 2 line 13: 7 line 14: 14 LocalVariableTable: Start Length Slot Name Signature 0 15 0 this Lcn/bestqiang/jvm/Test2; 2 13 1 i I 7 8 2 a I public void method2(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: iconst_1 1: istore_1 2: iinc 1, 1 5: iload_1 6: istore_2 7: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 10: iload_2 11: invokevirtual #7 // Method java/io/PrintStream.println:(I)V 14: return LineNumberTable: line 17: 0 line 18: 2 line 19: 7 line 20: 14 LocalVariableTable: Start Length Slot Name Signature 0 15 0 this Lcn/bestqiang/jvm/Test2; 2 13 1 i I 7 8 2 a I&#125;SourceFile: "Test2.java" 2.5.2、对比i++： 123456789 0: iconst_1 //将数字1压入到操作栈 1: istore_1 //将数字1从操作栈弹出，压入到本地变量表中，下标为1 2: iload_1 //从本地变量表中获取下标为1的数据，压入到操作栈中 3: iinc 1, 1 // 将本地变量中的1，再+1 6: istore_2 // 将数字1从操作栈弹出，压入到本地变量表中，下标为2 7: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream;10: iload_2 //从本地变量表中获取下标为2的数据，压入到操作栈中11: invokevirtual #7 // Method java/io/PrintStream.println:(I)V14: return ++i： 123456789 0: iconst_1 //将数字1压入到操作栈 1: istore_1 //将数字1从操作栈弹出，压入到本地变量表中，下标为1 2: iinc 1, 1// 将本地变量中的1，再+1 5: iload_1 //从本地变量表中获取下标为1的数据（2），压入到操作栈中 6: istore_2 //将数字2从操作栈弹出，压入到本地变量表中，下标为2 7: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream;10: iload_2 //从本地变量表中获取下标为2的数据（2），压入到操作栈中11: invokevirtual #7 // Method java/io/PrintStream.println:(I)V14: return 区别： i++ 只是在本地变量中对数字做了相加，并没有将数据压入到操作栈 将前面拿到的数字1，再次从操作栈中拿到，压入到本地变量中 ++i 将本地变量中的数字做了相加，并且将数据压入到操作栈 将操作栈中的数据，再次压入到本地变量中 小结：可以通过查看字节码的方式对代码的底层做研究，探究其原理。 2.6、字符串拼接字符串的拼接在开发过程中使用是非常频繁的，常用的方式有三种： +号拼接： str+”456” StringBuilder拼接 StringBuffer拼接 StringBuffer是保证线程安全的，效率是比较低的，我们更多的是使用场景是不会涉及到线程安全的问题的，所以更多的时候会选择StringBuilder，效率会高一些。 那么，问题来了，StringBuilder和“+”号拼接，哪个效率高呢？接下来我们通过字节码的方式进行探究。 首先，编写个示例： 1234567891011121314151617181920212223242526package cn.bestqiang.jvm;public class Test3 &#123; public static void main(String[] args) &#123; new Test3().m1(); new Test3().m2(); &#125; public void m1()&#123; String s1 = "123"; String s2 = "456"; String s3 = s1 + s2; System.out.println(s3); &#125; public void m2()&#123; String s1 = "123"; String s2 = "456"; StringBuilder sb = new StringBuilder(); sb.append(s1); sb.append(s2); String s3 = sb.toString(); System.out.println(s3); &#125;&#125; 查看Test3.class的字节码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185Classfile /F:/code/bestqiang-jvm/bestqiang-jvm-test/target/classes/cn/bestqiang/jvm/Test3.class MD5 checksum b3f7629e7e37768b9b5581be01df40d6 Compiled from "Test3.java"public class cn.bestqiang.jvm.Test3 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #14.#36 // java/lang/Object."&lt;init&gt;":()V #2 = Class #37 // cn/bestqiang/jvm/Test3 #3 = Methodref #2.#36 // cn/bestqiang/jvm/Test3."&lt;init&gt;":()V #4 = Methodref #2.#38 // cn/bestqiang/jvm/Test3.m1:()V #5 = Methodref #2.#39 // cn/bestqiang/jvm/Test3.m2:()V #6 = String #40 // 123 #7 = String #41 // 456 #8 = Class #42 // java/lang/StringBuilder #9 = Methodref #8.#36 // java/lang/StringBuilder."&lt;init&gt;":()V #10 = Methodref #8.#43 // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #11 = Methodref #8.#44 // java/lang/StringBuilder.toString:()Ljava/lang/String; #12 = Fieldref #45.#46 // java/lang/System.out:Ljava/io/PrintStream; #13 = Methodref #47.#48 // java/io/PrintStream.println:(Ljava/lang/String;)V #14 = Class #49 // java/lang/Object #15 = Utf8 &lt;init&gt; #16 = Utf8 ()V #17 = Utf8 Code #18 = Utf8 LineNumberTable #19 = Utf8 LocalVariableTable #20 = Utf8 this #21 = Utf8 Lcn/bestqiang/jvm/Test3; #22 = Utf8 main #23 = Utf8 ([Ljava/lang/String;)V #24 = Utf8 args #25 = Utf8 [Ljava/lang/String; #26 = Utf8 m1 #27 = Utf8 s1 #28 = Utf8 Ljava/lang/String; #29 = Utf8 s2 #30 = Utf8 s3 #31 = Utf8 m2 #32 = Utf8 sb #33 = Utf8 Ljava/lang/StringBuilder; #34 = Utf8 SourceFile #35 = Utf8 Test3.java #36 = NameAndType #15:#16 // "&lt;init&gt;":()V #37 = Utf8 cn/bestqiang/jvm/Test3 #38 = NameAndType #26:#16 // m1:()V #39 = NameAndType #31:#16 // m2:()V #40 = Utf8 123 #41 = Utf8 456 #42 = Utf8 java/lang/StringBuilder #43 = NameAndType #50:#51 // append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #44 = NameAndType #52:#53 // toString:()Ljava/lang/String; #45 = Class #54 // java/lang/System #46 = NameAndType #55:#56 // out:Ljava/io/PrintStream; #47 = Class #57 // java/io/PrintStream #48 = NameAndType #58:#59 // println:(Ljava/lang/String;)V #49 = Utf8 java/lang/Object #50 = Utf8 append #51 = Utf8 (Ljava/lang/String;)Ljava/lang/StringBuilder; #52 = Utf8 toString #53 = Utf8 ()Ljava/lang/String; #54 = Utf8 java/lang/System #55 = Utf8 out #56 = Utf8 Ljava/io/PrintStream; #57 = Utf8 java/io/PrintStream #58 = Utf8 println #59 = Utf8 (Ljava/lang/String;)V&#123; public cn.bestqiang.jvm.Test3(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcn/bestqiang/jvm/Test3; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: new #2 // class cn/bestqiang/jvm/Test3 3: dup 4: invokespecial #3 // Method "&lt;init&gt;":()V 7: invokevirtual #4 // Method m1:()V 10: new #2 // class cn/bestqiang/jvm/Test3 13: dup 14: invokespecial #3 // Method "&lt;init&gt;":()V 17: invokevirtual #5 // Method m2:()V 20: return LineNumberTable: line 6: 0 line 7: 10 line 8: 20 LocalVariableTable: Start Length Slot Name Signature 0 21 0 args [Ljava/lang/String; public void m1(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=4, args_size=1 0: ldc #6 // String 123 2: astore_1 3: ldc #7 // String 456 5: astore_2 6: new #8 // class java/lang/StringBuilder 9: dup 10: invokespecial #9 // Method java/lang/StringBuilder."&lt;init&gt;":()V 13: aload_1 14: invokevirtual #10 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 17: aload_2 18: invokevirtual #10 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 21: invokevirtual #11 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 24: astore_3 25: getstatic #12 // Field java/lang/System.out:Ljava/io/PrintStream; 28: aload_3 29: invokevirtual #13 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 32: return LineNumberTable: line 11: 0 line 12: 3 line 13: 6 line 14: 25 line 15: 32 LocalVariableTable: Start Length Slot Name Signature 0 33 0 this Lcn/bestqiang/jvm/Test3; 3 30 1 s1 Ljava/lang/String; 6 27 2 s2 Ljava/lang/String; 25 8 3 s3 Ljava/lang/String; public void m2(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=5, args_size=1 0: ldc #6 // String 123 2: astore_1 3: ldc #7 // String 456 5: astore_2 6: new #8 // class java/lang/StringBuilder 9: dup 10: invokespecial #9 // Method java/lang/StringBuilder."&lt;init&gt;":()V 13: astore_3 14: aload_3 15: aload_1 16: invokevirtual #10 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: pop 20: aload_3 21: aload_2 22: invokevirtual #10 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 25: pop 26: aload_3 27: invokevirtual #11 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 30: astore 4 32: getstatic #12 // Field java/lang/System.out:Ljava/io/PrintStream; 35: aload 4 37: invokevirtual #13 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 40: return LineNumberTable: line 18: 0 line 19: 3 line 20: 6 line 21: 14 line 22: 20 line 23: 26 line 24: 32 line 25: 40 LocalVariableTable: Start Length Slot Name Signature 0 41 0 this Lcn/bestqiang/jvm/Test3; 3 38 1 s1 Ljava/lang/String; 6 35 2 s2 Ljava/lang/String; 14 27 3 sb Ljava/lang/StringBuilder; 32 9 4 s3 Ljava/lang/String;&#125;SourceFile: "Test3.java" 从解字节码中可以看出，m1()方法源码中是使用+号拼接，但是在字节码中也被编译成了StringBuilder方式。 所以，可以得出结论，字符串拼接，+号和StringBuilder是相等的，效率一样。 接下来，我们再看一个案例： 12345678910111213141516171819202122232425package cn.bestqiang.jvm;public class Test4 &#123; public static void main(String[] args) &#123; new Test4().m1(); new Test4().m2(); &#125; public void m1()&#123; String str = ""; for (int i = 0; i &lt; 5; i++) &#123; str = str + i; &#125; System.out.println(str); &#125; public void m2()&#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; 5; i++) &#123; sb.append(i); &#125; System.out.println(sb.toString()); &#125;&#125; m1() 与 m2() 哪个方法的效率高？ 依然是通过字节码的方式进行探究。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200Classfile /F:/code/bestqiang-jvm/bestqiang-jvm-test/target/classes/cn/bestqiang/jvm/Test4.class MD5 checksum f87a55446b8b6cd88b6e54bd5edcc9dc Compiled from "Test4.java"public class cn.bestqiang.jvm.Test4 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #14.#39 // java/lang/Object."&lt;init&gt;":()V #2 = Class #40 // cn/bestqiang/jvm/Test4 #3 = Methodref #2.#39 // cn/bestqiang/jvm/Test4."&lt;init&gt;":()V #4 = Methodref #2.#41 // cn/bestqiang/jvm/Test4.m1:()V #5 = Methodref #2.#42 // cn/bestqiang/jvm/Test4.m2:()V #6 = String #43 // #7 = Class #44 // java/lang/StringBuilder #8 = Methodref #7.#39 // java/lang/StringBuilder."&lt;init&gt;":()V #9 = Methodref #7.#45 // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #10 = Methodref #7.#46 // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder; #11 = Methodref #7.#47 // java/lang/StringBuilder.toString:()Ljava/lang/String; #12 = Fieldref #48.#49 // java/lang/System.out:Ljava/io/PrintStream; #13 = Methodref #50.#51 // java/io/PrintStream.println:(Ljava/lang/String;)V #14 = Class #52 // java/lang/Object #15 = Utf8 &lt;init&gt; #16 = Utf8 ()V #17 = Utf8 Code #18 = Utf8 LineNumberTable #19 = Utf8 LocalVariableTable #20 = Utf8 this #21 = Utf8 Lcn/bestqiang/jvm/Test4; #22 = Utf8 main #23 = Utf8 ([Ljava/lang/String;)V #24 = Utf8 args #25 = Utf8 [Ljava/lang/String; #26 = Utf8 m1 #27 = Utf8 i #28 = Utf8 I #29 = Utf8 str #30 = Utf8 Ljava/lang/String; #31 = Utf8 StackMapTable #32 = Class #53 // java/lang/String #33 = Utf8 m2 #34 = Utf8 sb #35 = Utf8 Ljava/lang/StringBuilder; #36 = Class #44 // java/lang/StringBuilder #37 = Utf8 SourceFile #38 = Utf8 Test4.java #39 = NameAndType #15:#16 // "&lt;init&gt;":()V #40 = Utf8 cn/bestqiang/jvm/Test4 #41 = NameAndType #26:#16 // m1:()V #42 = NameAndType #33:#16 // m2:()V #43 = Utf8 #44 = Utf8 java/lang/StringBuilder #45 = NameAndType #54:#55 // append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #46 = NameAndType #54:#56 // append:(I)Ljava/lang/StringBuilder; #47 = NameAndType #57:#58 // toString:()Ljava/lang/String; #48 = Class #59 // java/lang/System #49 = NameAndType #60:#61 // out:Ljava/io/PrintStream; #50 = Class #62 // java/io/PrintStream #51 = NameAndType #63:#64 // println:(Ljava/lang/String;)V #52 = Utf8 java/lang/Object #53 = Utf8 java/lang/String #54 = Utf8 append #55 = Utf8 (Ljava/lang/String;)Ljava/lang/StringBuilder; #56 = Utf8 (I)Ljava/lang/StringBuilder; #57 = Utf8 toString #58 = Utf8 ()Ljava/lang/String; #59 = Utf8 java/lang/System #60 = Utf8 out #61 = Utf8 Ljava/io/PrintStream; #62 = Utf8 java/io/PrintStream #63 = Utf8 println #64 = Utf8 (Ljava/lang/String;)V&#123; public cn.bestqiang.jvm.Test4(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcn/bestqiang/jvm/Test4; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: new #2 // class cn/bestqiang/jvm/Test4 3: dup 4: invokespecial #3 // Method "&lt;init&gt;":()V 7: invokevirtual #4 // Method m1:()V 10: new #2 // class cn/bestqiang/jvm/Test4 13: dup 14: invokespecial #3 // Method "&lt;init&gt;":()V 17: invokevirtual #5 // Method m2:()V 20: return LineNumberTable: line 6: 0 line 7: 10 line 8: 20 LocalVariableTable: Start Length Slot Name Signature 0 21 0 args [Ljava/lang/String; public void m1(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: ldc #6 // String 2: astore_1 // 将空字符串压入到本地变量表中的下标为1的位置 3: iconst_0 // 将数字0压入操作栈顶 4: istore_2 // 将栈顶数字0压入到本地变量表中的下标为2的位置 5: iload_2 // 将本地变量中下标为2的数字0压入操作栈顶 6: iconst_5 // 将数字5压入操作栈顶 7: if_icmpge 35 //比较栈顶两int型数值大小，当结果大于等于0时跳转到35 10: new #7 // class java/lang/StringBuilder 13: dup //复制栈顶数值并将复制值压入栈顶(数字5) 14: invokespecial #8 // Method java/lang/StringBuilder."&lt;init&gt;":()V 17: aload_1 18: invokevirtual #9 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 21: iload_2 //将本地变量中下标为2的数字0压入操作栈顶 22: invokevirtual #10 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder; 25: invokevirtual #11 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 28: astore_1 29: iinc 2, 1 32: goto 5 35: getstatic #12 // Field java/lang/System.out:Ljava/io/PrintStream; 38: aload_1 39: invokevirtual #13 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 42: return LineNumberTable: line 11: 0 line 12: 3 line 13: 10 line 12: 29 line 15: 35 line 16: 42 LocalVariableTable: Start Length Slot Name Signature 5 30 2 i I 0 43 0 this Lcn/bestqiang/jvm/Test4; 3 40 1 str Ljava/lang/String; StackMapTable: number_of_entries = 2 frame_type = 253 /* append */ offset_delta = 5 locals = [ class java/lang/String, int ] frame_type = 250 /* chop */ offset_delta = 29 public void m2(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: new #7 // class java/lang/StringBuilder 3: dup 4: invokespecial #8 // Method java/lang/StringBuilder."&lt;init&gt;":()V 7: astore_1 8: iconst_0 9: istore_2 10: iload_2 11: iconst_5 12: if_icmpge 27 15: aload_1 16: iload_2 17: invokevirtual #10 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder; 20: pop 21: iinc 2, 1 24: goto 10 27: getstatic #12 // Field java/lang/System.out:Ljava/io/PrintStream; 30: aload_1 31: invokevirtual #11 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 34: invokevirtual #13 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 37: return LineNumberTable: line 19: 0 line 20: 8 line 21: 15 line 20: 21 line 23: 27 line 24: 37 LocalVariableTable: Start Length Slot Name Signature 10 17 2 i I 0 38 0 this Lcn/bestqiang/jvm/Test4; 8 30 1 sb Ljava/lang/StringBuilder; StackMapTable: number_of_entries = 2 frame_type = 253 /* append */ offset_delta = 10 locals = [ class java/lang/StringBuilder, int ] frame_type = 250 /* chop */ offset_delta = 16&#125;SourceFile: "Test4.java" 可以看到，m1()方法中的循环体内，每一次循环都会创建StringBuilder对象，效率低于m2()方法。 2.7、小结使用字节码的方式可以很好查看代码底层的执行，从而可以看出哪些实现效率高，哪些实现效率低。可以更好的对我们的代码做优化。让程序执行效率更高。 3、代码优化优化，不仅仅是在运行环境进行优化，还需要在代码本身做优化，如果代码本身存在性能问题，那么在其他方面再怎么优化也不可能达到效果最优的。 3.1、尽可能使用局部变量调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。 3.2、尽量减少对变量的重复计算明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的。所以例如下面的操作： 12for (int i = 0; i &lt; list.size(); i++)&#123;...&#125; 建议替换为： 1234int length = list.size();for (int i = 0, i &lt; length; i++)&#123;...&#125; 这样，在list.size()很大的时候，就减少了很多的消耗。 3.3、尽量采用懒加载的策略，即在需要的时候才创建1234567891011String str = "aaa";if (i == 1)&#123; list.add(str);&#125;//建议替换成if (i == 1)&#123; String str = "aaa"; list.add(str);&#125; 3.4、异常不应该用来控制程序流程异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方 法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建 了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。 3.5、不要将数组声明为public static final因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变。 3.6、不要创建一些不使用的对象，不要导入一些不使用的类这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容 3.7、程序运行过程中避免使用反射反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是 Method的invoke方法。 如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存。 3.8、使用数据库连接池和线程池这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程。 3.9、容器初始化时尽可能指定长度容器初始化时尽可能指定长度，如：new ArrayList&lt;&gt;(10); new HashMap&lt;&gt;(32); 避免容器长度不足时，扩容带来的性能损耗。 3.10、ArrayList随机遍历快，LinkedList添加删除快3.11、使用Entry遍历Map12345Map&lt;String,String&gt; map = new HashMap&lt;&gt;();for (Map.Entry&lt;String,String&gt; entry : map.entrySet()) &#123; String key = entry.getKey(); String value = entry.getValue();&#125; 避免使用这种方式： 1234Map&lt;String,String&gt; map = new HashMap&lt;&gt;();for (String key : map.keySet()) &#123; String value = map.get(key);&#125; 3.12、不要手动调用System.gc();3.13、String尽量少用正则表达式正则表达式虽然功能强大，但是其效率较低，除非是有需要，否则尽可能少用。 replace() 不支持正则replaceAll() 支持正则 如果仅仅是字符的替换建议使用replace()。 3.14、日志的输出要注意级别12// 当前的日志级别是errorLOGGER.info("保存出错！" + user); 3.15、对资源的close()建议分开操作1234567891011121314151617181920212223try&#123; XXX.close(); YYY.close();&#125;catch (Exception e)&#123; ...&#125;// 建议改为try&#123; XXX.close();&#125;catch (Exception e)&#123; ...&#125;try&#123; YYY.close();&#125;catch (Exception e)&#123; ...&#125;]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GC之垃圾回收算法和垃圾处理器]]></title>
    <url>%2F2019%2F05%2F30%2FGC%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%92%8C%E5%9E%83%E5%9C%BE%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[GC之常见的垃圾回收算法和垃圾处理器 了解什么是垃圾回收 掌握垃圾会回收的常见算法 学习串行、并行、并发、G1垃圾收集器 学习GC日志的可视化查看 1、什么是垃圾回收？程序的运行必然需要申请内存资源，无效的对象资源如果不及时处理就会一直占有内存资源，最终将导致内存溢出，所以对内存资源的管理是非常重要了。 1.1、C/C++语言的垃圾回收在C/C++语言中，没有自动垃圾回收机制，是通过new关键字申请内存资源，通过delete关键字释放内存资源。 如果，程序员在某些位置没有写delete进行释放，那么申请的对象将一直占用内存资源，最终可能会导致内存溢出。 1.2、Java语言的垃圾回收为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC。 有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。 换句话说，自动的垃圾回收的算法就会变得非常重要了，如果因为算法的不合理，导致内存资源一直没有释放，同样也可能会导致内存溢出的。 当然，除了Java语言，C#、Python等语言也都有自动的垃圾回收机制。 2、垃圾回收的常见算法自动化的管理内存资源，垃圾回收机制必须要有一套算法来进行计算，哪些是有效的对象，哪些是无效的对象，对于无效的对象就要进行回收处理。 常见的垃圾回收算法有：引用计数法、标记清除法、标记压缩法、复制算法、分代算法等。 2.1、引用计数法引用计数是历史最悠久的一种算法，最早George E. Collins在1960的时候首次提出，50年后的今天，该算法依然被很多编程语言使用。 2.1.1、原理假设有一个对象A，任何一个对象对A的引用，那么对象A的引用计数器+1，当引用失败时，对象A的引用计数器就-1，如果对象A的计数器的值为0，就说明对象A没有引用了，可以被回收。 2.1.2、优缺点优点： 实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。 在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报outofmember 错误。 区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。 缺点： 每次对象被引用时，都需要去更新计数器，有一点时间开销。 浪费CPU资源，即使内存够用，仍然在运行时进行计数器的统计。 无法解决循环引用问题。（最大的缺点） 什么是循环引用？ 1234567891011121314151617class TestA&#123; public TestB b;&#125;class TestB&#123; public TestA a;&#125;public class Main&#123; public static void main(String[] args)&#123; A a = new A(); B b = new B(); a.b=b; b.a=a; a = null; b = null; &#125;&#125; 虽然a和b都为null，但是由于a和b存在循环引用，这样a和b永远都不会被回收。 2.2、标记清除法标记清除算法，是将垃圾回收分为2个阶段，分别是标记和清除。 标记：从根节点开始标记引用的对象。 清除：未被标记引用的对象就是垃圾对象，可以被清理。 2.2.1、原理 这张图代表的是程序运行期间所有对象的状态，它们的标志位全部是0（也就是未标记，以下默认0就是未标记，1为已标记），假设这会儿有效内存空间耗尽了，JVM将会停止应用程序的运行并开启GC线程，然后开始进行标记工作，按照根搜索算法，标记完以后，对象的状态如下图。 可以看到，按照根搜索算法，所有从root对象可达的对象就被标记为了存活的对象，此时已经完成了第一阶段标记。接下来，就要执行第二阶段清除了，那么清除完以后，剩下的对象以及对象的状态如下图所示。 可以看到，没有被标记的对象将会回收清除掉，而被标记的对象将会留下，并且会将标记位重新归0。接下来就不用说了，唤醒停止的程序线程，让程序继续运行即可。 2.2.2、优缺点可以看到，标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收。 同样，标记清除算法也是有缺点的： 效率较低，标记和清除两个动作都需要遍历所有的对象，并且在GC时，需要停止应用程序，对于交互性要求比较高的应用而言这个体验是非常差的。 通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。 2.3、标记压缩算法标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的清理未标记的对象，而是将存活的对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决了碎片化的问题。 2.3.1、原理 2.3.2、优缺点优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有有一定的影响。 2.4、复制算法复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。 如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之，则不适合。 2.4.1、JVM中年轻代内存空间 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。 紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。 经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。 GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 2.4.2、优缺点优点： 在垃圾对象多的情况下，效率较高 清理后，内存无碎片 缺点： 在垃圾对象少的情况下，不适用，如：老年代内存 分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低 2.5、分代算法前面介绍了多种回收算法，每一种算法都有自己的优点也有缺点，谁都不能替代谁，所以根据垃圾回收对象的特点进行选择，才是明智的选择。 分代算法其实就是这样的，根据回收对象的特点进行选择，在jvm中，年轻代适合使用复制算法，老年代适合使用标记清除或标记压缩算法。 接下来就是垃圾回收器了！ 3、垃圾收集器以及内存分配前面我们讲了垃圾回收的算法，还需要有具体的实现，在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器、CMS（并发）垃圾收集器、G1垃圾收集器，接下来，我们一个个的了解学习。 3.1、串行垃圾收集器串行垃圾收集器，是指使用单线程进行垃圾回收，垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停，等待垃圾回收的完成。这种现象称之为STW（Stop-The-World）。 对于交互性较强的应用而言，这种垃圾收集器是不能够接受的。 一般在Javaweb应用中是不会采用该收集器的。 3.1.1、编写测试代码1234567891011121314151617181920212223242526272829package com.bestqiang.jvm;import java.util.ArrayList;import java.util.List;import java.util.Properties;import java.util.Random;public class TestGC &#123; public static void main(String[] args) throws Exception &#123; List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); while (true)&#123; int sleep = new Random().nextInt(100); if(System.currentTimeMillis() % 2 ==0)&#123; list.clear(); &#125;else&#123; for (int i = 0; i &lt; 10000; i++) &#123; Properties properties = new Properties(); properties.put("key_"+i, "value_" + System.currentTimeMillis() + i); list.add(properties); &#125; &#125; // System.out.println("list大小为：" + list.size()); Thread.sleep(sleep); &#125; &#125;&#125; 3.1.2、设置垃圾回收为串行收集器在程序运行参数中添加2个参数，如下： -XX:+UseSerialGC 指定年轻代和老年代都使用串行垃圾收集器 -XX:+PrintGCDetails 打印垃圾回收的详细信息 12# 为了测试GC，将堆的初始和最大内存都设置为16M-XX:+UseSerialGC -XX:+PrintGCDetails -Xms16m -Xmx16m 启动程序，可以看到下面信息： 123[GC (Allocation Failure) [DefNew: 4416K-&gt;512K(4928K), 0.0046102 secs] 4416K-&gt;1973K(15872K), 0.0046533 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [Tenured: 10944K-&gt;3107K(10944K), 0.0085637 secs] 15871K-&gt;3107K(15872K), [Metaspace: 3496K-&gt;3496K(1056768K)], 0.0085974 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] GC日志信息解读： 年轻代的内存GC前后的大小： DefNew 表示使用的是串行垃圾收集器。 4416K-&gt;512K(4928K) 表示，年轻代GC前，占有4416K内存，GC后，占有512K内存，总大小4928K 0.0046102 secs 表示，GC所用的时间，单位为毫秒。 4416K-&gt;1973K(15872K) 表示，GC前，堆内存占有4416K，GC后，占有1973K，总大小为15872K Full GC 表示，内存空间全部进行GC 3.2、并行垃圾收集器并行垃圾收集器在串行垃圾收集器的基础之上做了改进，将单线程改为了多线程进行垃圾回收，这样可以缩短垃圾回收的时间。（这里是指，并行能力较强的机器） 当然了，并行垃圾收集器在收集的过程中也会暂停应用程序，这个和串行垃圾回收器是一样的，只是并行执行，速度更快些，暂停的时间更短一些。 3.2.1、ParNew垃圾收集器ParNew垃圾收集器是工作在年轻代上的，只是将串行的垃圾收集器改为了并行。 通过-XX:+UseParNewGC参数设置年轻代使用ParNew回收器，老年代使用的依然是串行收集器。 测试： 12345#参数-XX:+UseParNewGC -XX:+PrintGCDetails -Xms16m -Xmx16m#打印出的信息[GC (Allocation Failure) [ParNew: 4416K-&gt;512K(4928K), 0.0032106 secs] 4416K-&gt;1988K(15872K), 0.0032697 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 由以上信息可以看出，ParNew: 使用的是ParNew收集器。其他信息和串行收集器一致。 3.2.2、ParallelGC垃圾收集器ParallelGC收集器工作机制和ParNewGC收集器一样，只是在此基础之上，新增了两个和系统吞吐量相关的参数，使得其使用起来更加的灵活和高效。 相关参数如下： -XX:+UseParallelGC 年轻代使用ParallelGC垃圾回收器，老年代使用串行回收器。 -XX:+UseParallelOldGC 年轻代使用ParallelGC垃圾回收器，老年代使用ParallelOldGC垃圾回收器。 -XX:MaxGCPauseMillis 设置最大的垃圾收集时的停顿时间，单位为毫秒 需要注意的时，ParallelGC为了达到设置的停顿时间，可能会调整堆大小或其他的参数，如果堆的大小设置的较小，就会导致GC工作变得很频繁，反而可能会影响到性能。 该参数使用需谨慎。 -XX:GCTimeRatio 设置垃圾回收时间占程序运行时间的百分比，公式为1/(1+n)。 它的值为0~100之间的数字，默认值为99，也就是垃圾回收时间不能超过1% -XX:UseAdaptiveSizePolicy 自适应GC模式，垃圾回收器将自动调整年轻代、老年代等参数，达到吞吐量、堆大小、停顿时间之间的平衡。 一般用于，手动调整参数比较困难的场景，让收集器自动进行调整。 测试： 1234567#参数-XX:+UseParallelGC -XX:+UseParallelOldGC -XX:MaxGCPauseMillis=100 -XX:+PrintGCDetails -Xms16m -Xmx16m#打印的信息[GC (Allocation Failure) [PSYoungGen: 4096K-&gt;480K(4608K)] 4096K-&gt;1840K(15872K), 0.0034307 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 505K-&gt;0K(4608K)] [ParOldGen: 10332K-&gt;10751K(11264K)] 10837K-&gt;10751K(15872K), [Metaspace: 3491K-&gt;3491K(1056768K)], 0.0793622 secs] [Times: user=0.13 sys=0.00, real=0.08 secs] 有以上信息可以看出，年轻代和老年代都使用了ParallelGC垃圾回收器。 3.3、CMS垃圾收集器CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，通过参数-XX:+UseConcMarkSweepGC进行设置。 CMS垃圾回收器的执行过程如下： 初始化标记(CMS-initial-mark) ,标记root，会导致stw； 并发标记(CMS-concurrent-mark)，与用户线程同时运行； 预清理（CMS-concurrent-preclean），与用户线程同时运行； 重新标记(CMS-remark) ，会导致stw； 并发清除(CMS-concurrent-sweep)，与用户线程同时运行； 调整堆大小，设置CMS在清理之后进行内存压缩，目的是清理内存中的碎片； 并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行； 3.3.1、测试12345678910111213141516171819202122#设置启动参数-XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -Xms16m -Xmx16m#运行日志[GC (Allocation Failure) [ParNew: 4926K-&gt;512K(4928K), 0.0041843 secs] 9424K-&gt;6736K(15872K), 0.0042168 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] #第一步，初始标记[GC (CMS Initial Mark) [1 CMS-initial-mark: 6224K(10944K)] 6824K(15872K), 0.0004209 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] #第二步，并发标记[CMS-concurrent-mark-start][CMS-concurrent-mark: 0.002/0.002 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] #第三步，预处理[CMS-concurrent-preclean-start][CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] #第四步，重新标记[GC (CMS Final Remark) [YG occupancy: 1657 K (4928 K)][Rescan (parallel) , 0.0005811 secs][weak refs processing, 0.0000136 secs][class unloading, 0.0003671 secs][scrub symbol table, 0.0006813 secs][scrub string table, 0.0001216 secs][1 CMS-remark: 6224K(10944K)] 7881K(15872K), 0.0018324 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] #第五步，并发清理[CMS-concurrent-sweep-start][CMS-concurrent-sweep: 0.004/0.004 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] #第六步，重置[CMS-concurrent-reset-start][CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 由以上日志信息，可以看出CMS执行的过程。 3.4、G1垃圾收集器（重点）G1垃圾收集器是在jdk1.7中正式使用的全新的垃圾收集器，oracle官方计划在jdk9中将G1变成默认的垃圾收集器，以替代CMS。 G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优： 第一步，开启G1垃圾收集器 第二步，设置堆的最大内存 第三步，设置最大的停顿时间 G1中提供了三种模式垃圾回收模式，Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。 3.4.1、原理G1垃圾收集器相对比其他收集器而言，最大的区别在于它取消了年轻代、老年代的物理划分，取而代之的是将堆划分为若干个区域（Region），这些区域中包含了有逻辑上的年轻代、老年代区域。 这样做的好处就是，我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。 在G1划分的区域中，年轻代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。 这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。 在G1中，有一种特殊的区域，叫Humongous区域。 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。 这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。 为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。 3.4.2、Young GCYoung GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。 Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。 Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。 最终Eden空间的数据为空，GC停止工作，应用线程继续执行。 3.4.2.1、Remembered Set（已记忆集合）在GC年轻代的对象时，我们如何找到年轻代中对象的根对象呢？ 根对象可能是在年轻代中，也可以在老年代中，那么老年代中的所有对象都是根么？ 如果全量扫描老年代，那么这样扫描下来会耗费大量的时间。 于是，G1引进了RSet的概念。它的全称是Remembered Set，其作用是跟踪指向某个堆内的对象引用。 每个Region初始化时，会初始化一个RSet，该集合用来记录并跟踪其它Region指向该Region中对象的引用，每个Region默认按照512Kb划分成多个Card，所以RSet需要记录的东西应该是 xx Region的 xx Card。 3.4.3、Mixed GC当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region，这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC 并不是 Full GC。 MixedGC什么时候触发？ 由参数 -XX:InitiatingHeapOccupancyPercent=n 决定。默认：45%，该参数的意思是：当老年代大小占整个堆大小百分比达到该阀值时触发。 它的GC步骤分2步： 全局并发标记（global concurrent marking） 拷贝存活对象（evacuation） 3.4.3.1、全局并发标记全局并发标记，执行过程分为五个步骤： 初始标记（initial mark，STW） 标记从根节点直接可达的对象，这个阶段会执行一次年轻代GC，会产生全局停顿。 根区域扫描（root region scan） G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。 该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收。 并发标记（Concurrent Marking） G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断。 重新标记（Remark，STW） 该阶段是 STW 回收，因为程序在运行，针对上一次的标记进行修正。 清除垃圾（Cleanup，STW） 清点和重置标记状态，该阶段会STW，这个阶段并不会实际上去做垃圾的收集，等待evacuation阶段来回收。 3.4.3.2、拷贝存活对象Evacuation阶段是全暂停的。该阶段把一部分Region里的活对象拷贝到另一部分Region中，从而实现垃圾的回收清理。 3.4.4、G1收集器相关参数 -XX:+UseG1GC 使用 G1 垃圾收集器 -XX:MaxGCPauseMillis 设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到），默认值是 200 毫秒。 -XX:G1HeapRegionSize=n 设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。 默认是堆内存的1/2000。 -XX:ParallelGCThreads=n 设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。 -XX:ConcGCThreads=n 设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右。 -XX:InitiatingHeapOccupancyPercent=n 设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。 3.4.5、测试123456789101112131415161718192021222324252627282930313233-XX:+UseG1GC -XX:MaxGCPauseMillis=100 -XX:+PrintGCDetails -Xmx256m#日志[GC pause (G1 Evacuation Pause) (young), 0.0044882 secs] [Parallel Time: 3.7 ms, GC Workers: 3] [GC Worker Start (ms): Min: 14763.7, Avg: 14763.8, Max: 14763.8, Diff: 0.1] #扫描根节点 [Ext Root Scanning (ms): Min: 0.2, Avg: 0.3, Max: 0.3, Diff: 0.1, Sum: 0.8] #更新RS区域所消耗的时间 [Update RS (ms): Min: 1.8, Avg: 1.9, Max: 1.9, Diff: 0.2, Sum: 5.6] [Processed Buffers: Min: 1, Avg: 1.7, Max: 3, Diff: 2, Sum: 5] [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] #对象拷贝 [Object Copy (ms): Min: 1.1, Avg: 1.2, Max: 1.3, Diff: 0.2, Sum: 3.6] [Termination (ms): Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 0.2] [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 3] [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [GC Worker Total (ms): Min: 3.4, Avg: 3.4, Max: 3.5, Diff: 0.1, Sum: 10.3] [GC Worker End (ms): Min: 14767.2, Avg: 14767.2, Max: 14767.3, Diff: 0.1] [Code Root Fixup: 0.0 ms] [Code Root Purge: 0.0 ms] [Clear CT: 0.0 ms] #清空CardTable [Other: 0.7 ms] [Choose CSet: 0.0 ms] #选取CSet [Ref Proc: 0.5 ms] #弱引用、软引用的处理耗时 [Ref Enq: 0.0 ms] #弱引用、软引用的入队耗时 [Redirty Cards: 0.0 ms] [Humongous Register: 0.0 ms] #大对象区域注册耗时 [Humongous Reclaim: 0.0 ms] #大对象区域回收耗时 [Free CSet: 0.0 ms] [Eden: 7168.0K(7168.0K)-&gt;0.0B(13.0M) Survivors: 2048.0K-&gt;2048.0K Heap: 55.5M(192.0M)-&gt;48.5M(192.0M)] #年轻代的大小统计 [Times: user=0.00 sys=0.00, real=0.00 secs] 3.4.6、对于G1垃圾收集器优化建议 年轻代大小 避免使用 -Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小。 固定年轻代的大小会覆盖暂停时间目标。 暂停时间目标不要太过严苛 G1 GC 的吞吐量目标是 90% 的应用程序时间和 10%的垃圾回收时间。 评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示您愿意承受更多的垃圾回收开销，而这会直接影响到吞吐量。 4、可视化GC日志分析工具4.1、GC日志输出参数前面通过-XX:+PrintGCDetails可以对GC日志进行打印，我们就可以在控制台查看，这样虽然可以查看GC的信息，但是并不直观，可以借助于第三方的GC日志分析工具进行查看。 在日志打印输出涉及到的参数如下： 123456-XX:+PrintGC 输出GC日志-XX:+PrintGCDetails 输出GC的详细日志-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息-Xloggc:../logs/gc.log 日志文件的输出路径 测试： 1-XX:+UseG1GC -XX:MaxGCPauseMillis=100 -Xmx256m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:F://test//gc.log 运行后就可以在E盘下生成gc.log文件。 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Java HotSpot(TM) 64-Bit Server VM (25.144-b01) for windows-amd64 JRE (1.8.0_144-b01), built on Jul 21 2017 21:57:33 by "java_re" with MS VC++ 10.0 (VS2010)Memory: 4k page, physical 12582392k(1939600k free), swap 17300984k(5567740k free)CommandLine flags: -XX:InitialHeapSize=201318272 -XX:MaxGCPauseMillis=100 -XX:MaxHeapSize=268435456 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC -XX:-UseLargePagesIndividualAllocation &#123;Heap before GC invocations=0 (full 0): garbage-first heap total 196608K, used 9216K [0x00000000f0000000, 0x00000000f0100600, 0x0000000100000000) region size 1024K, 9 young (9216K), 0 survivors (0K) Metaspace used 3491K, capacity 4500K, committed 4864K, reserved 1056768K class space used 381K, capacity 388K, committed 512K, reserved 1048576K2018-09-24T23:06:02.230+0800: 0.379: [GC pause (G1 Evacuation Pause) (young), 0.0031038 secs] [Parallel Time: 2.8 ms, GC Workers: 3] [GC Worker Start (ms): Min: 378.6, Avg: 378.8, Max: 379.0, Diff: 0.3] [Ext Root Scanning (ms): Min: 0.0, Avg: 0.4, Max: 0.8, Diff: 0.8, Sum: 1.3] [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0] [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.1] [Object Copy (ms): Min: 1.8, Avg: 1.9, Max: 1.9, Diff: 0.1, Sum: 5.6] [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0] [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 3] [GC Worker Other (ms): Min: 0.0, Avg: 0.2, Max: 0.6, Diff: 0.6, Sum: 0.6] [GC Worker Total (ms): Min: 2.4, Avg: 2.5, Max: 2.7, Diff: 0.3, Sum: 7.6] [GC Worker End (ms): Min: 381.4, Avg: 381.4, Max: 381.4, Diff: 0.0] [Code Root Fixup: 0.0 ms] [Code Root Purge: 0.0 ms] [Clear CT: 0.0 ms] [Other: 0.2 ms] [Choose CSet: 0.0 ms] [Ref Proc: 0.1 ms] [Ref Enq: 0.0 ms] [Redirty Cards: 0.0 ms] [Humongous Register: 0.0 ms] [Humongous Reclaim: 0.0 ms] [Free CSet: 0.0 ms] [Eden: 9216.0K(9216.0K)-&gt;0.0B(7168.0K) Survivors: 0.0B-&gt;2048.0K Heap: 9216.0K(192.0M)-&gt;1888.0K(192.0M)]Heap after GC invocations=1 (full 0): garbage-first heap total 196608K, used 1888K [0x00000000f0000000, 0x00000000f0100600, 0x0000000100000000) region size 1024K, 2 young (2048K), 2 survivors (2048K) Metaspace used 3491K, capacity 4500K, committed 4864K, reserved 1056768K class space used 381K, capacity 388K, committed 512K, reserved 1048576K&#125; [Times: user=0.00 sys=0.00, real=0.00 secs] &#123;Heap before GC invocations=1 (full 0): garbage-first heap total 196608K, used 9056K [0x00000000f0000000, 0x00000000f0100600, 0x0000000100000000) region size 1024K, 9 young (9216K), 2 survivors (2048K) Metaspace used 3492K, capacity 4500K, committed 4864K, reserved 1056768K class space used 381K, capacity 388K, committed 512K, reserved 1048576K2018-09-24T23:06:02.310+0800: 0.458: [GC pause (G1 Evacuation Pause) (young), 0.0070126 secs]。。。。。。。。。。。。。。。。。。。 4.2、GC Easy 可视化工具GC Easy是一款在线的可视化工具，易用、功能强大，网站： http://gceasy.io/ 上传后，点击“Analyze”按钮，即可查看报告。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github骚操作]]></title>
    <url>%2F2019%2F05%2F29%2Fgithub%E9%AA%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[github的骚操作集锦你值得拥有！ 常用词的含义： watch：会持续收到该项目的动态 fork，复制某个项目到自己的Github仓库中 star，可以理解为点赞 clone，将项目下载至本地 follow，关注你感兴趣的作者，会收到他们的动态 通过in关键词限制搜索范围 xxx in:name 项目名包含xxx的 xxx in:description 项目描述包含xxx的 xxx in:readme 项目的readme文件中包含xxx的 当然也可以通过xxx in:name,desciption来组合使用 例如：ICU in:name,description 表示搜索在项目名和项目描述中包含ICU的项目 通过 Star 或者Fork数 去查找项目通过通配符 &gt; &lt; = 即可，区间范围内可通过 num1..num2 如，要查找stars数不小于666的springboot项目 springboot stars:&gt;=666 forks 大于等于500 springboot forks:&gt;500 查找fork在100到200之间 且stars数在80到100之间的springboot项目 springboot forks:100..200 stars:80..1000 awesome + 关键字搜索和关键字匹配的优秀项目！注意，是优秀哦！和 springboot in:name这样搜索出的结果是不同的！ awesome springboot 搜索优秀的springboot相关的项目，包括框架、教程等来进行学习。 注意到那个粉色眼镜了吗，那就是Awesome Lists的标识。（我做了一个实验，把awesome放在关键词的后面搜索其实结果是一样的，只是少了这个粉红眼镜） 分享项目中某一行的代码只需要在具体的网址后面拼接#Lxx(xx为行数)，如果是段落的话，就为#Lxx-Lxx，选中的行就会高亮显示 当然，这个操作直接用鼠标选中也是可以的，效果相同。 项目内搜索打开你想要搜索的项目，然后按一下‘T’键。会跳转至一个新的网页 类似的页面内快捷键还有很多，常用的还有’L‘, 在文件内跳转到多少行。 更多快捷键可以查看官方文档 https://help.github.com/en/articles/using-keyboard-shortcuts 搜索某个地区内的大佬可以通过location:地区 进行检索，在具体可以通过language:语言 缩小检索范围 如搜索地区在北京的Java方向的用户 location:beijing language:java 北京的大佬出现了！ 推荐一些Github插件 Octotree（推荐安装） 平时浏览github代码时，每个文件都需要点击才能查看，用了这个插件可以将项目的目录结构以树形结构显示，点击之后会自动跳转到相应的目录。墙裂推荐！ 下面晒出图，左侧就是啦！体验极好！ OctoLinker（推荐） 浏览代码如果可以像ide那样可以链接跳转岂不是美滋滋，这个插件就可以帮助我们完成这些。只需要ctrl+点击变量名即可。 Sourcegraph（推荐安装） 一个可以在github上浏览和搜索代码的工具，安装好插件之后会出现一个view Repository的按钮 下图中标红处就是啦！ 感觉非常好 这个插件同时带有以上两个插件的功能哦！]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GC Roots的对象，以及对java类中的成员变量，局部变量，静态变量和常量的不同回收时机的解析]]></title>
    <url>%2F2019%2F05%2F06%2FGC-Roots%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AF%B9java%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%94%B6%E6%97%B6%E6%9C%BA%E7%9A%84%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.作为GC Roots的对象有以下几种 虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中引用的对象。 方法区中的类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI（Native）方法引用的对象。 2.成员变量（实例变量）&amp;局部变量&amp;静态变量（类变量）的区别成员变量（实例变量）&amp;局部变量区别： 作用域 成员变量：针对整个类有效。 局部变量：只在某个范围内有效。(一般指的就是方法,语句体内) 存储位置 成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。 局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中（栈帧中的局部变量表）。当方法调用完，或者语句结束后，就自动释放。 初始值 成员变量：有默认初始值。注意：赋值的时候不能把声明和赋值分开举例： 1234public class demo&#123; int x ; x = 1; //这样不行&#125; 123public class demo&#123; int x = 10; //这样就可以&#125; 原因是 ：成员变量在类的范围内，存在于堆内存中，会有默认的初始值，在声明的同时已经给变量赋值了。再次”赋值“实际是使用了语句，而类体里面只能出现变量和方法,不能出现语句。 局部变量：没有默认初始值，使用前必须赋值。 成员变量（实例变量）&amp;静态变量（类变量）区别： 调用方式静态变量也称为类变量，可以直接通过类名调用。也可以通过对象名调用。这个变量属于类。成员变量也称为实例变量，只能通过对象名调用。这个变量属于对象。 存储位置静态变量存储在方法区中。成员变量存储在堆内存。 生命周期静态变量随着类的加载而存在，随着类的消失而消失。生命周期长。成员变量随着对象的创建而存在，随着对象的消失而消失。 与对象的相关性静态变量是所有对象共享的数据。成员变量是每个对象所特有的数据。 关于静态变量和常量的详细解析：参照：从class文件与JVM加载机制理解final、static、static final 不同的回收机制总结 变量属于类变量（静态变量），那么永远不会被回收，原因是方法区中的类静态属性引用的对象是GC Roots，不会被回收。 变量属于实例（成员变量，包括final），则实例被回收才会被顺便回收（和实例一起存在堆中，栈帧中的局部变量区（GC Root）中不再引用，就回收） 变量属于实例的方法（局部变量），那么他是在栈中临时的（栈帧中的局部变量区（GC Root），GC的区域在堆和方法区，而不在栈），随着方法结束了，栈自动释放了，无需回收。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从class文件与JVM加载机制理解final、static、static final]]></title>
    <url>%2F2019%2F05%2F06%2F%E4%BB%8Eclass%E6%96%87%E4%BB%B6%E4%B8%8EJVM%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3final%E3%80%81static%E3%80%81static-final%2F</url>
    <content type="text"><![CDATA[编程过程中经常用的static，final关键字，JVM中class类文件结构可以找到答案。 ConstantValue属性ConstantValue属性的作用是通知虚拟机自动为静态变量赋值，只有被static修饰的变量才可以使用这项属性。非static类型的变量的赋值是在实例构造器方法中进行的；static类型变量赋值分两种，在类构造器中赋值，或使用ConstantValue属性赋值。 在实际的程序中，只有同时被final和static修饰的字段才有ConstantValue属性，且限于基本类型和String。编译时Javac将会为该常量生成ConstantValue属性，在类加载的准备阶段虚拟机便会根据ConstantValue为常量设置相应的值，如果该变量没有被final修饰，或者并非基本类型及字符串，则选择在类构造器中进行初始化。 1.为什么ConstantValue的属性值只限于基本类型和String？因为从常量池中只能引用到基本类型和String类型的字面量 2.final、static、static final修饰的字段赋值的区别？ static修饰的字段在加载过程中准备阶段被初始化，但是这个阶段只会赋值一个默认的值（0或者null而并非定义变量设置的值）初始化阶段在类构造器中才会赋值为变量定义的值。（关于static的初始化请看“init”与”clinit”的区别） final修饰的字段在运行时被初始化，可以直接赋值，也可以在实例构造器中赋值，赋值后不可修改。final关键字对于变量的存储区域是没有任何影响的。jvm规范中，类的静态变量存储在方法区，实例变量存储在堆区。也就是说static关键字才对变量的存储区域造成影响。final关键字来修饰变量表明了该变量一旦赋值就无法更改。同时编译器必须保证该变量在使用前被初始化赋值。例如你的static final int c1这个变量，是一个静态变量，静态变量的初始化可以在静态块中进行。而非static变量，可以初始化块中和构造方法中进行。如果你在这几个地方没有对final变量进行赋值，编译器便会报错。 static final修饰的字段在javac编译时生成comstantValue属性，在类加载的准备阶段直接把constantValue的值赋给该字段。可以理解为在编译期即把结果放入了常量池中。 在一个类中定义字段时，可以声明为成员变量（如final），也可以声明为类变量（静态变量），静态变量在装载类时被初始化，而成员变量每次创建实例时都会被初始化一次。一个字段被声明为static final，表示这个字段在初始化完成后就不可再改变了，final，类的初始化完成后，在类的实例化进行赋值，每次实例化的值不一定相同。加上了static 的 final，在类只装载一次的情况下，可以是真正意义的“常量”例如： 12private static final int random = new Random().nestInt();//每次发生类装载时都会赋值一次，且赋的值都不一样 private final int random = new Random().nestInt();//每次生成这个类的实例时都会赋值一次，且赋的值都不一样]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“init”与“clinit”的区别]]></title>
    <url>%2F2019%2F05%2F06%2Finit-%E4%B8%8E-clinit-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[关于类加载时的&lt;clinit>与类实例化时的&lt;init> 在编译生成class文件时，会自动产生两个方法，一个是类的初始化方法&lt;clinit>, 另一个是实例的初始化方法&lt;init>注意: &lt;clinit>:如果没有静态块，静态变量则没有&lt;clinit> &lt;init>:类的实例构造器。 关于二者的详细对照： &lt;clinit>：在JVM第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行 &lt;init>:在实例创建出来的时候调用，包括调用new操作符；调用Class或Java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。 初始化过程： 初始化就是执行&lt;clinit>()方法的过程。 &lt;clinit>如果没有静态块，静态变量则没有&lt;clinit> &lt;init>类的实例构造器 1234567class A &#123; static int i = 2; static &#123; System.out.println(“”); &#125; int n; &#125; &lt;clinit>静态变量，静态块的初始化 &lt;init>类的初始化]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM之Class文件分析详解]]></title>
    <url>%2F2019%2F05%2F03%2FJVM%E4%B9%8BClass%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[JVM之Class文件分析详解逐个字节分析Class文件。了解Class文件内部结构。 原始类文件：这个类直接拿了知乎的一个类，分析是很简单，只是因为重新画图比较麻烦，不想再做重复的苦力工作（地址（https://zhuanlan.zhihu.com/p/23068093）ps:作者仅仅提供了类和图，并无解析。） 123456789package com.vonzhou.learn.jvm.klass;public class Foo &#123; private int m; public int inc() &#123; return m + 1; &#125;&#125; Class结构体一个Class文件可以用如下的结构体抽象： Step by Step接下来就是对照着字节码和JVM规范阅读的过程，对自己多点耐心。 Class魔数和版本 常量池计数器和常量池 注意：常量池内常量的真实数量是 常量池计数器-1 那么接下来就是这三个了： 访问标志 这里 为什么是0021呢？因为 0X0001|0X0020 = 0X0021。 类索引，父类索引 接下来的2B是this_class指向我们的类名, super_class指示父类。 这里没有实现接口： 字段计数器和字段表集合fields_count以后进入字段表集合 方法计数器和方发表集合首先进入方法计数器。 从上可以看出，关键的不同点在于attribute_info字段。这是属性表集合，下面附上属性表集合的一般结构。 从上面两个图可以看出属性表前两个字段时固定的，关键在于第三个字段各有不同，比如方法表的属性表Code的完整格式为下图 接下来就对Code属性表进行梳理： 属性计数器和属性表集合 属性表集合中的SourceFile： 由属性计数器后的0010计算十进制数为 下面的DEC为16，所以找到第16个常量为 没错了，是SourceFile ​ 附上javap -version 验证解析结果使用javap解析出来的结果中没有包含LocalVariableTable字段，需要在使用javac编译java中时，加上-g的参数，生成的class文件中才带有LocalVariableTable的信息。LocalVariableTable属性：用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系，非运行时必需属性，默认不会生成至Class文件中，可以使用Javac的-g:none或-g:vars关闭或要求生成该项属性信息。 另外：LineNumberTale属性：用于描述Java源码的行号与字节码行号之间的对应关系，非运行时必需属性，会默认生成至Class文件中，可以使用Javac的-g:none或-g:lines关闭或要求生成该项属性信息。 具体编译过程： 1javac -g -d . Foo.java 1javap -v com.vonzhou.learn.jvm.klass.Foo 1ca fe ba be 20 20 20 34 20 16 0a 20 04 20 12 09 20 03 20 13 07 20 14 07 20 15 01 20 01 6d 01 20 01 49 01 20 06 3c 69 6e 69 74 3e 01 20 03 28 29 56 01 20 04 43 6f 64 65 01 20 0f 4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 01 20 12 4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 20 04 74 68 69 73 01 20 21 4c 63 6f 6d 2f 76 6f 6e 7a 68 6f 75 2f 6c 65 61 72 6e 2f 6a 76 6d 2f 6b 6c 61 73 73 2f 46 6f 6f 3b 01 20 03 69 6e 63 01 20 03 28 29 49 01 20 0a 53 6f 75 72 63 65 46 69 6c 65 01 20 08 46 6f 6f 2e 6a 61 76 61 0c 20 07 20 08 0c 20 05 20 06 01 20 1f 63 6f 6d 2f 76 6f 6e 7a 68 6f 75 2f 6c 65 61 72 6e 2f 6a 76 6d 2f 6b 6c 61 73 73 2f 46 6f 6f 01 20 10 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 20 21 20 03 20 04 20 20 20 01 20 02 20 05 20 06 20 20 20 02 20 01 20 07 20 08 20 01 20 09 20 20 20 2f 20 01 20 01 20 20 20 05 2a b7 20 01 b1 20 20 20 02 20 0a 20 20 20 06 20 01 20 20 20 03 20 0b 20 20 20 0c 20 01 20 20 20 05 20 0c 20 0d 20 20 20 01 20 0e 20 0f 20 01 20 09 20 20 20 31 20 02 20 01 20 20 20 07 2a b4 20 02 04 60 ac 20 20 20 02 20 0a 20 20 20 06 20 01 20 20 20 07 20 0b 20 20 20 0c 20 01 20 20 20 07 20 0c 20 0d 20 20 20 01 20 10 20 20 20 02 20 11 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263E:\JVM&gt;javap -v com.vonzhou.learn.jvm.klass.FooClassfile /E:/JVM/com/vonzhou/learn/jvm/klass/Foo.class Last modified 2019-5-3; size 391 bytes MD5 checksum 4d9e593620f49a9114d834ec5d923986 Compiled from "Foo.java"public class com.vonzhou.learn.jvm.klass.Foo minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#18 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #3.#19 // com/vonzhou/learn/jvm/klass/Foo.m:I #3 = Class #20 // com/vonzhou/learn/jvm/klass/Foo #4 = Class #21 // java/lang/Object #5 = Utf8 m #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/vonzhou/learn/jvm/klass/Foo; #14 = Utf8 inc #15 = Utf8 ()I #16 = Utf8 SourceFile #17 = Utf8 Foo.java #18 = NameAndType #7:#8 // "&lt;init&gt;":()V #19 = NameAndType #5:#6 // m:I #20 = Utf8 com/vonzhou/learn/jvm/klass/Foo #21 = Utf8 java/lang/Object&#123; public com.vonzhou.learn.jvm.klass.Foo(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/vonzhou/learn/jvm/klass/Foo; public int inc(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: getfield #2 // Field m:I 4: iconst_1 5: iadd 6: ireturn LineNumberTable: line 7: 0 LocalVariableTable: Start Length Slot Name Signature 0 7 0 this Lcom/vonzhou/learn/jvm/klass/Foo;&#125;SourceFile: "Foo.java" 再次附上没有 -g 的结果： 1ca fe ba be 20 20 20 34 20 13 0a 20 04 20 0f 09 20 03 20 10 07 20 11 07 20 12 01 20 01 6d 01 20 01 49 01 20 06 3c 69 6e 69 74 3e 01 20 03 28 29 56 01 20 04 43 6f 64 65 01 20 0f 4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 01 20 03 69 6e 63 01 20 03 28 29 49 01 20 0a 53 6f 75 72 63 65 46 69 6c 65 01 20 08 46 6f 6f 2e 6a 61 76 61 0c 20 07 20 08 0c 20 05 20 06 01 20 1f 63 6f 6d 2f 76 6f 6e 7a 68 6f 75 2f 6c 65 61 72 6e 2f 6a 76 6d 2f 6b 6c 61 73 73 2f 46 6f 6f 01 20 10 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 20 21 20 03 20 04 20 20 20 01 20 02 20 05 20 06 20 20 20 02 20 01 20 07 20 08 20 01 20 09 20 20 20 1d 20 01 20 01 20 20 20 05 2a b7 20 01 b1 20 20 20 01 20 0a 20 20 20 06 20 01 20 20 20 03 20 01 20 0b 20 0c 20 01 20 09 20 20 20 1f 20 02 20 01 20 20 20 07 2a b4 20 02 04 60 ac 20 20 20 01 20 0a 20 20 20 06 20 01 20 20 20 07 20 01 20 0d 20 20 20 02 20 0e 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556E:\JVM&gt;javac -d . Foo.javaE:\JVM&gt;javap -v com.vonzhou.learn.jvm.klass.FooClassfile /E:/JVM/com/vonzhou/learn/jvm/klass/Foo.class Last modified 2019-5-3; size 291 bytes MD5 checksum 45262c23d72e75c78347d2f05b918bee Compiled from "Foo.java"public class com.vonzhou.learn.jvm.klass.Foo minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #3.#16 // com/vonzhou/learn/jvm/klass/Foo.m:I #3 = Class #17 // com/vonzhou/learn/jvm/klass/Foo #4 = Class #18 // java/lang/Object #5 = Utf8 m #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 inc #12 = Utf8 ()I #13 = Utf8 SourceFile #14 = Utf8 Foo.java #15 = NameAndType #7:#8 // "&lt;init&gt;":()V #16 = NameAndType #5:#6 // m:I #17 = Utf8 com/vonzhou/learn/jvm/klass/Foo #18 = Utf8 java/lang/Object&#123; public com.vonzhou.learn.jvm.klass.Foo(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 3: 0 public int inc(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: getfield #2 // Field m:I 4: iconst_1 5: iadd 6: ireturn LineNumberTable: line 7: 0&#125;SourceFile: "Foo.java" 参考《深入理解Java虚拟机》周志明， 另外找到的其他关于Class文件解析的文章有： https://www.cnblogs.com/timlong/p/8143839.html https://www.cnblogs.com/noteless/p/9540876.html#0 https://www.jianshu.com/p/d0f3e361f92e https://www.jb51.net/article/116203.htm（这个有对文中没有详细解释的method方法的属性的解释）]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot的属性注入和自动配置原理]]></title>
    <url>%2F2019%2F04%2F17%2FSpringBoot%E7%9A%84%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%E5%92%8C%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[SpringBoot的学习，属性注入和自动配置原理。 1. 了解SpringBoot在这一部分，我们主要了解以下3个问题： 什么是SpringBoot 为什么要学习SpringBoot SpringBoot的特点 1.1.什么是SpringBootSpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品: 我们可以看到下面的一段介绍： Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 翻译一下： 用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。 其实人们把Spring Boot 称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。 1.2.为什么要学习SpringBootjava一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点： 复杂的配置， 项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。 一个是混乱的依赖管理。 项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 而SpringBoot让这一切成为过去！ Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。 我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 1.3.SpringBoot的特点Spring Boot 主要目标是： 为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验 开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。 提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等 绝对没有代码生成，也无需 XML 配置。 更多细节，大家可以到官网查看。 2.快速入门接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！ 2.1.创建工程我们先新建一个空的工程： 工程名为demo： 新建一个model： 使用maven来构建： 然后填写项目坐标： 目录结构： 项目结构： 2.2.添加依赖看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？ 别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！ 2.2.1.添加父工程坐标12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt; 2.2.2.添加web启动器为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为启动器。因为我们是web项目，这里我们引入web启动器： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。 这个时候，我们会发现项目中多出了大量的依赖： 这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。 2.2.3.管理jdk版本默认情况下，maven工程的jdk版本是1.5，而我们开发使用的是1.8，因此这里我们需要修改jdk版本，只需要简单的添加以下属性即可： 123&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt; 2.2.4.完整pom123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.3.启动类Spring Boot项目通过main函数即可启动，我们需要创建一个启动类： 然后编写main函数： 123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 2.4.编写controller接下来，我们就可以像以前那样开发SpringMVC的项目了！ 我们编写一个controller： 代码： 12345678@RestControllerpublic class HelloController &#123; @GetMapping("hello") public String hello()&#123; return "hello, spring boot!"; &#125;&#125; 2.5.启动测试接下来，我们运行main函数，查看控制台： 并且可以看到监听的端口信息： 1）监听的端口是8080 2）SpringMVC的映射路径是：/ 3）/hello路径已经映射到了HelloController中的hello()方法 打开页面访问：http://localhost:8080/hello 测试成功了！ 3.Java配置在入门案例中，我们没有任何的配置，就可以实现一个SpringMVC的项目了，快速、高效！ 但是有同学会有疑问，如果没有任何的xml，那么我们如果要配置一个Bean该怎么办？比如我们要配置一个数据库连接池，以前会这么玩： 1234567&lt;!-- 配置连接池 --&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt;&lt;/bean&gt; 现在该怎么做呢？ 3.1.回顾历史事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史： Spring1.0时代 在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒 Spring2.0时代 Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。 Spring3.0及以后 3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。 有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。 3.2.尝试java配置java配置主要靠java类和一些注解，比较常用的注解有： @Configuration：声明一个类作为配置类，代替xml文件 @Bean：声明在方法上，将方法的返回值加入Bean容器，代替&lt;bean&gt;标签 @value：属性注入 @PropertySource：指定外部属性文件， 我们接下来用java配置来尝试实现连接池配置： 首先引入Druid连接池依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 创建一个jdbc.properties文件，编写jdbc属性： 1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/leyoujdbc.username=rootjdbc.password=123 然后编写代码： 1234567891011121314151617181920212223@Configuration@PropertySource("classpath:jdbc.properties")public class JdbcConfig &#123; @Value("$&#123;jdbc.url&#125;") String url; @Value("$&#123;jdbc.driverClassName&#125;") String driverClassName; @Value("$&#123;jdbc.username&#125;") String username; @Value("$&#123;jdbc.password&#125;") String password; @Bean public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 解读： @Configuration：声明我们JdbcConfig是一个配置类 @PropertySource：指定属性文件的路径是:classpath:jdbc.properties 通过@Value为属性注入值 通过@Bean将 dataSource()方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。 然后我们就可以在任意位置通过@Autowired注入DataSource了！ 我们在HelloController中测试： 1234567891011@RestControllerpublic class HelloController &#123; @Autowired private DataSource dataSource; @GetMapping("hello") public String hello() &#123; return "hello, spring boot!" + dataSource; &#125;&#125; 然后Debug运行并查看： 属性注入成功了！ 3.3.SpringBoot的属性注入在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。 在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。 1）我们新建一个类，用来进行属性注入： 123456789@ConfigurationProperties(prefix = "jdbc")public class JdbcProperties &#123; private String url; private String driverClassName; private String username; private String password; // ... 略 // getters 和 setters&#125; 在类上通过@ConfigurationProperties注解声明当前类为属性读取类 prefix=&quot;jdbc&quot;读取属性文件中，前缀为jdbc的值。 在类上定义各个属性，名称必须与属性文件中jdbc.后面部分一致 需要注意的是，这里我们并没有指定属性文件的地址，所以我们需要把jdbc.properties名称改为application.properties，这是SpringBoot默认读取的属性文件名： 2）在JdbcConfig中使用这个属性： 1234567891011121314@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfig &#123; @Bean public DataSource dataSource(JdbcProperties jdbc) &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(jdbc.getUrl()); dataSource.setDriverClassName(jdbc.getDriverClassName()); dataSource.setUsername(jdbc.getUsername()); dataSource.setPassword(jdbc.getPassword()); return dataSource; &#125;&#125; 通过@EnableConfigurationProperties(JdbcProperties.class)来声明要使用JdbcProperties这个类的对象 然后你可以通过以下方式注入JdbcProperties： @Autowired注入 12@Autowiredprivate JdbcProperties prop; 构造函数注入 1234private JdbcProperties prop;public JdbcConfig(Jdbcproperties prop)&#123; this.prop = prop;&#125; 声明有@Bean的方法参数注入 1234@Beanpublic Datasource dataSource(JdbcProperties prop)&#123; // ...&#125; 本例中，我们采用第三种方式。 3）测试结果： 大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系： 优势： Relaxed binding：松散绑定 不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。 meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。 3.4.更优雅的注入事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可： 1234567891011@Configurationpublic class JdbcConfig &#123; @Bean // 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中 @ConfigurationProperties(prefix = "jdbc") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); return dataSource; &#125;&#125; 我们直接把@ConfigurationProperties(prefix = &quot;jdbc&quot;)声明在需要使用的@Bean的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：该类必须有对应属性的set方法！ 我们将jdbc的url改成：/heima，再次测试： 4.自动配置原理使用SpringBoot之后，一个整合了SpringMVC的WEB工程开发，变的无比简单，那些繁杂的配置都消失不见了，这是如何做到的？ 一切魔力的开始，都是从我们的main函数来的，所以我们再次来看下启动类： 我们发现特别的地方有两个： 注解：@SpringBootApplication run方法：SpringApplication.run() 我们分别来研究这两个部分。 4.1.了解@SpringBootApplication点击进入，查看源码： 这里重点的注解有3个： @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan 4.1.1.@SpringBootConfiguration我们继续点击查看源码： 通过这段我们可以看出，在这个注解上面，又有一个@Configuration注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，并且读取其中的配置信息。而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。 4.1.2.@EnableAutoConfiguration关于这个注解，官网上有一段说明： The second class-level annotation is @EnableAutoConfiguration. This annotationtells Spring Boot to “guess” how you want to configure Spring, based on the jardependencies that you have added. Since spring-boot-starter-web added Tomcatand Spring MVC, the auto-configuration assumes that you are developing a webapplication and sets up Spring accordingly. 简单翻译以下： 第二级的注解@EnableAutoConfiguration，告诉SpringBoot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！ 总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。 所以，我们使用SpringBoot构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。除非你不希望使用SpringBoot的默认配置，它也提供了自定义配置的入口。 4.1.3.@ComponentScan我们跟进源码： 并没有看到什么特殊的地方。我们查看注释： 大概的意思： 配置组件扫描的指令。提供了类似与&lt;context:component-scan&gt;标签的作用 通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包 而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，一般启动类会放在一个比较前的包目录中。 4.2.默认配置原理4.2.1默认配置类通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了： 这些默认配置是在哪里定义的呢？ 为何依赖引入就会触发配置呢？ 其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类： 还有： 非常多，几乎涵盖了现在主流的开源框架，例如： redis jms amqp jdbc jackson mongodb jpa solr elasticsearch … 等等 我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类： 打开WebMvcAutoConfiguration： 我们看到这个类上的4个注解： @Configuration：声明这个类是一个配置类 @ConditionalOnWebApplication(type = Type.SERVLET) ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是 @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) 这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！ @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！ 接着，我们查看该类中定义了什么： 视图解析器： 处理器适配器（HandlerAdapter）： 还有很多，这里就不一一截图了。 4.2.2.默认配置属性另外，这些默认配置的属性来自哪里呢？ 我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。这不正是SpringBoot的属性注入玩法嘛。 我们查看这两个属性类： 找到了内部资源视图解析器的prefix和suffix属性。 ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径： 如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。 4.3.总结SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个： 你引入了相关依赖 你自己没有配置Bean 1）启动器 所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。 因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器。 2）全局配置 另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义application.properties文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。 因此，玩SpringBoot的第二件事情，就是通过application.properties来覆盖默认属性值，形成自定义配置。 属性文件支持两种格式，application.properties和application.yml yml的语法实例： 12345678jdbc: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/leyou username: root password: 123server: port: 80]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统总结]]></title>
    <url>%2F2019%2F04%2F17%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于操作系统问题的总结。 操作系统总结：1.进程和线程的区别是什么？进程是CPU分配资源的最小单元，线程是CPU调度的基本单元、一个进程可以包含多个线程、巴拉巴拉。如果你觉得这个概念在你心里不是特别清楚的话，一定要到网上看一下，最好能够理解为什么有些时候要使用线程不使用进程。因为进程启动的时候cpu需要给他分配资源，对系统压力比进程大，你可以把线程看成是轻量级的进程。 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 何时使用多进程，何时使用多线程？对资源的管理和保护要求高，不限制开销和效率时，使用多进程。要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。 2.进程间通信的方式有什么？线程间通信的方式有什么？这也是一个被问烂的问题。进程间通讯可以通过socket，管道，信号，消息，共享内存等多种方式。线程间通信就比较简单了，直接共享变量也行，通过管道也行。 进程的通信方式：管道、信号量、消息队列、信号、共享内存、套接字 参考博客：https://blog.csdn.net/biqioso/article/details/80025726线程间通信 参考博客：https://blog.csdn.net/qq_32621445/article/details/78635951 3.什么是缓存？有哪些缓存的更新算法？缓存的更新算法用的最多的应该就是LRU。 ———————————————-还未完成，等待更新。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络总结]]></title>
    <url>%2F2019%2F04%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于计算机网络的问题总结. 计算机网络总结1.OSI，TCP/IP，五层协议的体系结构，以及各层协议OSI分层 （7层）： 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。TCP/IP分层（4层）： 网络接口层、 网际层、运输层、 应用层。五层协议 （5层）： 物理层、数据链路层、网络层、运输层、 应用层。 每一层的协议如下：物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）数据链路层：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）传输层：TCP、UDP、SPX会话层：NFS、SQL、NETBIOS、RPC表示层：JPEG、MPEG、ASII应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 每一层的作用如下：物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）数据链路层：将比特组装成帧和点到点的传递（帧Frame）网络层：负责数据包从源到宿的传递和网际互连（包PackeT）传输层：提供端到端的可靠报文传递和错误恢复（段Segment）会话层：建立、管理和终止会话（会话协议数据单元SPDU）表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）应用层：允许访问OSI环境的手段（应用协议数据单元APDU） OSI将计算机网络体系结构(architecture）划分为以下七层：物理层: 将数据转换为可通过物理介质传送的电子信号 相当于邮局中的搬运工人。数据链路层: 决定访问网络介质的方式。在此层将数据分帧，并处理流控制。本层指定拓扑结构并提供硬件寻址，相当于邮局中的装拆箱工人。网络层: 使用权数据路由经过大型网络 相当于邮局中的排序工人。传输层: 提供终端到终端的可靠连接 相当于公司中跑邮局的送信职员。会话层: 允许用户使用简单易记的名称建立连接 相当于公司中收寄信、写信封与拆信封的秘书。表示层: 协商数据交换格式 相当公司中简报老板、替老板写信的助理。应用层: 用户的应用程序和网络之间的接口老板。 2.TCP协议中的三次握手，为什么两次握手不行建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。（1）TCP的三次握手过程： 主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况 ，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。（3）采用两次握手不行，原因就是上面说的“失效的连接请求“的特殊情况。 3.TCP和UDP有什么区别，什么场景使用TCP，什么场景什么UDP，哪些应用层协议使用了TCP，哪些使用了UDPTCP和UDP最主要的区别是TCP是可靠传输的，UDP是不可靠传输的 。所以如果我们的发送消息之类的场景，因为你要确保用户的消息不会丢失，需要使用TCP协议。如果你是在进行视频聊天或者看直播，那你可以使用UDP协议，因为即使几个画面丢失了，对用户来说影响也不是很大。 TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。 TCP对应的协议和UDP对应的协议TCP对应的协议：（1） FTP：定义了文件传输协议，使用21端口。（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。UDP对应的协议：（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 4.TCP三次握手和四次挥手的全过程运输连接有三个阶段，即：连接建立、数据传送和连接释放。 TCP建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个TCP报文段。详见计算机网络（第七版谢希仁）238，240，218，219页。说是三次握手其实是不准确的，具体情况是一次握手过程中交换了三个报文，而并不是进行了三次握手，这有点像两个人见面进行一次握手时，他们的手上摇晃了三次，但这并非进行了三次握手。RFC937文档中有这样的描述：“three way（three message） handshake”。handshake使用的是单数而不是复数，表明只是一次握手。准确的译名应该是“三报文握手”。 三次握手(三报文握手)： 一个易于理解的图： 详细的图： 第一次握手：客户端发送SYN = 0[同步]包(seq[序号] = x)到服务器，并进入SYN_SEND 状态，等待服务器确认；第二次握手：服务器收到SYN包，必须确认客户的SYN[同步]（ACK = 1，ack = x + 1），同时自己也发送一个SYN包（SYN=1，seq=y），即SYN + ACK包，此时服务器进入SYN_RECV 状态；第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ACK = 1，seq = x + 1, ack = y + 1)，此包发送完毕，客户端和服务器进入ESTABLISHED 状态，完成三次握手。握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 四次挥手（四报文握手）： 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次挥手”。第一次挥手：主动关闭方发送一个FIN包（FIN = 1，seq = u），同时进入FIN-WAIT-1 阶段，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。第二次挥手：被动关闭方收到FIN包后，发送一个ACK（ACK = 1， seq = v， ack = u + 1）给对方，服务器为CLOSE-WAIT 状态，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。第三次挥手：被动关闭方发送一个FIN（FIN = 1， ACK = 1， seq = w， ack = u + 1），用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了，客户端进行到FIN-WAIT-2 阶段，服务器B进行到LAST-ACK 阶段。第四次挥手：主动关闭方收到FIN后，发送一个ACK（ACK = 1， seq = u + 1， ack = w + 1）给被动关闭方，确认序号为收到序号+1，客户端进到TIME-WAIT 状态，服务端关闭，在等待2MSL后，客户端关闭，至此，完成四次挥手。 注意： 在TIME-WAIT 状态，必须等待2MSL时间有两个理由。 第一，为了保证A发送的最后一个ACK报文段能够到达B。因为这个ACK报文段有可能丢失，如果在LAST-ACK状态的B收不到对方发送的FIN + ACK 报文段的确认，B会超时重传这个FIN + ACK 报文段，而 A就能在2MSL时间内收到这个重传的FIN + ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A 和 B都正常进入到CLOSED状态。 第二，防止“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中小时。这样就就可以使下一个新的连接中不会出现这种旧的连接请求报文段。 5.什么是窗口滑动协议，什么是快速重传，什么是拥塞避免，什么是慢启动？滑动窗口协议： 属于TCP协议中的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发送一个分组就停下来等待确认，所以该协议可以加速数据的传输，提高网络吞吐量。滑动窗口是接受数据端使用的窗口大小，用来告知发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的。 网络中的链路容量和交换结点中的缓存和处理机都有着工作的极限，当网络的需求超过它们的工作极限时，就出现了拥塞。拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。常用的方法就是： 慢开始、拥塞避免 快重传、快恢复 慢开始算法：先让拥塞窗口cwnd=1，然后每经过一个传输轮次（RTT），拥塞窗口 cwnd 就加倍，直到 cwnd = ssthresh（慢开始门限）拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。快重传：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器到期快恢复：把慢开始门限ssthresh减半，把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。参考博客：https://www.cnblogs.com/losbyday/p/5847041.html参考博客：https://blog.csdn.net/qq_37924084/article/details/78409096 6.当你输入域名访问一个网站的时候，背后的过程是什么？这个问题是比较开放的，你可以回答的内容有很多，但是你如果回答得越详细肯定是越好的。第一步就是域名解析，域名解析的话你可以说一下域名缓存在哪些地方，然后如果你域名在本地没有缓存的话，是如何通过DNS来进行域名解析的，如果你的DNS服务器上没有保存那个域名，那你的DNS服务器将如何处理来得到这个域名的ip。第二步就是说一下TCP连接的三次握手的过程。其他拓展内容有很多可以说，看你知识储备。例如你可以说通过CDN来进行访问加速。也可以说目前网站基本上都是前后端分离的，访问的时候会先访问反向代理服务器进行负载均衡之类的。 7.在浏览器中输入www.baidu.com后执行的全部过程1、客户端浏览器通过DNS解析到www.baidu.com 的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.181.27.48，然后通过TCP进行封装数据包，输入到网络层。2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 8.什么是https协议？https协议用到了哪种密钥？https是在http上面套了一层ssl，用来实现安全连接。用到的密钥有对称密钥和非对称密钥。目前基本上大一点的网站，都会使用https，这里面涉及的知识点也不是很多，但是过程相对来说会复杂一点，感兴趣的话可以去看一下。基本上就是有数字证书，然后把对称密钥作为消息内容，通过非对称密钥来进行传输。之后双方的通信就通过对称密钥来进行解密就行了。参考博客：https://www.cnblogs.com/zxj015/p/6530766.html 9.什么是socket？socket是用来进行网络通信的。TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样。TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。 为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了称为套接字 (Socket)的接口，区分不同应用程序进程间的网络通信和连接。 实际上socket是对TCP/IP协议的封装，它的出现只是使得程序员更方便地使用TCP/IP协议栈而已。socket本身并不是协议，它是应用层与TCP/IP协议族通信的中间软件抽象层，是一组调用接口 10.什么是IO，什么是NIO，什么是AIO，什么是netty框架？BIO：同步阻塞式IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。NIO：同步非阻塞式IO，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。AIO(NIO.2)：异步非阻塞式IO，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。Netty：Netty是一款异步的事件驱动的网络应用框架和工具，用于快速开发可维护的高性能、高扩展性协议服务器和客户端。也就是说，Netty是一个NIO客户端/服务器框架，支持快速、简单地开发网络应用，如协议服务器和客户端。它极大简化了网络编程，如TCP和UDP套接字服务器。 11.ARP是地址解析协议，简单语言解释一下工作原理 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。广播发送ARP请求，单播发送ARP响应。 13.从用户在浏览器输入域名，到浏览器显示出页面的过程https://blog.csdn.net/qq_22313585/article/details/78926141这篇文章写的比较详细 同时感谢朋友的博客提供的问题：https://lzh0108.site/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/#more]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux(CentOS下)更改终端命令行颜色及网络配置]]></title>
    <url>%2F2019%2F04%2F12%2FLinux-CentOS%E4%B8%8B-%E6%9B%B4%E6%94%B9%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%A2%9C%E8%89%B2%E5%8F%8A%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[测试环境：CentOS 7 修改CentOS命令行颜色以及配置网路总结。 1. 修改CentOS命令行颜色1.1. 用户命令行颜色修改：进入用户家目录，输入命令 1ls -al 然后，用vim或者vi编辑器打开.bash_profile文件，在文件最下方添加： 12# PS1PS1=&apos;\[\e[32;40m\][\u@\h\w]$&apos; 修改完输入命令 1source .bashrc 即可，这种方法可为每个用户定制登录颜色 1.2. 全用户命令行颜色修改：在root用户下登录，输入以下命令 1vi /etc/bashrc 接下来，修改方式相同，等于说只是换个目录打开全局配置文件修改即可，注意这个文件前面没有“.”。修改完输入命令 1source /etc/bashrc 注意： 也可以在 /etc/profile中输入 PS1=”\e[1;32m\u\e[m\e[1;33m@\e[m\e[1;35m\h\e[m:\w\$”，但是此时的效果只会自动在登陆用户上产生，而使用su命令切换到root用户时，命令提示符还是普通颜色，此时需要再输入一遍 source /etc/bashrc ，才能使root用户的命令提示符改变颜色。而将内容输入在 /etc/bashrc中的话，任何用户的命令提示符颜色都做了修改。 2. CentOS7网络配置2.1. 修改ip地址编辑 /etc/sysconfig/network-scripts/ ifcfg-eth33（具体名字按照具体网卡名来定） 12345678910111213141516171819TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=static #设置为静态ip（网卡获得ip地址的方式，默认为dhcp，表示自动获取）DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=5c609e8c-9a0c-4346-a2d7-825b5f890bcaDEVICE=ens33 #网卡对应的设备别名ONBOOT=yes #系统启动时是否激活此设备IPADDR=192.168.1.192 #设置ip地址NETMASK=255.255.255.0 #设置子网掩码 本配置也可以用 PREFIX=24 代替GATEWAY=192.168.1.1 #设置网关DNS1=8.8.8.8 #设置DNS地址，在这里设置后会同步到/etc/resolv.conf 文件中 接下来输入命令重启网卡： 1service network restart centos7的新增网卡重启方法： 1systemctl restart network 注意：配置文件中配置项的值（如static）不区分大小写，但是配置项的名字（如DNS1）区分大小写。小心出错。 2.2. 修改dns地址（在CentOS 7包括已知CentOS 6.7及以上不需设置此项）编辑/etc/resolv.conf修改文件内容如 1nameserver 114.114.114.114 注意：在 /etc/sysconfig/network-scripts/ ifcfg-eth33 中如果已经设置了ip地址，那么就不用设置此处，linux会自动完成同步。直接修改/etc/resolv.conf这个文件是没用的，网络服务重启以后会根据 /etc/sysconfig /network-scripts/ ifcfg-eth33来重载配置，如果ifcfg-eth0没有配置DNS，那么resolv.conf会被冲掉，重新变成空值。 常用dns地址 114.114.114.114114.114.114.114是国内移动、电信和联通通用的DNS，手机和电脑端都可以使用，干净无广告，解析成功率相对来说更高，国内用户使用的比较多，而且速度相对快、稳定，是国内用户上网常用的DNS 8.8.8.88.8.8.8是GOOGLE公司提供的DNS，该地址是全球通用的，相对来说，更适合国外以及访问国外网站的用户使用 223.5.5.5 阿里 223.6.6.6 阿里 180.76.76.76 百度 3. 其他另外附加常用配置软件位置：DNS配置文件：cat /etc/resolv.conf设置主机和IP绑定信息：cat /etc/hosts设置主机名：cat /etc/hostname 防火墙操作： 关闭防火墙并设置开机不启动查看防火墙状态：systemctl status firewalld.service关闭：systemctl stop firewalld开启：systemctl start firewalld开机自动关闭：systemctl disable firewalld开机自动启动：systemctl enable firewalld 查看开机是否启动：chkconfig –list|grep （要查询的应用）]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入分析ClassLoader工作机制]]></title>
    <url>%2F2019%2F04%2F11%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90ClassLoader%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[深入分析ClassLoader工作机制结合资料，自己的一些理解，分析JVM的类加载器工作机制。 1.java类的加载机制1.1 .什么是类的加载类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 ​ 类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没 有被程序主动使用，那么类加载器就不会报告错误。 加载.class文件的方式有： 从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件 1.2.类的生命周期 其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 Java中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对java来说，绑定分为静态绑定和动态绑定： 静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。 动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。 一. 加载：查找并加载类的二进制数据 加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情： 1. 通过一个类的全限定名来获取其定义的二进制字节流。 2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 3. 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。 ​ 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 ​ 加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。 二.连接: 验证：确保被加载的类的正确性 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备：为类的静态变量分配内存，并将其初始化为默认值 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： 这时候进行内存分配的仅包括类变量（static即静态变量），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。 举例： 假设一个类变量的定义为：public static int value = 3； 那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器 （） 方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 注意： 这里还需要注意如下几点： 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。 如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。 假设上面的类变量value被定义为： public static final int value = 3； 编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。回忆上一篇博文中对象被动引用的第2个例子，便是这种情况。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中 如果常量引用的是一个固定值，那么加不加static的效果是一样的，除非声明为public的公共常量，需要加上static，可以直接调用。 如果常量引用的是一个函数，或者其他对象的赋值，那么就必须加上static了，要不，你就为莫名其妙的错误而头大了。 final修饰的变量一旦初始化就不能被改变，但每次创建对象都会被初始化 。static final修饰的变量只能被初始化一次，而且一旦初始化就不能被改变。 所以在声明常量时，static+final可以更加保险，避免出现不必要的问题。 解析： 把类中的符号引用转换为直接引用解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 三.初始化初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式： ①声明类变量是指定初始值 ②使用静态代码块为类变量指定初始值 JVM初始化步骤: 假如这个类还没有被加载和连接，则程序先加载并连接该类 假如该类的直接父类还没有被初始化，则先初始化其直接父类 假如类中有初始化语句，则系统依次执行这些初始化语句 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： 创建类的实例，也就是new的方式 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如Class.forName(“com.shengsiyuan.Test”)） 初始化某个类的子类，则其父类也会被初始化 Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类 四.结束生命周期在如下几种情况下，Java虚拟机将结束生命周期 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 2.什么是ClassLoader？ClassLoader顾名思义就是类加载器。 2.1.作用： ClassLoader负责将Class加载到JVM中，他就好比开会对门口的接待员，负责给进入会场的不同等级嘉宾发放入会证明。 ClassLoader除了能将Class加载到JVM之中之外，还有一个重要的作用就是审核每个类应该由谁加载，它是一种父优先的等级加载机制。 ClassLoader将Class字节码重新解析成JVM统一要求的对象格式。 2.2.寻找类加载器先来一个小例子: 123456789package com.neo.classloader;public class ClassLoaderTest &#123; public static void main(String[] args) &#123; ClassLoader loader = Thread.currentThread().getContextClassLoader(); System.out.println(loader); System.out.println(loader.getParent()); System.out.println(loader.getParent().getParent()); &#125;&#125; 运行后，输出结果： 123sun.misc.Launcher$AppClassLoader@64fef26asun.misc.Launcher$ExtClassLoader@1ddd40f3null 从上面的结果可以看出，并没有获取到ExtClassLoader的父Loader，原因是Bootstrap Loader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。 这几种类加载器的层次关系如下图所示： 注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。 站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。 站在Java开发人员的角度来看， 2.3.类加载器可以大致划分为以下三类：启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。(JVM服务自身，独立：无父加载器，也无子加载器) 扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。（服务jvm员工会员，服务的特定目标在System.getProperty(“java.ext.dirs”）目录下) 应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。（服务普通会员，所有在System.getProperty(“java.class.path”）目录下的类都可以被这个类加载器加载，这个目录就是我们经常用到的classpath） 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器（父加载器为AppclassLoader，因为不管调用哪个父类构造器，创建的对象都必须最终调用getSystemClassLoader()作为父加载器。而getSystemClassLoader()方法获取到的正是AppClassLoader）。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点： 在执行非置信代码之前，自动验证数字签名。 动态地创建符合用户特定需要的定制化构建类。 从特定的场所取得java class，例如数据库中和网络中。 2.4.JVM类加载机制 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。 2.5.类加载的三种方式(两类方式)两类方式： 隐式加载：所谓隐式加载就是不通过在代码里调用ClassLoader来加载需要的类，而是通过JVM来自动加载需要的类到内存的方式。例如，当我们在类中继承或者引用某个类时，JVM在解析这个类时发现引用的类不在内存中，那么就会自动将这些类加载到内存中。 显式加载： 相反的显式加载就是我们在代码中通过调用ClassLoader类来加载个类一个类的方式，例如，调用this.getClass.getClassloader().loadClass()或者 Class.forName(),或者我们自己实现ClassLoader的findClass()方法等。 其实这两种方式是混合使用的，例如，我们通过自定义的ClassLoader显式加载一个类时，这个类中又引用了其他类，那么这些类就是隐式加载的。 常用的三种方式： 命令行启动应用时候由JVM初始化加载(隐式加载) 通过Class.forName()方法动态加载（显式加载） 通过ClassLoader.loadClass()方法动态加载（显式加载） 例子： 12345678910111213package com.neo.classloader;public class loaderTest &#123; public static void main(String[] args) throws ClassNotFoundException &#123; ClassLoader loader = HelloWorld.class.getClassLoader(); System.out.println(loader); //使用ClassLoader.loadClass()来加载类，不会执行初始化块 loader.loadClass("Test2"); //使用Class.forName()来加载类，默认会执行初始化块 // Class.forName("Test2"); //使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 // Class.forName("Test2", false, loader); &#125; &#125; demo类： 12345public class Test2 &#123; static &#123; System.out.println("静态初始化块执行了！"); &#125; &#125; 分别切换加载方式，会有不同的输出结果。 Class.forName()和ClassLoader.loadClass()区别： Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块； ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。 注： Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。 2.6.双亲委派模型双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 双亲委派机制: 1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载； 4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。 ClassLoader源码分析： 123public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; return loadClass(name, false); &#125; 12345678910111213141516171819202122232425262728293031323334353637383940protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; // 没有被加载，委托给父类加载或者委派给启动类加载器加载 long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //如果存在父类加载器，就委派给父类加载器加载 c = parent.loadClass(name, false); &#125; else &#123; //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name) c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; findClass源码：（jdk 1.8） 由于findClass没有进行实现，所以直接抛出没有找到类的异常。 123protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name); &#125; 双亲委派模型意义： 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行 JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。 2.7.ClassLoader类结构分析我们经常会用到或扩展ClassLoader,主要会用到如图6-1所示的几个方法，以及它们的重载方法。 defineClass方法：defineClass方法用来将byte字节流解析成JVM能够识别的Class对象，有了这个方法意味着我们不仅仅可以通过class文件实例化对象，还可以通过其他方式实例化对象，如我们通过网络接收到一个类的字节码，拿这个字节码流直接创建类的Class对象形式实例化对象。注意，如果直接调用这个方法生成类的Class对象，这个类的Class对象还没有resolve（解析，在Linking时进行，不是固定的）,这个resolve将会在这个对象真正实例化时才进行。 ​ defineClass通常是和findClass方法一起使用的，我们通过直接覆盖ClassLoader父类的findClass方法来实现类的加载规则，从而取得要加载类的字节码。然后调用defineClass方法生成类的Class对象，如果你想在类被加载到JVM中时就被链接(Link),那么可以接着调用另办一个 resolveClass方法(决定什么时候对类进行解析),当然你也可以选择让JVM来解决什么时候才链接这个类。 ​ 如果你不想重新定义加载类的规则，也没有复杂的处理逻辑，只想在运行时能够加载自己指定的一个类，那么你可以用 this.getClass().getClassLoader().loadClass(“class”)调用ClassLoader的loadClass方法以获取这个类的Class对象，这个loadClass还有重载方法，你同样可以决定在什么时候解析这个类。 ​ ClassLoader是个抽象类，它还有很多子类,我们如果要实现自己的ClassLoader，一般都会继承URLClassLoader这个字类，因为这个类已经帮我们实现了大部分工作，我们只需要在适当的地方做些修改就好了，就像我们要实现Servlet时通常会直接继HttpServlet —样 。 ​ 前面介绍的这几个方法都是我们在扩展ClassLoader时需要用到的，ClassLoader 还提供了 另外一些辅助方法， 如获取 class 文件的法 getResource ,getResourceAsStream 等，还有就是获取SystemClassLoader的方法等。 2.8.自定义类加载器通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可（在上面源码已经说明，在loadClass中未找到类最后会调用findClass方法）。下面我们通过一个示例来演示自定义类加载器的流程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.neo.classloader;import java.io.*;public class MyClassLoader extends ClassLoader &#123; private String root; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = loadClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] loadClassData(String className) &#123; String fileName = root + File.separatorChar + className.replace('.', File.separatorChar) + ".class"; try &#123; InputStream ins = new FileInputStream(fileName); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; int length = 0; while ((length = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, length); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; public String getRoot() &#123; return root; &#125; public void setRoot(String root) &#123; this.root = root; &#125; public static void main(String[] args) &#123; MyClassLoader classLoader = new MyClassLoader(); classLoader.setRoot("E:\\temp"); Class&lt;?&gt; testClass = null; try &#123; testClass = classLoader.loadClass("com.neo.classloader.Test2"); Object object = testClass.newInstance(); System.out.println(object.getClass().getClassLoader()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意： 这里传递的文件名需要是类的全限定性名称，即com.paddx.test.classloading.Test格式的，因为 defineClass 方法是按这种格式进行处理的。 最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。 这类Test 类本身可以被 AppClassLoader 类加载，因此我们不能把 com/paddx/test/classloading/Test.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由AppClassLoader 加载，而不会通过我们自定义类加载器来加载。 2.9.常见加载类错误分析 ClassNotFoundExecption ClassNotFoundExecption 异常是平常碰到的最多的。这个异常通常发生在显式加载类的时候。 12345678910public class ClassNotFoundExceptionTest&#123; public static void main(String[] args) &#123; try &#123; Class.forName("NotFoundClass"); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 显式加载一个类通常有： 通过类 Class 中的 forName() 方法 通过类 ClassLoader 中的 loadClass() 方法 通过类 ClassLoader 中的 findSystemClass() 方法 出现这种错误其实就是当 JVM 要加载指定文件的字节码到内存时，并没有找到这个文件对应的字节码，也就是这个文件并不存在。解决方法就是检查在当前的 classpath 目录下有没有指定的文件。 NoClassDefFoundError 在JavaDoc中对NoClassDefFoundError的产生可能的情况就是使用new关键字、属性引用某个类、继承了某个接口或者类，以及方法的某个参数中引用了某个类，这时就会触发JVM或者类加载器实例尝试加载类型的定义，但是该定义却没有找到，影响了执行路径。换句话说，在编译时这个类是能够被找到的，但是在执行时却没有找到。 解决这个错误的方法就是确保每个类引用的类都在当前的classpath下面。 UnsatisfiedLinkError 该错误通常是在 JVM 启动的时候，如果 JVM 中的某个 lib 删除了，就有可能报这个错误。 12345678910public class UnsatisfiedLinkErrorTest&#123; public native void nativeMethod(); static &#123; System.loadLibrary("NoLib"); &#125; public static void main(String[] args) &#123; new UnsatisfiedLinkErrorTest().nativeMethod(); //解析native标识的方法时JVM找不到对应的库文件 &#125;&#125; ClassCastException 该错误通常出现强制类型转换时出现这个错误。 123456789101112public class ClassCastExceptionTest&#123; public static Map m = new HashMap()&#123; &#123; put("a", "2"); &#125; &#125;; public static void main(String[] args) &#123; Integer integer = (Integer) m.get("a"); //将m强制转换成Integer类型 System.out.println(integer); &#125;&#125; 注意：JVM 在做类型转换时的规则： 对于普通对象，对象必须是目标类的实例或目标类的子类的实例。如果目标类是接口，那么会把它当作实现了该接口的一个子类。 对于数组类型，目标类必须是数组类型或 java.lang.Object、java.lang.Cloneable、java.io.Serializable。 如果不满足上面的规则，JVM 就会报错，有两种方式可避免错误： 在容器类型中显式的指明这个容器所包含的对象类型。 先通过 instanceof 检查是不是目标类型，然后再进行强制类型的转换。 ExceptionInInitializerError 12345678910public class ExceptionInInitializerErrorTest&#123; public static Map m = new HashMap()&#123;&#123; m.put("a", "2"); &#125;&#125;; public static void main(String[] args) &#123; Integer integer = (Integer) m.get("a"); System.out.println(integer); &#125;&#125; 在初始化这个类时，给静态属性 m 赋值时出现了异常导致抛出错误 ExceptionInInitializerError。 NoSuchMethodError NoSuchMethodError代表这个类型确实存在，但是一个不正确的版本被加载了。为了解决这个问题我们可以使用 ‘­verbose:class’ 来判断该JVM加载的到底是哪个版本。 LinkageError 有时候事情会变得更糟，和 ClassCastException 本质一样，加载自不同位置的相同类在同一段逻辑（比如：方法）中交互时，会出现 LinkageError 。 LinkageError 需要观察哪个类被不同的类加载器加载了，在哪个方法或者调用处发生（交汇）的，然后才能想解决方法，解决方法无外乎两种。第一，还是不同的类加载器加载，但是相互不再交汇影响，这里需要针对发生问题的地方做一些改动，比如更换实现方式，避免出现上述问题；第二，冲突的类需要由一个Parent类加载器进行加载。LinkageError 和ClassCastException 本质是一样的，加载自不同类加载器的类型，在同一个类的方法或者调用中出现，如果有转型操作那么就会抛 ClassCastException ，如果是直接的方法调用处的参数或者返回值解析，那么就会产生 LinkageError 。 （参考书籍以及博客： ​ 《深入分析javaweb技术内幕》， ​ 博客：http://blog.csdn.net/ns_code/article/details/17881581 ​ 博客：https://www.cnblogs.com/ityouknow/p/5603287.html ​ 博客: https://blog.csdn.net/coslay/article/details/40709921 ​ 博客：https://segmentfault.com/a/1190000008491597 ）]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种常用排序算法的总结]]></title>
    <url>%2F2019%2F03%2F27%2F%E5%90%84%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[各大常用排序算法总结排序算法为最基础,而有最常用的算法,下面列举了冒泡排序,选择排序,插入排序,快速排序.算法总结均为个人的理解,用于以后如果遗忘能够快速回忆. 1.冒泡排序思想:将需要排序的数组的n个元素看做一个个气泡,每次浮出一个最大的,需要浮出n - 1次(最后一个元素自然在正确的位置,不用进行排序).要想使得气泡可以浮出来,需要不断进行比较交换,将最大的气泡冒出来,需要比较n - 1次,每次进行一轮浮出就排好了一个元素,所以应把排好的数量减去.利用这样的双重for循环,就成功完成了排序. 改进:如果有一次排序中全程没有发生交换,说明顺序已经排好,不必在进行后续遍历了,设置标志位进行判断即可. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @author BestQiang */public class BubbleSort &#123; // 算法不允许产生任何实例 private BubbleSort() &#123; &#125; public static void sort1(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123;// 第一次for循环表示需要排序n - 1趟 for (int j = 0; j &lt; arr.length - i - 1; j++) &#123;// 第二次for循环表示需要进行n - 1次比较交换 if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; &#125; &#125; // 改进后的冒泡排序,设置标志k,当一次遍历中没有发生交换,说明已经完成所有排序,不必在进行后续遍历 public static void sort2(int arr[]) &#123; boolean k; for (int i = 0; i &lt; arr.length - 1; i++) &#123; k = false; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; k = true; &#125; &#125; if (!k) &#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] arr = new int[]&#123;10, 9, 8, 7, 6, 5, 4, 3, 2, 1&#125;; BubbleSort.sort7(arr); for (int i : arr) &#123; System.out.print(i); System.out.print(" "); &#125; &#125;&#125; 百度百科的介绍:冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。 它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。 这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。冒泡排序的时间复杂度为O(n^2),空间复杂度为O(1),它是一种稳定的排序算法。 2.选择排序思想:选择排序,就如它的名字一样,就是每次选择最小的,从第一个位置依次往后放置,就完成了排序.算法也简单,使用两个for循环,一个用来遍历位置,一个用来寻找最小的值.注意放置的时候不能直接赋值,这样会导致当前的值直接被覆盖,所以将当前位置的值与所找到的最小值进行交换即可,等待下一次挑选. 123456789101112131415161718192021222324252627282930313233343536373839package sort;/** * @author BestQiang */public class SelectionSort &#123; // 算法不允许产生任何实例 private SelectionSort() &#123; &#125; private static void sort(int arr[]) &#123; for (int i = 0; i &lt; arr.length; i ++) &#123; // 寻找当前排序位置以及之后最小值的坐标 int minIndex = i; for(int j = i + 1; j &lt; arr.length; j++) &#123; if(arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; // 找到后将这个坐标与当前的排序位置的坐标进行互换 swap(arr, i, minIndex); &#125; &#125; private static void swap(int[] arr, int i, int minIndex) &#123; int t = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = t; &#125; public static void main(String[] args) &#123; int[] arr = new int[]&#123;10, 9, 8, 7, 6, 5, 4, 3, 2, 1&#125;; SelectionSort.sort(arr); for (int i : arr) &#123; System.out.print(i); System.out.print(" "); &#125; &#125;&#125; 百度百科的介绍:选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。 3.插入排序思想:就像玩扑克牌一样,拿到第一张牌,然后第二张牌拿到后和第一张牌比较,放到合适的位置,依次类推,拿到一张新牌,把它插到手里已经排好的牌当中即可.将要排序的数组的元素比作牌,实现这个算法,首先要用一个for循环记录当前拿到的牌,然后再用一个for循环,用来将它和手中已经排好的牌进行比较,放到合适的位置即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package sort;/** * @author BestQiang */public class InsertSort &#123; // 我们的算法不允许产生任何实例 private InsertSort() &#123; &#125; public static void sort(Comparable[] arr) &#123; int n = arr.length; for (int i = 0; i &lt; n; i++) &#123; // 寻找元素arr[i]合适的插入位置 // 写法1 /*for (int j = i; j &gt; 0; j--) &#123; // 进行比较交换,一直到合适的位置 if(arr[j].compareTo(arr[j-1]) &lt; 0) &#123; Comparable tmp = arr[j]; arr[j] = arr[j -1]; arr[j-1] = tmp; &#125;else &#123; break; &#125; &#125;*/ // 写法2,将比较提到条件中 /*for (int j = i; j &gt; 0 &amp;&amp; arr[j].compareTo(arr[j-1]) &lt; 0; j--) &#123; Comparable tmp = arr[j]; arr[j] = arr[j -1]; arr[j-1] = tmp; &#125;*/ &#125; // 优化写法,省去不必要的交换 for (int i = 1; i &lt; n; i++) &#123; // 寻找元素arr[i]合适的插入位置 Comparable e = arr[i]; int j; // j保存元素e应该插入的位置 for (j = i; j &gt; 0 &amp;&amp; arr[j - 1].compareTo(e) &gt; 0; j--) &#123; // 找到后不需交换,直接赋值即可 arr[j] = arr[j - 1]; &#125; arr[j] = e; &#125; &#125; public static void main(String[] args) &#123; Integer[] arr = new Integer[]&#123;10, 9, 8, 7, 6, 5, 4, 3, 2, 1&#125;; InsertSort.sort(arr); for (int i : arr) &#123; System.out.print(i); System.out.print(" "); &#125; &#125;&#125; 百度百科的介绍:一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。 插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 4.快速排序思想:核心思想就是,找一个基准元素,通过一趟排序将数组中的元素分为两个部分,其中一部分比基准元素小,另外一部分比基准元素大,此时基准元素已经处于正确的位置了,然后再次递归调用,分别对左右两部分进行排序,以此达到整个序列有序.递归,使得算法变得简单. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package sort;/** * @author BestQiang */public class QuickSort &#123; // 我们的算法类不允许产生任何实例 private QuickSort() &#123; &#125; // 这是用于快速排序的调用 private static void sort(int[] arr) &#123; int n = arr.length; sort(arr, 0, n - 1); &#125; // 这是快速排序的主体实现 private static void sort(int[] arr, int l, int r) &#123; // 递归使用快速排序,对arr[l...r]的范围进行排序 // 设置终止条件 if (l &gt; r) &#123; return; &#125; // 获取基准点,并排序,使得基准点在正确的位置 int p = partition(arr, l, r); // 一次排好后,递归调用,再次对左右两边的元素分别进行排序 sort(arr, l, p - 1); sort(arr, p + 1, r); &#125; // 对arr[l...p-1] &lt; arr[p]; arr[p+1...r] &gt; arr[p] private static int partition(int[] arr, int l, int r) &#123; // 选取最左边的元素作为基准点,用于下面for循环中的比较 int v = arr[l]; // 设置j作为基准点位置返回值,此时默认值就是最左边的l int j = l; // arr[l+1...j] &lt; v arr[j+1,...i] &gt; v // 核心算法,从基准点初始值+1的位置比较,即l+1的位置,如果当前值比基准点要小,就 // 将基准点的位置加上1,然后将当前值与基准点位置互换(就相当于使基准点位置一直位于左边部分的尾部) // 就这样把元素遍历一遍之后,将基准点的值换到对应的位置即可(基准点的值一直在l位置,没有变) for (int i = l + 1; i &lt;= r; i++) &#123; if (arr[i] &lt; v) &#123; j++; swap(arr, j, i); &#125; &#125; swap(arr, l, j); return j; &#125; private static void swap(int[] arr, int j, int i) &#123; int tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp; &#125; public static void main(String[] args) &#123; int[] arr = new int[]&#123;10, 9, 8, 7, 6, 5, 4, 3, 2, 1&#125;; QuickSort.sort(arr); for (int i : arr) &#123; System.out.print(i); System.out.print(" "); &#125; &#125;&#125; 百度百科的介绍:快速排序（Quicksort）是对冒泡排序的一种改进。 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序的时间复杂度为O (nlogn).]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JWT授权和身份认证规范以及结合Zuul的鉴权流程]]></title>
    <url>%2F2019%2F03%2F23%2FJWT%E6%8E%88%E6%9D%83%E5%92%8C%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E8%A7%84%E8%8C%83%E4%BB%A5%E5%8F%8A%E7%BB%93%E5%90%88Zuul%E7%9A%84%E9%89%B4%E6%9D%83%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这次来谈谈:什么是无状态登录,如何实现呢?利用JWT进行的鉴权流程是如何的? 1.无状态登录原理1.1.什么是有状态？有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如tomcat中的session。 例如登录：用户登录后，我们把登录者的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session。然后下次请求，用户携带cookie值来，我们就能识别到对应session，从而找到用户的信息。 缺点是什么？ 服务端保存大量数据，增加服务端压力 服务端保存用户状态，无法进行水平扩展 客户端请求依赖服务端，多次请求必须访问同一台服务器 1.2.什么是无状态微服务集群中的每个服务，对外提供的都是Rest风格的接口。而Rest风格的一个最重要的规范就是：服务的无状态性，即： 服务端不保存任何客户端请求者信息 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 带来的好处是什么呢？ 客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务 服务端的集群和状态对客户端透明 服务端可以任意的迁移和伸缩 减小服务端存储压力 1.3.如何实现无状态无状态登录的流程： 当客户端第一次请求服务时，服务端对用户进行信息认证（登录） 认证通过，将用户信息进行加密形成token，返回给客户端，作为登录凭证 以后每次请求，客户端都携带认证的token 服务的对token进行解密，判断是否有效。 流程图： 整个登录过程中，最关键的点是什么？ token的安全性 token是识别客户端身份的唯一标示，如果加密不够严密，被人伪造那就完蛋了。 采用何种方式加密才是安全可靠的呢？ 我们将采用JWT + RSA非对称加密 2.JWT21.简介JWT，全称是Json Web Token， 是JSON风格轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权；官网：https://jwt.io GitHub上jwt的java客户端：https://github.com/jwtk/jjwt 22.数据格式JWT包含三部分数据： Header：头部，通常头部有两部分信息： 声明类型，这里是JWT 加密算法，自定义 我们会对头部进行base64加密（可解密），得到第一部分数据 Payload：载荷，就是有效数据，一般包含下面信息： 用户身份信息（注意，这里因为采用base64加密，可解密，因此不要存放敏感信息） 注册声明：如token的签发时间，过期时间，签发人等 这部分也会采用base64加密，得到第二部分数据 Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥（secret）（不要泄漏，最好周期性更换），通过加密算法生成。用于验证整个数据完整和可靠性 生成的数据格式： 可以看到分为3段，每段就是上面的一部分数据 2.3.JWT交互流程流程图： 步骤翻译： 1、用户登录 2、服务的认证，通过后根据secret生成token 3、将生成的token返回给用户 4、用户每次请求携带token 5、服务端利用公钥解读jwt签名，判断签名有效后，从Payload中获取用户信息 6、处理请求，返回响应结果 因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，完全符合了Rest的无状态规范。 2.4.非对称加密加密技术是对信息进行编码和解码的技术，编码是把原来可读信息（又称明文）译成代码形式（又称密文），其逆过程就是解码（解密），加密技术的要点是加密算法，加密算法可以分为三类： 对称加密，如AES 基本原理：将明文分成N个组，然后使用密钥对各个组进行加密，形成各自的密文，最后把所有的分组密文进行合并，形成最终的密文。 优势：算法公开、计算量小、加密速度快、加密效率高 缺陷：双方都使用同样密钥，安全性得不到保证 非对称加密，如RSA 基本原理：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端 私钥加密，持有私钥或公钥才可以解密 公钥加密，持有私钥才可解密 优点：安全，难以破解 缺点：算法比较耗时 不可逆加密，如MD5，SHA 基本原理：加密过程中不需要使用密钥，输入明文后由系统直接经过加密算法处理成密文，这种加密后的数据是无法被解密的，无法根据密文推算出明文。 RSA算法历史： 1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字缩写：RSA 3.结合Zuul的鉴权流程我们逐步演进系统架构设计。需要注意的是：secret是签名的关键，因此一定要保密，我们放到鉴权中心保存，其它任何服务中都不能获取secret。 3.1.没有RSA加密时在微服务架构中，我们可以把服务的鉴权操作放到网关中，将未通过鉴权的请求直接拦截，如图： 1、用户请求登录 2、Zuul将请求转发到授权中心，请求授权 3、授权中心校验完成，颁发JWT凭证 4、客户端请求其它功能，携带JWT 5、Zuul将jwt交给授权中心校验，通过后放行 6、用户请求到达微服务 7、微服务将jwt交给鉴权中心，鉴权同时解析用户信息 8、鉴权中心返回用户数据给微服务 9、微服务处理请求，返回响应 发现什么问题了？ 每次鉴权都需要访问鉴权中心，系统间的网络请求频率过高，效率略差，鉴权中心的压力较大。 PS(postscript): 1.为什么每次鉴权都要访问权限中心? 因为其他服务中不含有密钥,不能对JWT凭证进行校验,所以只能每个服务都向权限中心进行请求,导致全新中心负载过重. 2.那为什么所有请求都经过zuul,zuul已经对请求进行了权限验证,其他服务还要再次对请求进行权限验证呢? 正常情况下当然是每个请求都经过zuul,但是也可以不通过zuul,模拟http请求,直接访问其他微服务,这时等于跳过了zuul网关,如果不进行权限验证,不就可以直接通过微服务查询用户信息甚至帐号密码吗,所以,有这么一句话,前端的校验防君子不防小人,为了防止小人直接模拟请求想为非作歹,就要后台添加验证,所以后台验证是必不可少的. 3.2.结合RSA的鉴权直接看图： 我们首先利用RSA生成公钥和私钥。私钥保存在授权中心，公钥保存在Zuul和各个微服务 用户请求登录 授权中心校验，通过后用私钥对JWT进行签名加密 返回jwt给用户 用户携带JWT访问 Zuul直接通过公钥解密JWT，进行验证，验证通过则放行 请求到达微服务，微服务直接用公钥解析JWT，获取用户信息，无需访问授权中心 PS:为什么其他服务验证JWT凭证时不需要通过权限中心进行校验? 1.RSA采用非对称加密算法,也就是说私钥进行的加密可以被公钥和私钥(一般都用公钥)给解密,公钥的加密只能被私钥解密,所以这就好办了,前面Zuul和微服务都对授权中心发起请求进行校验,对Zuul进行校验是因为第一次要获取凭证,而其他次要验证凭证,对微服务校验是因为要防小人,确保通过的请求是进行授权过的. 而现在,只需第一次向授权中心请求获取token令牌,然后Zull和其他微服务通过公钥对令牌进行验证即可,不需要再对授权中心进行请求,而此时授权中心的私钥是安全的,不会泄漏,实现了对鉴权中心进行减负]]></content>
      <categories>
        <category>javaweb</category>
        <category>权限认证</category>
      </categories>
      <tags>
        <tag>权限认证</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于消息队列ActiveMQ那些事]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97ActiveMQ%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[1.ActiveMQActiveMQ与RabbitMQ的异同?使用方法?ActiveMQ与Spring整合? 1.1. 什么是ActiveMQActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现,尽管JMS规范出台已经是很久的事情了,但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。主要特点： 多种语言和协议编写客户端。语言: Java, C, C++, C#, Ruby, Perl, Python, PHP。应用协议: OpenWire,Stomp REST,WS Notification,XMPP,AMQP 完全支持JMS1.1和J2EE 1.4规范 (持久化,XA消息,事务) 对Spring的支持,ActiveMQ可以很容易内嵌到使用Spring的系统里面去,而且也支持Spring2.0的特性 通过了常见J2EE服务器(如 Geronimo,JBoss 4, GlassFish,WebLogic)的测试,其中通过JCA 1.5 resource adaptors的配置,可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上 支持多种传送协议:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA 支持通过JDBC和journal提供高速的消息持久化 从设计上保证了高性能的集群,客户端-服务器,点对点 支持Ajax 支持与Axis的整合 可以很容易得调用内嵌JMS provider,进行测试1.2 ActiveMQ的消息形式对于消息的传递有两种类型：一种是点对点的，即一个生产者和一个消费者一一对应；另一种是发布/订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。 · StreamMessage – Java原始值的数据流 · MapMessage–一套名称-值对 · TextMessage–一个字符串对象 · ObjectMessage–一个序列化的 Java对象 · BytesMessage–一个字节的数据流2. ActiveMQ的安装进入http://activemq.apache.org/下载ActiveMQ 使用的版本是5.12.0使用的版本是5.12.0 2.1 安装环境：1、需要jdk2、安装Linux系统。生产环境都是Linux系统。 2.2 安装步骤第一步： 把ActiveMQ 的压缩包上传到Linux系统。第二步：解压缩。第三步：启动。使用bin目录下的activemq命令启动：[root@localhost bin]# ./activemq start关闭：[root@localhost bin]# ./activemq stop查看状态：[root@localhost bin]# ./activemq status 注意：如果ActiveMQ整合spring使用不要使用activemq-all-5.12.0.jar包。建议使用5.11.2 进入管理后台：http://192.168.25.168:8161/admin用户名：admin密码：admin 2.3.解决405问题：修改hosts文件，配置机器名和127.0.0.1的映射关系。机器名：/etc/sysconfig/network文件中定义了机器名： tHost文件的配置： q重新启动Activemq的服务 3.ActiveMQ的使用方法 3.1 Queue3.1.1. Producer生产者：生产消息，发送端。把jar包添加到工程中。使用5.11.2版本的jar包。第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。第二步：使用ConnectionFactory对象创建一个Connection对象。第三步：开启连接，调用Connection对象的start方法。第四步：使用Connection对象创建一个Session对象。第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。第六步：使用Session对象创建一个Producer对象。第七步：创建一个Message对象，创建一个TextMessage对象。第八步：使用Producer对象发送消息。第九步：关闭资源。 1234567891011121314151617181920212223242526272829@Test public void testQueueProducer() throws Exception &#123; // 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。 //brokerURL服务器的ip及端口号 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.25.168:61616"); // 第二步：使用ConnectionFactory对象创建一个Connection对象。 Connection connection = connectionFactory.createConnection(); // 第三步：开启连接，调用Connection对象的start方法。 connection.start(); // 第四步：使用Connection对象创建一个Session对象。 //第一个参数：是否开启事务。true：开启事务，第二个参数忽略。 //第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。 //参数：队列的名称。 Queue queue = session.createQueue("test-queue"); // 第六步：使用Session对象创建一个Producer对象。 MessageProducer producer = session.createProducer(queue); // 第七步：创建一个Message对象，创建一个TextMessage对象。 /*TextMessage message = new ActiveMQTextMessage(); message.setText("hello activeMq,this is my first test.");*/ TextMessage textMessage = session.createTextMessage("hello activeMq,this is my first test."); // 第八步：使用Producer对象发送消息。 producer.send(textMessage); // 第九步：关闭资源。 producer.close(); session.close(); connection.close(); &#125; 3.1.2. Consumer消费者：接收消息。第一步：创建一个ConnectionFactory对象。第二步：从ConnectionFactory对象中获得一个Connection对象。第三步：开启连接。调用Connection对象的start方法。第四步：使用Connection对象创建一个Session对象。第五步：使用Session对象创建一个Destination对象。和发送端保持一致queue，并且队列的名称一致。第六步：使用Session对象创建一个Consumer对象。第七步：接收消息。第八步：打印消息。第九步：关闭资源 1234567891011121314151617181920212223242526272829303132333435363738@Test public void testQueueConsumer() throws Exception &#123; // 第一步：创建一个ConnectionFactory对象。 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.25.168:61616"); // 第二步：从ConnectionFactory对象中获得一个Connection对象。 Connection connection = connectionFactory.createConnection(); // 第三步：开启连接。调用Connection对象的start方法。 connection.start(); // 第四步：使用Connection对象创建一个Session对象。 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 第五步：使用Session对象创建一个Destination对象。和发送端保持一致queue，并且队列的名称一致。 Queue queue = session.createQueue("test-queue"); // 第六步：使用Session对象创建一个Consumer对象。 MessageConsumer consumer = session.createConsumer(queue); // 第七步：接收消息。 consumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; try &#123; TextMessage textMessage = (TextMessage) message; String text = null; //取消息的内容 text = textMessage.getText(); // 第八步：打印消息。 System.out.println(text); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); //等待键盘输入 System.in.read(); // 第九步：关闭资源 consumer.close(); session.close(); connection.close(); &#125; 3.2. Topic3.2.1. Producer 使用步骤：第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。第二步：使用ConnectionFactory对象创建一个Connection对象。第三步：开启连接，调用Connection对象的start方法。第四步：使用Connection对象创建一个Session对象。第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Topic对象。第六步：使用Session对象创建一个Producer对象。第七步：创建一个Message对象，创建一个TextMessage对象。第八步：使用Producer对象发送消息。第九步：关闭资源。 12345678910111213141516171819202122232425262728293031@Test public void testTopicProducer() throws Exception &#123; // 第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。 // brokerURL服务器的ip及端口号 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.25.168:61616"); // 第二步：使用ConnectionFactory对象创建一个Connection对象。 Connection connection = connectionFactory.createConnection(); // 第三步：开启连接，调用Connection对象的start方法。 connection.start(); // 第四步：使用Connection对象创建一个Session对象。 // 第一个参数：是否开启事务。true：开启事务，第二个参数忽略。 // 第二个参数：当第一个参数为false时，才有意义。消息的应答模式。1、自动应答2、手动应答。一般是自动应答。 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个topic对象。 // 参数：话题的名称。 Topic topic = session.createTopic("test-topic"); // 第六步：使用Session对象创建一个Producer对象。 MessageProducer producer = session.createProducer(topic); // 第七步：创建一个Message对象，创建一个TextMessage对象。 /* * TextMessage message = new ActiveMQTextMessage(); message.setText( * "hello activeMq,this is my first test."); */ TextMessage textMessage = session.createTextMessage("hello activeMq,this is my topic test"); // 第八步：使用Producer对象发送消息。 producer.send(textMessage); // 第九步：关闭资源。 producer.close(); session.close(); connection.close(); &#125; 3.2.2. Consumer消费者：接收消息。第一步：创建一个ConnectionFactory对象。第二步：从ConnectionFactory对象中获得一个Connection对象。第三步：开启连接。调用Connection对象的start方法。第四步：使用Connection对象创建一个Session对象。第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。第六步：使用Session对象创建一个Consumer对象。第七步：接收消息。第八步：打印消息。第九步：关闭资源 123456789101112131415161718192021222324252627282930313233343536373839@Test public void testTopicConsumer() throws Exception &#123; // 第一步：创建一个ConnectionFactory对象。 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.25.168:61616"); // 第二步：从ConnectionFactory对象中获得一个Connection对象。 Connection connection = connectionFactory.createConnection(); // 第三步：开启连接。调用Connection对象的start方法。 connection.start(); // 第四步：使用Connection对象创建一个Session对象。 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。 Topic topic = session.createTopic("test-topic"); // 第六步：使用Session对象创建一个Consumer对象。 MessageConsumer consumer = session.createConsumer(topic); // 第七步：接收消息。 consumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; try &#123; TextMessage textMessage = (TextMessage) message; String text = null; // 取消息的内容 text = textMessage.getText(); // 第八步：打印消息。 System.out.println(text); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); System.out.println("topic的消费端03。。。。。"); // 等待键盘输入 System.in.read(); // 第九步：关闭资源 consumer.close(); session.close(); connection.close(); &#125; 4. Activemq整合spring4.1. 使用方法第一步：引用相关的jar包。 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; 第二步：配置Activemq整合spring。配置ConnectionFactory 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.168:61616" /&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory" /&gt; &lt;/bean&gt;&lt;/beans&gt; 第三步：配置生产者。使用JMSTemplate对象。发送消息。第四步：在spring容器中配置Destination。 ​12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.168:61616" /&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory" /&gt; &lt;/bean&gt; &lt;!-- 配置生产者 --&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 --&gt; &lt;bean id="queueDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg&gt; &lt;value&gt;spring-queue&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!--这个是主题目的地，一对多的 --&gt; &lt;bean id="topicDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="topic" /&gt; &lt;/bean&gt;&lt;/beans&gt; 第五步：代码测试 12345678910111213141516171819@Test public void testSpringActiveMq() throws Exception &#123; //初始化spring容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring/applicationContext-activemq.xml"); //从spring容器中获得JmsTemplate对象 JmsTemplate jmsTemplate = applicationContext.getBean(JmsTemplate.class); //从spring容器中取Destination对象 Destination destination = (Destination) applicationContext.getBean("queueDestination"); //使用JmsTemplate对象发送消息。 jmsTemplate.send(destination, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; //创建一个消息对象并返回 TextMessage textMessage = session.createTextMessage("spring activemq queue message"); return textMessage; &#125; &#125;); &#125; 4.2. 代码测试4.2.1 发送消息第一步：初始化一个spring容器第二步：从容器中获得JMSTemplate对象。第三步：从容器中获得一个Destination对象第四步：使用JMSTemplate对象发送消息，需要知道Destination 123456789101112131415161718@Test public void testQueueProducer() throws Exception &#123; // 第一步：初始化一个spring容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring/applicationContext-activemq.xml"); // 第二步：从容器中获得JMSTemplate对象。 JmsTemplate jmsTemplate = applicationContext.getBean(JmsTemplate.class); // 第三步：从容器中获得一个Destination对象 Queue queue = (Queue) applicationContext.getBean("queueDestination"); // 第四步：使用JMSTemplate对象发送消息，需要知道Destination jmsTemplate.send(queue, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; TextMessage textMessage = session.createTextMessage("spring activemq test"); return textMessage; &#125; &#125;); &#125; 4.2.2 接收消息search-Service中接收消息。第一步：把Activemq相关的jar包添加到工程中第二步：创建一个MessageListener的实现类。 12345678910111213141516public class MyMessageListener implements MessageListener &#123; @Override public void onMessage(Message message) &#123; try &#123; TextMessage textMessage = (TextMessage) message; //取消息内容 String text = textMessage.getText(); System.out.println(text); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 第三步：配置spring和Activemq整合。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供 --&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.168:61616" /&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory" /&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 --&gt; &lt;bean id="queueDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg&gt; &lt;value&gt;spring-queue&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!--这个是主题目的地，一对多的 --&gt; &lt;bean id="topicDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="topic" /&gt; &lt;/bean&gt; &lt;!-- 接收消息 --&gt; &lt;!-- 配置监听器 --&gt; &lt;bean id="myMessageListener" class="cn.e3mall.search.listener.MyMessageListener" /&gt; &lt;!-- 消息监听容器 --&gt; &lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="queueDestination" /&gt; &lt;property name="messageListener" ref="myMessageListener" /&gt; &lt;/bean&gt;&lt;/beans&gt; 第四步：测试代码。 1234567@Test public void testQueueConsumer() throws Exception &#123; //初始化spring容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:spring/applicationContext-activemq.xml"); //等待 System.in.read(); &#125;]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于消息队列RabbitMQ的那些事]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[1.消息队列（MQ）关于消息队列那点事 1.1什么是消息队列消息队列，即MQ，Message Queue。 1.2 AMQP和JMSMQ是消息通信的模型，并不是具体实现。现在实现MQ的有两种主流方式：AMQP、JMS。 正如上图所说,队列的使用除去了接受和发送应用程序同时执行的要求,消息队列是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。两者间的区别和联系： JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式 JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。 JMS规定了两种消息模型；而AMQP的消息模型更加丰富 JMS更适合于java服务之间的应用通信,而AMQP可以跨语言通信,消息模型更加丰富,在javaweb的开发中,构建springcloud应用的时用到了消息队列,springcloud传递了微服务这个概念,也许不同的服务是由不同的语言进行实现,AMQP这个消息队列协议更加适合一些. 1.3 常见MQ产品 ActiveMQ：基于JMS RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好 RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会 Kafka：分布式消息系统，高吞吐量 其中RabbitMQ,稳定性较好,是一个开源的,基于AMQP协议的完整的可复用的企业消息系统,支持主流的操作系统,Linux,Windows,MacOs等.支持多种开发语言官网： http://www.rabbitmq.com/ 官方教程：http://www.rabbitmq.com/getstarted.html 2.五种消息模型2.1.基本消息模型RabbitMQ提供了6种消息模型，但是第6种其实是RPC，并不是MQ，因此不予学习。那么也就剩下5种。 但是其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。RabbitMQ是一个消息代理：它接受和转发消息。 你可以把它想象成一个邮局：当你把邮件放在邮箱里时，你可以确定邮差先生最终会把邮件发送给你的收件人。 在这个比喻中，RabbitMQ是邮政信箱，邮局和邮递员。 RabbitMQ与邮局的主要区别是它不处理纸张，而是接受，存储和转发数据消息的二进制数据块。P（producer/ publisher）：生产者，一个发送消息的用户应用程序。 C（consumer）：消费者，消费和接收有类似的意思，消费者是一个主要用来等待接收消息的用户应用程序 队列（红色区域）：rabbitmq内部类似于邮箱的一个概念。虽然消息流经rabbitmq和你的应用程序，但是它们只能存储在队列中。队列只受主机的内存和磁盘限制，实质上是一个大的消息缓冲区。许多生产者可以发送消息到一个队列，许多消费者可以尝试从一个队列接收数据。 总之： 生产者将消息发送到队列，消费者从队列中获取消息，队列是存储消息的缓冲区。 我们将用Java编写两个程序;发送单个消息的生产者，以及接收消息并将其打印出来的消费者。我们将详细介绍Java API中的一些细节，这是一个消息传递的“Hello World”。 我们将调用我们的消息发布者（发送者）Send和我们的消息消费者（接收者）Recv。发布者将连接到RabbitMQ，发送一条消息，然后退出。 2.2.work消息模型 工作队列或者竞争消费者模式在第一篇教程中，我们编写了一个程序，从一个命名队列中发送并接受消息。在这里，我们将创建一个工作队列，在多个工作者之间分配耗时任务。 工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多工人时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。 这个概念在Web应用程序中特别有用，因为在短的HTTP请求窗口中无法处理复杂的任务。 接下来我们来模拟这个流程： ​ P：生产者：任务的发布者 ​ C1：消费者，领取任务并且完成任务，假设完成速度较快 ​ C2：消费者2：领取任务并完成任务，假设完成速度慢 面试题：避免消息堆积？ 1） 采用workqueue，多个消费者监听同一队列。 2）接收到消息以后，而是通过线程池，异步消费。 2.3.订阅模型分类前面2个案例中，只有3个角色： P：生产者，也就是要发送消息的程序 C：消费者：消息的接受者，会一直等待消息到来。 queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。 而在订阅模型中，多了一个exchange角色，而且过程略有变化： P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机） C：消费者，消息的接受者，会一直等待消息到来。 Queue：消息队列，接收消息、缓存消息。 Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型： Fanout：广播，将消息交给所有绑定到交换机的队列 Direct：定向，把消息交给符合指定routing key 的队列 Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！ 2.3.订阅模型-FanoutFanout，也称为广播。 流程说明 流程图：在广播模式下，消息发送流程是这样的： 1） 可以有多个消费者 2） 每个消费者有自己的queue（队列） 3） 每个队列都要绑定到Exchange（交换机） 4） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。 5） 交换机把消息发送给绑定过的所有队列 6） 队列的消费者都能拿到消息。实现一条消息被多个消费者消费 2.4.订阅模型-Direct说明 在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。 在Direct模型下： 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key） 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。 Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息 流程图：图解： P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。 X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列 C1：消费者，其所在队列指定了需要routing key 为 error 的消息 C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息 2.5.订阅模型-Topic说明 Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！ Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert 通配符规则： ​ #：匹配一个或多个词 ​ *：匹配不多不少恰好1个词 举例： ​ audit.#：能够匹配audit.irs.corporate 或者 audit.irs ​ audit.*：只能匹配audit.irs 图示：解释： 红色Queue：绑定的是usa.# ，因此凡是以 usa.开头的routing key 都会被匹配到 黄色Queue：绑定的是#.news ，因此凡是以 .news结尾的 routing key 都会被匹配 例子2： 在这个例子中，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“..”。 我们创建了三个绑定：Q1绑定了绑定键“ .orange.”，Q2绑定了“..rabbit”和“lazy.＃”。 Q1匹配所有的橙色动物。 Q2匹配关于兔子以及懒惰动物的消息。 练习，生产者发送如下消息，会进入那个队列： quick.orange.rabbit Q1 Q2 lazy.orange.elephant Q1 Q2 quick.orange.fox Q1 lazy.pink.rabbit Q2 quick.brown.fox 不匹配任意队列，被丢弃 quick.orange.male.rabbit 不匹配任意队列，被丢弃 orange 不匹配任意队列，被丢弃 3.持久化如何避免消息丢失？ 1） 消费者的ACK机制。可以防止消费者丢失消息。 2） 但是，如果在消费者消费之前，MQ就宕机了，消息就没了。 是可以将消息进行持久化呢？ 要将消息持久化，前提是：队列、Exchange都持久化 交换机持久化 队列持久化 消息持久化 消费者的消息确认机制(Acknowlage)消息一旦被消费者接收，队列中的消息就会被删除。 那么问题来了：RabbitMQ怎么知道消息被接收了呢？ 这就要通过消息确认机制（Acknowlege）来实现了。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况： 自动ACK：消息一旦被接收，消费者自动发送ACK 手动ACK：消息接收后，不会发送ACK，需要手动调用 大家觉得哪种更好呢？ 这需要看消息的重要性： 如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便 如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。我们之前的测试都是自动ACK的，如果要手动ACK，需要改动我们的代码： 123456789101112131415161718192021222324252627public class Recv2 &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 创建通道 final Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [x] received : " + msg + "!"); // 手动进行ACK channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; // 监听队列，第二个参数false，手动进行ACK channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; 注意到最后一行代码： 1channel.basicConsume(QUEUE_NAME, false, consumer); 如果第二个参数为true，则会自动进行ACK；如果为false，则需要手动ACK。方法的声明： 能者多劳刚才的实现有问题吗？ 消费者1比消费者2的效率要低，一次任务的耗时较长 然而两人最终消费的消息数量是一样的 消费者2大量时间处于空闲状态，消费者1一直忙碌 现在的状态属于是把任务平均分配，正确的做法应该是消费越快的人，消费的越多。 怎么实现呢？ 我们可以修改设置，让消费者同一时间只接收一条消息，这样处理完成之前，就不会接收更多消息，就可以让处理快的人，接收更多消息 ：再次测试： 以上原生方法语句较为复杂,日常使用为springboot整合,自动配置的代码. 4.Spring AMQP4.1.简介Sprin有很多不同的项目，其中就有对AMQP的支持：Spring AMQP的页面：http://projects.spring.io/spring-amqp/注意这里一段描述：Spring-amqp是对AMQP协议的抽象实现，而spring-rabbit 是对协议的具体实现，也是目前的唯一实现。底层使用的就是RabbitMQ。 4.2.依赖和配置添加AMQP的启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 在application.yml中添加RabbitMQ地址： 123456spring: rabbitmq: host: 192.168.1.102 username: test password: test virtual-host: /test 4.3.监听者在SpringAmqp中，对消息的消费者进行了封装和抽象，一个普通的JavaBean中的普通方法，只要通过简单的注解，就可以成为一个消费者。 123456789101112131415@Componentpublic class Listener &#123; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "spring.test.queue", durable = "true"), exchange = @Exchange( value = "spring.test.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC ), key = &#123;"#.#"&#125;)) public void listen(String msg)&#123; System.out.println("接收到消息：" + msg); &#125;&#125; @Componet：类上的注解，注册到Spring容器 @RabbitListener：方法上的注解，声明这个方法是一个消费者方法，需要指定下面的属性： bindings：指定绑定关系，可以有多个。值是@QueueBinding的数组。@QueueBinding包含下面属性： value：这个消费者关联的队列。值是@Queue，代表一个队列 exchange：队列所绑定的交换机，值是@Exchange类型 key：队列和交换机绑定的RoutingKey 类似listen这样的方法在一个类中可以写多个，就代表多个消费者。 4.4.AmqpTemplateSpring最擅长的事情就是封装，把他人的框架进行封装和整合。 Spring为AMQP提供了统一的消息处理模板：AmqpTemplate，非常方便的发送消息，其发送方法： 红框圈起来的是比较常用的3个方法，分别是： 指定交换机、RoutingKey和消息体 指定消息 指定RoutingKey和消息，会向默认的交换机发送消息 4.5.测试代码123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = Application.class)public class MqDemo &#123; @Autowired private AmqpTemplate amqpTemplate; @Test public void testSend() throws InterruptedException &#123; String msg = "hello, Spring boot amqp"; this.amqpTemplate.convertAndSend("spring.test.exchange","a.b", msg); // 等待10秒后再结束 Thread.sleep(10000); &#125;&#125; 运行后查看日志:至此,Spring AMQP 成功使用. 4.6.配置文件完善发送方application.yml配置:我们在application.yml中添加一些有关RabbitMQ的配置： 1234567891011121314spring: rabbitmq: host: 192.168.1.103 username: test password: test virtual-host: /test template: retry: enabled: true initial-interval: 10000ms max-interval: 300000ms multiplier: 2 exchange: test.item.exchange publisher-confirms: true template：有关AmqpTemplate的配置 retry：失败重试 enabled：开启失败重试 initial-interval：第一次重试的间隔时长 max-interval：最长重试间隔，超过这个间隔将不再重试 multiplier：下次重试间隔的倍数，此处是2即下次重试间隔是上次的2倍 exchange：缺省的交换机名称，此处配置后，发送消息如果不指定交换机就会使用这个 publisher-confirms：生产者确认机制，确保消息会正确发送，如果发送失败会有错误回执，从而触发重试 完善接受方application.yml配置: 123456spring: rabbitmq: host: 192.168.56.101 username: test password: test virtual-host: /test 这里只是接收消息而不发送，所以不用配置template相关内容。 4.7 测试查看RabbitMQ控制台 重新启动项目，并且登录RabbitMQ管理界面：http://192.168.1.103:15672 可以看到，交换机已经创建出来了,队列也已经创建完毕,并且队列都已经绑定到交换机 ## 特别感谢:传智播客]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好世界]]></title>
    <url>%2F2019%2F03%2F17%2F%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[初次见面,多多指教123public static void main(String[] args) &#123; System.out.pringln("Hello world!");&#125;]]></content>
      <categories>
        <category>你好</category>
        <category>世界</category>
      </categories>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
</search>
