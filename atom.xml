<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我就是BestQiang</title>
  
  <subtitle>活着就是为了改变世界，难道还有其他原因吗？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-28T03:57:17.638Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BestQiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Guava Caches和Guava ListenableFuture学习</title>
    <link href="http://yoursite.com/2020/07/27/Guava-Caches%E5%92%8CGuava-ListenableFuture%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/27/Guava-Caches和Guava-ListenableFuture学习/</id>
    <published>2020-07-27T11:37:46.000Z</published>
    <updated>2020-07-28T03:57:17.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Guava是什么"><a href="#1-Guava是什么" class="headerlink" title="1.Guava是什么?"></a>1.Guava是什么?</h2><p>Guava是Google的一组核心Java库，其中包括新的集合类型（例如多图和多集），不可变的集合，图形库以及用于并发，I / O，哈希，缓存，原语，字符串等的实用程序！它广泛用于Google的大多数Java项目中，也被许多其他公司广泛使用。</p><p>它的github地址为: <a href="https://github.com/google/guava" target="_blank" rel="noopener">https://github.com/google/guava</a></p><p>本次主要参照官方文档,对项目中用到的guava caches和guava listenableFuture进行了学习.</p><a id="more"></a><h2 id="2-Guava-Caches"><a href="#2-Guava-Caches" class="headerlink" title="2.Guava Caches"></a>2.Guava Caches</h2><h3 id="2-1-为什么要用Guava-Caches"><a href="#2-1-为什么要用Guava-Caches" class="headerlink" title="2.1.为什么要用Guava Caches?"></a>2.1.为什么要用Guava Caches?</h3><p>基于内存的高速本地缓存在各种情况下都很用,我们在编程开发时,一定使用过HashMap或ConcurrentMap对数据进行过缓存.Guava Caches就与ConcurrentMap比较相似,最根本的区别就是ConcurrentMap会保存添加到其中的所有元素，直到调用代码将其明确删除为止。而Guava Caches则可以对存储的元素进行管理和剔除，以限制其内存占用量,而且它提供了<code>LoadingCache</code>，进行缓存的自动加载，非常的方便。</p><p>在官方文档上这样介绍Guava:</p><p>Generally, the Guava caching utilities are applicable whenever:</p><ul><li>You are willing to spend some memory to improve speed.</li><li>You expect that keys will sometimes get queried more than once.</li><li>Your cache will not need to store more data than what would fit in RAM. (Guava caches are <strong>local</strong> to a single run of your application. They do not store data in files, or on outside servers. If this does not fit your needs, consider a tool like <a href="http://memcached.org/" target="_blank" rel="noopener">Memcached</a>.)</li></ul><p>If each of these apply to your use case, then the Guava caching utilities could be right for you!</p><p>当然如果不需要Guava Caches的这些特性,那么ConcurrentHashMap的内存效率更高——但是用任何旧的ConcurrentMap来复制大多数Guava Cahces的特性是极其困难或不可能的(官网都这么说了,有现成的那就用吧).</p><h3 id="2-2-Guava-Caches的学习和使用"><a href="#2-2-Guava-Caches的学习和使用" class="headerlink" title="2.2.Guava Caches的学习和使用"></a>2.2.Guava Caches的学习和使用</h3><p>首先把Guava的包引进来</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--guava--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>29.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-1-创建缓存和获取缓存基本用法"><a href="#2-2-1-创建缓存和获取缓存基本用法" class="headerlink" title="2.2.1.创建缓存和获取缓存基本用法"></a>2.2.1.创建缓存和获取缓存基本用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, String&gt; graphs = CacheBuilder.newBuilder()</span><br><span class="line">                .maximumSize(<span class="number">1</span>)</span><br><span class="line">                .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">                .build(</span><br><span class="line">                        <span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">                            <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                <span class="keyword">return</span> getRealCache(s); <span class="comment">// 这个方法可以自己写</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br></pre></td></tr></table></figure><p>代码中的build中出现了CacheLoader这个东西,他的用处意思就是设置一个默认的方法,在取值的时候如果key对应的value不存在,那么就用这个方法获取value然后自动进行设置.当然我们也可以直接用<code>graphs.put(k,v)</code>来进行缓存的添加,但是建议用CacheLoader来自动加载设置缓存,可以保证缓存加载的统一性.</p><p>当我们不想用默认的CacheLoader来进行缓存加载时,我们可以在获取缓存时指定方法对默认加载方法进行覆盖,它使用原子性的“ get-if-absent-compute”语义，传递 <code>Callable</code>给<code>get</code>调用,此方法为常规的“如果已缓存，则返回；否则创建，缓存并返回”模式提供了简单的替代方法。如下面代码所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String noCacheValueCallable = graphs.get(<span class="string">"helloCallable"</span>, () -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"helloCallableValue:Callable"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">log.info(<span class="string">"获取不存在的缓存调用Callable进行加载: &#123;&#125;"</span>, noCacheValueCallable);</span><br></pre></td></tr></table></figure><p><strong>其他API简单列举:</strong></p><ul><li><p><strong>get:</strong> 要么返回已经缓存的值，要么使用CacheLoader向缓存原子地加载新值；</p></li><li><p><strong>getUnchecked:</strong> CacheLoader 会抛异常，定义的CacheLoader没有声明任何检查型异常，则可以 getUnchecked 查找缓存；<strong>反之不能；</strong></p></li><li><p><strong>getAll:</strong> 方法用来执行批量查询；</p></li><li><p><strong>put:</strong> 向缓存显式插入值，Cache.asMap()也能修改值，但不具原子性；</p></li><li><p><strong>getIfPresent:</strong> 该方法只是简单的把Guava Cache当作Map的替代品，不执行load方法；</p></li></ul><h4 id="2-2-2-清除key"><a href="#2-2-2-清除key" class="headerlink" title="2.2.2.清除key:"></a>2.2.2.清除key:</h4><p>我们几乎可以肯定没有足够的内存来缓存我们可以缓存的所有内容.所以必须决定：什么情况下不值得保留缓存对?Guava Caches提供了三种缓存清除类型:</p><ul><li>基于大小的清除</li><li>基于时间的清除</li><li>基于引用的清除</li></ul><p><strong>基于大小的清除:</strong></p><p>使用<a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#maximumSize-long-" target="_blank" rel="noopener"><code>CacheBuilder.maximumSize(long)</code></a>进行设置,缓存将清除最近没有使用或者不经常使用的缓存.值得注意的是,缓存会在这个数值接近设置值的时候就对缓存进行清除.除此之外,也可以用<a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#weigher-com.google.common.cache.Weigher-" target="_blank" rel="noopener"><code>CacheBuilder.weigher(Weigher)</code></a>来设置权重函数来进行清除的规则设置.</p><p>直接贴上一个伪代码帮助理解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder()</span><br><span class="line">       .maximumWeight(<span class="number">100000</span>)</span><br><span class="line">       .weigher(<span class="keyword">new</span> Weigher&lt;Key, Graph&gt;() &#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">weigh</span><span class="params">(Key k, Graph g)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> g.vertices().size();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">       .build(</span><br><span class="line">           <span class="keyword">new</span> CacheLoader&lt;Key, Graph&gt;() &#123;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> Graph <span class="title">load</span><span class="params">(Key key)</span> </span>&#123; <span class="comment">// no checked exception</span></span><br><span class="line">               <span class="keyword">return</span> createExpensiveGraph(key);</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><p><strong>基于时间的清除:</strong></p><ul><li><a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#expireAfterAccess-long-java.util.concurrent.TimeUnit-" target="_blank" rel="noopener"><code>expireAfterAccess(long, TimeUnit)</code></a>仅在自从上次通过读取或写入访问条目以来经过指定的持续时间后，条目才到期。请注意，逐出条目的顺序将类似于<a href="https://github.com/google/guava/wiki/CachesExplained#Size-based-Eviction" target="_blank" rel="noopener">基于大小的逐出</a>。</li><li><a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#expireAfterWrite-long-java.util.concurrent.TimeUnit-" target="_blank" rel="noopener"><code>expireAfterWrite(long, TimeUnit)</code></a>自创建条目以来经过指定的时间或该值的最新替换之后，使条目过期。如果经过一定时间后缓存的数据过时，则可能需要这样做。</li></ul><p>请注意: 定时到期是在写入过程中进行定期维护的，偶尔在读取过程中进行维护,并不是实时的哦.</p><p><strong>基于引用的清除:</strong></p><p>Guava允许您设置缓存，以通过对键或值使用<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/ref/WeakReference.html" target="_blank" rel="noopener">弱引用，</a>对值使用<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/ref/SoftReference.html" target="_blank" rel="noopener">软引用</a>来对条目进行垃圾回收。</p><ul><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#weakKeys--" target="_blank" rel="noopener"><code>CacheBuilder.weakKeys()</code></a>使用弱引用存储密钥。如果没有其他（强或软）键引用，则可以垃圾回收条目。由于垃圾回收仅取决于身份相等性，因此导致整个缓存使用身份（<code>==</code>）相等性来比较键，而不是<code>equals()</code>。</li><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#weakValues--" target="_blank" rel="noopener"><code>CacheBuilder.weakValues()</code></a>使用弱引用存储值。如果没有其他（强或软）值引用，则可以垃圾回收这些条目。由于垃圾回收仅取决于身份相等性，因此这导致整个缓存使用身份（<code>==</code>）相等性来比较值，而不是<code>equals()</code>。</li><li><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#softValues--" target="_blank" rel="noopener"><code>CacheBuilder.softValues()</code></a>将值包装在软引用中。<em>响应内存需求</em>，以全局最近最少使用的方式<em>对</em>软引用的对象进行垃圾回收。由于使用软引用会对性能产生影响，因此我们通常建议使用更可预测的<a href="https://github.com/google/guava/wiki/CachesExplained#Size-based-Eviction" target="_blank" rel="noopener">最大高速缓存大小</a>。使用<code>softValues()</code>会导致使用identity（<code>==</code>）相等而不是来比较值<code>equals()</code>。</li></ul><p><strong>其他的清除 API:</strong></p><p>guava cache 自带 清除机制，但仍旧可以手动清除：</p><ul><li><p>个别清除：Cache.invalidate(key)</p></li><li><p>批量清除：Cache.invalidateAll(keys)</p></li><li><p>清除所有缓存项：Cache.invalidateAll()</p></li></ul><p><strong>缓存清除的监听器:</strong></p><p>可以通过<a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/CacheBuilder.html#removalListener-com.google.common.cache.RemovalListener-" target="_blank" rel="noopener"><code>CacheBuilder.removalListener(RemovalListener)</code></a>为缓存指定删除侦听器，以便在删除条目时执行某些操作。向 <a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/RemovalListener.html" target="_blank" rel="noopener"><code>RemovalListener</code></a>传递一个<a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/RemovalNotification.html" target="_blank" rel="noopener"><code>RemovalNotification</code></a>，其中指定了 <a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/cache/RemovalCause.html" target="_blank" rel="noopener"><code>RemovalCause</code></a>、键和值。</p><p>注意，RemovalListener抛出的任何异常都会被记录(使用日志记录器)并被吞噬。</p><p>然后直接上一下我写的一个测试用例代码,Guava Caches的最基本的使用就在这块代码里了,通过代码可以更直观的看到缓存的基本操作用法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.guava.cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheLoader;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.LoadingCache;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GuavaCacheStudyTest</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> bestqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/27 10:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaCacheStudyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGuavaCaches</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        LoadingCache&lt;String, String&gt; graphs = CacheBuilder.newBuilder()</span><br><span class="line">                .maximumSize(<span class="number">1</span>)</span><br><span class="line">                .removalListener((cache) -&gt; &#123;</span><br><span class="line">                    log.info(<span class="string">"key为&#123;&#125;,value为&#123;&#125;的缓存被清除了..."</span>, cache.getKey(), cache.getValue());</span><br><span class="line">                &#125;)</span><br><span class="line">                .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">                .build(</span><br><span class="line">                        <span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">                            <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                <span class="keyword">return</span> getRealCache(s);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">        <span class="comment">// 可以直接用put,但是建议使用自动缓存加载,这样可以保证缓存加载的统一性</span></span><br><span class="line">        graphs.put(<span class="string">"hello"</span>, <span class="string">"helloValue"</span>);</span><br><span class="line">        String hello = graphs.get(<span class="string">"hello"</span>);</span><br><span class="line">        log.info(<span class="string">"获取已有的缓存: &#123;&#125;"</span>, hello);</span><br><span class="line"></span><br><span class="line">        String noCacheValue = graphs.get(<span class="string">"helloCacheLoader"</span>);</span><br><span class="line">        log.info(<span class="string">"获取不存在的缓存会自动调用load进行加载: &#123;&#125;"</span>, noCacheValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get时指定加载方法</span></span><br><span class="line">        String noCacheValueCallable = graphs.get(<span class="string">"helloCallable"</span>, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"helloCallableValue:Callable"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(<span class="string">"获取不存在的缓存调用Callable进行加载: &#123;&#125;"</span>, noCacheValueCallable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getRealCache</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">":RealCache"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">21</span>:<span class="number">07</span>:<span class="number">23</span>.<span class="number">631</span> INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest:<span class="number">38</span> say: 获取已有的缓存: helloValue</span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">21</span>:<span class="number">07</span>:<span class="number">23</span>.<span class="number">699</span> INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest:<span class="number">26</span> say: key为hello,value为helloValue的缓存被清除了...</span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">21</span>:<span class="number">07</span>:<span class="number">23</span>.<span class="number">700</span> INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest:<span class="number">41</span> say: 获取不存在的缓存会自动调用load进行加载: helloCacheLoader:RealCache</span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">21</span>:<span class="number">07</span>:<span class="number">23</span>.<span class="number">701</span> INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest:<span class="number">26</span> say: key为helloCacheLoader,value为helloCacheLoader:RealCache的缓存被清除了...</span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">21</span>:<span class="number">07</span>:<span class="number">23</span>.<span class="number">701</span> INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest:<span class="number">47</span> say: 获取不存在的缓存调用Callable进行加载: helloCallableValue:Callable</span><br></pre></td></tr></table></figure><p><strong>应该什么时候进行缓存清理:</strong></p><p>使用CacheBuilder构建的缓存不会“自动”执行清理和逐出值，也不会在值过期后立即执行此类操作。相反，它在写操作期间执行少量维护，或者在偶尔的读操作(如果写操作很少)期间执行少量维护。</p><p>这样做的原因如下:如果我们想要持续地执行缓存维护，我们将需要创建一个线程，而它的操作将与用户操作竞争共享锁。此外，一些环境限制线程的创建，这将使CacheBuilder在该环境中不可用。</p><p>相反，我们把选择权放在你的手中。如果您的缓存是高吞吐量的，那么您就不必担心执行缓存维护来清除过期的条目等等。如果您的缓存写入很少，并且您不希望清理阻塞缓存读取，您可能希望创建自己的维护线程，定期调用cache.cleanup()。</p><p>如果您想为很少写入的缓存安排常规的缓存维护，只需使用ScheduledExecutorService来安排维护。</p><p>总结就是一句话:高吞吐量不用担心,缓存在写入或读取的时候就会自动完成清理操作.如果缓存的写操作很少,不希望清理操作阻塞缓存读取,那么开一个线程定期调用cache.cleanup()进行缓存清理就ok.</p><p><strong>Refresh操作:</strong></p><p><code>CacheBuilder.refreshAfterWrite(1, TimeUnit.MINUTES)</code> 刷新操作,对于刷新不完全等同于清除。如LoadingCache.refresh(K)中所指定的,刷新一个键将为该键加载一个新值,可能是异步操作的.在键值刷新时,仍然返回旧的值(如果有的话),不会阻塞.这与清除相反,清除的话会进行强制检索等待,直到重新加载该值然后返回.如果在刷新时抛出异常,则保留旧值,并记录并排除异常.CacheLoader可以通过覆盖CacheLoader来指定刷新时使用的特定方法 reload(K, V).</p><p>举一个简单的测试用例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRefresh</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    LoadingCache&lt;String, String&gt; graphs = CacheBuilder.newBuilder()</span><br><span class="line">            .maximumSize(<span class="number">10</span>)</span><br><span class="line">            .removalListener((cache) -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"key为&#123;&#125;,value为&#123;&#125;的缓存被清除了..."</span>, cache.getKey(), cache.getValue());</span><br><span class="line">            &#125;)</span><br><span class="line">            .refreshAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">            .build(</span><br><span class="line">                    <span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.info(<span class="string">"load进行重新加载key为: "</span> + s + <span class="string">" 的value"</span>);</span><br><span class="line">                            <span class="keyword">return</span> getRealCache(s);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> ListenableFuture&lt;String&gt; <span class="title">reload</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">                            log.info(<span class="string">"reload进行重新加载key为: "</span> + key + <span class="string">" 的value"</span>);</span><br><span class="line">                            ListenableFutureTask&lt;String&gt; task = ListenableFutureTask.create(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> <span class="string">"刷新方法异步执行了,key为: "</span> + key;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                            <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">                            <span class="keyword">return</span> task;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;);</span><br><span class="line">    String key1 = graphs.get(<span class="string">"key1"</span>);</span><br><span class="line">    String key2 = graphs.get(<span class="string">"key2"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    String key11 = graphs.get(<span class="string">"key1"</span>);<span class="comment">// 此时符合缓存刷新条件,缓存会进行刷新</span></span><br><span class="line">    log.info(key1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">020</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">15</span>.<span class="number">641</span> INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest$<span class="number">1</span>:<span class="number">36</span> say: load进行重新加载key为: key1 的value</span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">15</span>.<span class="number">658</span> INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest$<span class="number">1</span>:<span class="number">36</span> say: load进行重新加载key为: key2 的value</span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">17</span>.<span class="number">659</span> INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest$<span class="number">1</span>:<span class="number">40</span> say: reload进行重新加载key为: key1 的value</span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">17</span>.<span class="number">877</span> INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest:<span class="number">30</span> say: key为key1,value为key1:RealCache的缓存被清除了...</span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">17</span>.<span class="number">881</span> INFO [main] com.bestqiang.guava.cache.GuavaCacheStudyTest:<span class="number">55</span> say: key1:RealCache</span><br></pre></td></tr></table></figure><p>那么,我们在真实使用时用expire还是refresh呢?其实我们应该都用,这样，当缓存对符合刷新条件时，就不会盲目重置缓存对上的过期计时器，如果缓存对在符合刷新条件后没有查询，那么就让它过期。</p><h3 id="2-3-统计"><a href="#2-3-统计" class="headerlink" title="2.3.统计:"></a>2.3.统计:</h3><p><strong>CacheBuilder.recordStats()用来开启Guava Cache的统计功能</strong>。统计打开后Cache.stats()方法返回如下统计信息：</p><ul><li>hitRate()：缓存命中率；</li><li>hitMiss(): 缓存失误率；</li><li>loadcount() ; 加载次数；</li><li>averageLoadPenalty()：加载新值的平均时间，单位为纳秒；</li><li>evictionCount()：缓存项被回收的总数，不包括显式清除。</li></ul><p>唯一值得注意的一点是：<strong>当通过asmap（）方法查询key时，stat项是不作任何变化的</strong>，修改值时会有影响。此外，还有其他很多统计信息。这些统计信息对于调整缓存设置是至关重要的，在性能监控时可以依据的重要指标。</p><p><strong>此外关于asmap还有几点注意事项:</strong></p><p>您可以使用它的asMap视图将任何缓存看作是一个ConcurrentMap，但是asMap视图如何与缓存交互需要一些解释。</p><ul><li><code>cache.asMap()</code>包含当前在缓存中加载的所有条目。因此，例如，<code>cache.asMap().keySet()</code>包含所有当前加载的键。</li><li><code>asMap().get(key)</code>本质上等效于<code>cache.getIfPresent(key)</code>，并且从不导致值被加载。这与<code>Map</code> 合同一致。</li><li>所有缓存读取和写入操作（包括<code>Cache.asMap().get(Object)</code>和<code>Cache.asMap().put(K, V)</code>）都会重置访问时间，但不会通过 <code>containsKey(Object)</code>，也不会通过对的集合视图进行的操作来重置访问时间 <code>Cache.asMap()</code>。因此，例如，遍历 <code>cache.asMap().entrySet()</code>不会重置您检索的条目的访问时间。</li></ul><h2 id="3-ListenableFuture"><a href="#3-ListenableFuture" class="headerlink" title="3.ListenableFuture"></a>3.ListenableFuture</h2><h3 id="3-1-为什么要用ListenableFuture"><a href="#3-1-为什么要用ListenableFuture" class="headerlink" title="3.1.为什么要用ListenableFuture?"></a>3.1.为什么要用ListenableFuture?</h3><p><strong>官方文档这样介绍它:</strong></p><p>并发是一个<em>困难的</em>问题，但是通过使用功能强大且简单的抽象可以大大简化并发。为了简化问题，Guava使用扩展<code>Future</code>了JDK 的 接口<a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/ListenableFuture.html" target="_blank" rel="noopener"><code>ListenableFuture</code></a>。</p><p><strong>强烈建议您始终使用<code>ListenableFuture</code>而不是<code>Future</code> 在所有代码中使用</strong>，因为：</p><ul><li>大多数<code>Futures</code>方法都需要它。</li><li>这比更改为<code>ListenableFuture</code>以后要容易。</li><li>实用方法提供商将不再需要提供<code>Future</code>与 <code>ListenableFuture</code>他们的方法变种。</li></ul><p>其实它就是jdk的Future的一个扩展,在Java8里,汲取了Guava ListenableFuture的优点,CompleteFuture类诞生了.ListenableFuture在项目用到了,在这里主要简单看一下如何去使用它,之后如果有新的需求,可以尝试使用CompleteFuture来完成.</p><h3 id="3-2-ListenableFuture的学习和使用"><a href="#3-2-ListenableFuture的学习和使用" class="headerlink" title="3.2.ListenableFuture的学习和使用"></a>3.2.ListenableFuture的学习和使用</h3><p><code>ListenableFuture</code>比原始的<code>Future</code>其实就是增加了一个回调操作,在执行完成后可以增加<code>listener</code>对执行进行监听,执行完毕后执行对应的方法,或者使用<code>Futures.addCallback</code>对不同的执行结果进行监听操作,根据执行结果的不同来进行不同的操作.</p><p>官方操作文档:  <a href="https://github.com/google/guava/wiki/ListenableFutureExplained" target="_blank" rel="noopener">https://github.com/google/guava/wiki/ListenableFutureExplained</a> (操作相对全面,建议以此为准,但是测试用例有时不是很清晰)</p><p>对于这个工具方法的学习参考了博客: <a href="https://www.jianshu.com/p/9c57aa5e34af" target="_blank" rel="noopener">https://www.jianshu.com/p/9c57aa5e34af</a> (说的比较通俗一点,下面的文章的测试用例和总结参考这篇博客)</p><h4 id="3-2-1-创建和使用ListenableFuture的方法"><a href="#3-2-1-创建和使用ListenableFuture的方法" class="headerlink" title="3.2.1.创建和使用ListenableFuture的方法"></a>3.2.1.创建和使用ListenableFuture的方法</h4><ul><li>使用create方法返回实例,这种就是简单的创建一个task,然后添加一个监听,当task执行完毕后监听执行后续方法,真实使用执行task的时候一定要用线程池,这里为了测试方便直接新开了一个线程执行task.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//ListenableFutureTask通过静态create方法返回实例，还有一个重载方法，不太常用</span></span><br><span class="line">        ListenableFutureTask&lt;String&gt; task = ListenableFutureTask.create(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"任务执行完毕"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动任务(当然,这里为了测试方便,真实使用要用线程池)</span></span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        <span class="comment">// 增加回调方法，MoreExecutors.directExecutor()返回guava默认的Executor，</span></span><br><span class="line">        <span class="comment">// 执行回调方法不会新开线程，所有回调方法都在当前线程做(可能是主线程或者执行ListenableFutureTask的线程，具体可以看最后面的代码)。</span></span><br><span class="line">        <span class="comment">// guava异步模块中参数有Executor的方法，一般还会有一个没有Executor参数的重载方法，使用的就是MoreExecutors.directExecutor()</span></span><br><span class="line">        task.addListener(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@SneakyThrows</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.info(task.get());</span><br><span class="line">                log.info(<span class="string">"回调方法执行"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, MoreExecutors.directExecutor());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//MoreExecutors.directExecutor()源码，execute方法就是直接运行，没有新开线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Executor <span class="title">directExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DirectExecutor.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> DirectExecutor implements Executor &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">            command.run();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MoreExecutors.directExecutor()"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">28</span> <span class="number">10</span>:<span class="number">54</span>:<span class="number">33.350</span> INFO [main] com.bestqiang.guava.future.ListenableFutureStudyTest$<span class="number">2</span>:<span class="number">61</span> say: 任务执行完毕</span><br><span class="line"><span class="number">2020</span>-<span class="number">07</span>-<span class="number">28</span> <span class="number">10</span>:<span class="number">54</span>:<span class="number">33.356</span> INFO [main] com.bestqiang.guava.future.ListenableFutureStudyTest$<span class="number">2</span>:<span class="number">62</span> say: 回调方法执行</span><br></pre></td></tr></table></figure><ul><li>使用guava对ExecutorService的增强来创建线程池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//真正干活的线程池</span></span><br><span class="line">ThreadPoolExecutor poolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">5</span>,</span><br><span class="line">        <span class="number">5</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>),</span><br><span class="line">        <span class="keyword">new</span> CustomizableThreadFactory(<span class="string">"demo"</span>),</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"><span class="comment">//guava的接口ListeningExecutorService继承了jdk原生ExecutorService接口，重写了submit方法，修改返回值类型为ListenableFuture</span></span><br><span class="line">ListeningExecutorService listeningExecutor = MoreExecutors.listeningDecorator(poolExecutor);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得一个随着jvm关闭而关闭的线程池，通过Runtime.getRuntime().addShutdownHook(hook)实现</span></span><br><span class="line"><span class="comment">//修改ThreadFactory为创建守护线程，默认jvm关闭时最多等待120秒关闭线程池，重载方法可以设置时间</span></span><br><span class="line">ExecutorService newPoolExecutor = MoreExecutors.getExitingExecutorService(poolExecutor);</span><br><span class="line"></span><br><span class="line"><span class="comment">//只增加关闭线程池的钩子，不改变ThreadFactory</span></span><br><span class="line">MoreExecutors.addDelayedShutdownHook(poolExecutor, <span class="number">120</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>其实就是调用工具类将原生ExecutorService进行转换,线程池进行submit时,会返回ListenableFuture对象.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//像线程池提交任务，并得到ListenableFuture</span></span><br><span class="line">ListenableFuture&lt;String&gt; listenableFuture = listeningExecutor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//可以通过addListener对listenableFuture注册回调，但是通常使用Futures中的工具方法</span></span><br><span class="line">Futures.addCallback(listenableFuture, <span class="keyword">new</span> FutureCallback&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Futures.addCallback源码，其实就是包装了一层addListener，可以不加executor参数，使用上文说的DirectExecutor</span></span><br><span class="line"><span class="comment"> * 需要说明的是不加Executor的情况，只适用于轻型的回调方法，如果回调方法很耗时占资源，会造成线程阻塞</span></span><br><span class="line"><span class="comment"> * 因为DirectExecutor有可能在主线程中执行回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="function"><span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(<span class="keyword">final</span> ListenableFuture&lt;V&gt; future, <span class="keyword">final</span> FutureCallback&lt;? <span class="keyword">super</span> V&gt; callback, Executor executor)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(callback);</span><br><span class="line">    Runnable callbackListener =</span><br><span class="line">            <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">final</span> V value;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        value = getDone(future);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                        callback.onFailure(e.getCause());</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                        callback.onFailure(e);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">                        callback.onFailure(e);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    callback.onSuccess(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    future.addListener(callbackListener, executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-异步操作链"><a href="#3-2-2-异步操作链" class="headerlink" title="3.2.2.异步操作链"></a>3.2.2.异步操作链</h4><p>使用<code>ListenableFuture</code>最重要的原因是,它可以拥有复杂的异步操作链,方便我们进行链式调用.</p><p>不用异步操作链,用<code>addListener</code>进行实现可以是这样:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ListenableFutureTask&lt;String&gt; task1 = ListenableFutureTask.create(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> Thread(task1).start();</span><br><span class="line">task1.addListener(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListenableFutureTask&lt;String&gt; task2 = ListenableFutureTask.create(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        task2.addListener(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, MoreExecutors.directExecutor());</span><br><span class="line">        <span class="keyword">new</span> Thread(task2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, MoreExecutors.directExecutor());</span><br></pre></td></tr></table></figure><p>上述代码,其实就是一层监听器套一层,实现了链式调用.使用Guava的异步链式调用,可以用两个API简单的实现:</p><ul><li><p><a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Futures.html#transformAsync-com.google.common.util.concurrent.ListenableFuture-com.google.common.util.concurrent.AsyncFunction-java.util.concurrent.Executor-" target="_blank" rel="noopener"><code>transformAsync(ListenableFuture, AsyncFunction, Executor)</code></a></p></li><li><p><a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Futures.html#transform-com.google.common.util.concurrent.ListenableFuture-com.google.common.base.Function-java.util.concurrent.Executor-" target="_blank" rel="noopener"><code>transform(ListenableFuture, Function, Executor)</code></a></p></li></ul><p>上述两个API的区别顾名思义就是一个异步链式调用一个同步链式调用.</p><p>还有两个API也比较常用,可以对ListenableFuture进行批量的处理:</p><ul><li><p><a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Futures.html#allAsList-java.lang.Iterable-" target="_blank" rel="noopener"><code>allAsList(Iterable&gt;)</code></a> 对多个ListenableFuture的合并，返回一个当所有Future成功时返回多个Future返回值组成的List对象。注：当其中一个Future失败或者取消的时候，将会进入失败或者取消。</p></li><li><p><a href="https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/util/concurrent/Futures.html#successfulAsList-java.lang.Iterable-" target="_blank" rel="noopener"><code>successfulAsList(Iterable&gt;)</code></a> 和allAsList相似，唯一差别是对于失败或取消的Future返回值用null代替。不会进入失败或者取消流程。</p></li></ul><p>具体的链式调用代码可以参考下面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当task1执行完毕会回调执行Function的apply方法，如果有task1有异常抛出，则task2也抛出相同异常，不执行apply</span></span><br><span class="line">ListenableFuture&lt;String&gt; task2 = Futures.transform(task1, <span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;String&gt; task3 = Futures.transform(task2, <span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//处理最终的异步任务</span></span><br><span class="line">Futures.addCallback(task3, <span class="keyword">new</span> FutureCallback&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码Futures.transform()和Futures.addCallback()都是对addListener做了封装,进行回调的设置,但是transform更适合用在链式处理的中间过程,addCallback更适合用在处理最终的结果上.另外,它们的参数都是可以带上线程池的.具体的使用根据情况来定吧.</p><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4.结语"></a>4.结语</h2><p>Guava的特性还有很多,这里主要结合官方文档,对Caches和ListenableFuture进行了学习,方便大家快速了解入门,建议大家学习时多去github看看官方文档,以官方文档为准,可以少走弯路.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Guava是什么&quot;&gt;&lt;a href=&quot;#1-Guava是什么&quot; class=&quot;headerlink&quot; title=&quot;1.Guava是什么?&quot;&gt;&lt;/a&gt;1.Guava是什么?&lt;/h2&gt;&lt;p&gt;Guava是Google的一组核心Java库，其中包括新的集合类型（例如多图和多集），不可变的集合，图形库以及用于并发，I / O，哈希，缓存，原语，字符串等的实用程序！它广泛用于Google的大多数Java项目中，也被许多其他公司广泛使用。&lt;/p&gt;
&lt;p&gt;它的github地址为: &lt;a href=&quot;https://github.com/google/guava&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/google/guava&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本次主要参照官方文档,对项目中用到的guava caches和guava listenableFuture进行了学习.&lt;/p&gt;
    
    </summary>
    
      <category term="Guava" scheme="http://yoursite.com/categories/Guava/"/>
    
    
      <category term="Guava" scheme="http://yoursite.com/tags/Guava/"/>
    
  </entry>
  
  <entry>
    <title>关于@Autowired注入空指针问题的解决</title>
    <link href="http://yoursite.com/2019/09/19/%E5%85%B3%E4%BA%8E-Autowired%E6%B3%A8%E5%85%A5%E7%A9%BA%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2019/09/19/关于-Autowired注入空指针问题的解决/</id>
    <published>2019-09-19T15:25:29.000Z</published>
    <updated>2020-07-27T09:25:36.686Z</updated>
    
    <content type="html"><![CDATA[<p>如果对Spring的生命周期掌握的不熟,遇到此类问题那就难办啦!</p><a id="more"></a><p>今天做项目的时候遇到一个问题，需要将线程池的参数抽取到yml文件里进行设置。这不是so easy吗？于是我就写出了下面这样的代码进行抽取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"thread-pool"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCorePoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> corePoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaximumPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maximumPoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaximumPoolSize</span><span class="params">(<span class="keyword">int</span> maximumPoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getKeepAliveTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keepAliveTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeepAliveTime</span><span class="params">(<span class="keyword">long</span> keepAliveTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = keepAliveTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCapacity</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bestqiang.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.bestqiang.pojo.ThreadPool;</span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.ThreadFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Yaqiang Chen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ThreadPool threadPool1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                threadPool1.getCorePoolSize(),</span><br><span class="line">                threadPool1.getMaximumPoolSize(),</span><br><span class="line">                threadPool1.getKeepAliveTime(),</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(threadPool1.getCapacity()),</span><br><span class="line">                namedThreadFactory,</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">            .setNameFormat(<span class="string">"pool-%d"</span>).build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span></span>&#123;</span><br><span class="line">        threadPool.submit(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在yml文件的配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">thread-pool:</span></span><br><span class="line"><span class="attr">  core-pool-size:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  maximum-pool-size:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">  keep-alive-time:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  capacity:</span> <span class="number">1024</span></span><br></pre></td></tr></table></figure><p>本想应该毫无问题，但是，报错了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating bean with name <span class="string">'myThreadUtils'</span> <span class="function">defined in <span class="title">fileXXXXXXXXXX</span><span class="params">(省略)</span></span></span><br><span class="line"><span class="function">Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [cn.itcast.util.MyThreadUtils]: Constructor threw exception</span>; nested exception is java.lang.NullPointerException</span><br><span class="line">Caused by: java.lang.NullPointerException: <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>空指针异常？检查好几遍配置没错。因为公司开发环境没法上网，只好拖到下班googel了一下，结合我比较深厚的基础（自恋一下），问题轻松解决：</p><p><img src="/2019/09/19/关于-Autowired注入空指针问题的解决/1568907769222.png" alt="1568907769222"></p><p>这就是答案。上面说所有的Spring的@Autowired注解都在构造函数之后，而如果一个对象像下面代码一样声明（private XXX = new XXX() 直接在类中声明）的话，成员变量是在构造函数之前进行初始化的，甚至可以作为构造函数的参数。 即     <strong>成员变量初始化 -&gt; Constructor -&gt; @Autowired</strong> </p><p>所以，在这个时候如果成员变量初始化时调用了利用@Autowired注解初始化的对象时，必然会报空指针异常的啊。</p><p>真相大白了。如果解决呢？那就让上面我写的代码的成员变量threadPool在@Autowired之后执行就好了。</p><p>要想解决这个问题，首先要知道@Autowired的原理：<br>AutowiredAnnotationBeanPostProcessor 这个类</p><p><img src="/2019/09/19/关于-Autowired注入空指针问题的解决/1568909007648.png" alt="1568909007648"></p><p><img src="/2019/09/19/关于-Autowired注入空指针问题的解决/1568909114572.png" alt="1568909114572"></p><p>其实看到这个继承结构，我心中已经有解决办法了。具体详细为什么，等997的工作结束（无奈）我会在后续博客里将Spring的注解配置详细的捋一遍，到时候会讲到Bean的生命周期的。</p><p>继承的BeanFactoryAware是在属性赋值完成，执行构造方法后,postProcessBeforeInitialization才执行,而且,是在其他生命周期之前，而@Autowired注解就是依靠这个原理进行的自动注入。想要解决这个问题很简单，就是把要赋值的成员变量放到其他生命周期中就可以。</p><p>下面介绍其中两种办法，第一种JSR250的@PostConstruct</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里放要执行的赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是Spring的InitializingBean(定义初始化逻辑) ，继承接口实现方法即可，这种直接放上完整用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Yaqiang Chen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadUtils</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ThreadPool threadPool1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ExecutorService threadPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">            .setNameFormat(<span class="string">"pool-%d"</span>).build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span></span>&#123;</span><br><span class="line">        threadPool.submit(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                threadPool1.getCorePoolSize(),</span><br><span class="line">                threadPool1.getMaximumPoolSize(),</span><br><span class="line">                threadPool1.getKeepAliveTime(),</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(threadPool1.getCapacity()),</span><br><span class="line">                namedThreadFactory,</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置完成后，问题解决！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果对Spring的生命周期掌握的不熟,遇到此类问题那就难办啦!&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>HeaFirst设计模式-单件模式[单例模式](Singleton Pattern)</title>
    <link href="http://yoursite.com/2019/06/20/HeaFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton-Pattern/"/>
    <id>http://yoursite.com/2019/06/20/HeaFirst设计模式-单件模式-单例模式-Singleton-Pattern/</id>
    <published>2019-06-20T07:08:42.000Z</published>
    <updated>2020-07-27T09:25:36.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入分析单件模式"><a href="#深入分析单件模式" class="headerlink" title="深入分析单件模式"></a>深入分析单件模式</h1><p>本次主要介绍的内容有</p><ul><li><a href="#单件模式：">单件模式</a></li><li><a href="#单线程下的单件模式的实现">单线程下的单件模式实现</a></li><li><a href="#多线程下实现单件模式出现的问题">多线程下实现单件模式出现的问题分析</a></li><li><a href="#JMM内存模型：">JMM内存模型</a></li><li><a href="#多线程下的单件模式实现的三种方式">多线程下的单件模式实现的三种方式</a></li></ul><p>这些内容，可以从最根本理解单例模式的代码，不信你就来看看吧。</p><a id="more"></a><h2 id="单件模式："><a href="#单件模式：" class="headerlink" title="单件模式："></a>单件模式：</h2><p>确保一个类只有一个实例，并提供一个全局访问点。</p><h2 id="单线程下的单件模式的实现"><a href="#单线程下的单件模式的实现" class="headerlink" title="单线程下的单件模式的实现"></a>单线程下的单件模式的实现</h2><p>在单线程下，不存在线程安全的问题，所以完成一个单件模式非常容易。<br>Singleton</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是其他的有用实例化变量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用getInstance方法实例化对象，并返回这个实例。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// 不为空就直接返回，保证只有一个实例</span></span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main线程中调用getInstance方法获取实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.singleton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Singleton instance = Singleton.getInstance();</span><br><span class="line">            System.out.println(instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下，这里可以看出，打印出的地址都是相同的，说明获取的是同一个实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">com.bestqiang.singleton.Singleton@<span class="number">4554617</span>c</span><br><span class="line">com.bestqiang.singleton.Singleton@<span class="number">4554617</span>c</span><br><span class="line">com.bestqiang.singleton.Singleton@<span class="number">4554617</span>c</span><br><span class="line">com.bestqiang.singleton.Singleton@<span class="number">4554617</span>c</span><br><span class="line">com.bestqiang.singleton.Singleton@<span class="number">4554617</span>c</span><br><span class="line">com.bestqiang.singleton.Singleton@<span class="number">4554617</span>c</span><br><span class="line">com.bestqiang.singleton.Singleton@<span class="number">4554617</span>c</span><br><span class="line">com.bestqiang.singleton.Singleton@<span class="number">4554617</span>c</span><br><span class="line">com.bestqiang.singleton.Singleton@<span class="number">4554617</span>c</span><br><span class="line">com.bestqiang.singleton.Singleton@<span class="number">4554617</span>c</span><br></pre></td></tr></table></figure><h2 id="多线程下实现单件模式出现的问题"><a href="#多线程下实现单件模式出现的问题" class="headerlink" title="多线程下实现单件模式出现的问题"></a>多线程下实现单件模式出现的问题</h2><p>在这里我用线程池开启了10个线程，分别调用getInstance()方法获取对象，并打印响应的线程名和对象的地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.multithreading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bestqiang.singleton.Singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                    Singleton ins = Singleton.getInstance();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 对象地址: "</span> + ins);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span> 对象地址: com.bestqiang.singleton.Singleton@<span class="number">4</span>c680a74</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span> 对象地址: com.bestqiang.singleton.Singleton@<span class="number">42970371</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> 对象地址: com.bestqiang.singleton.Singleton@<span class="number">4</span>c680a74</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> 对象地址: com.bestqiang.singleton.Singleton@<span class="number">4</span>c680a74</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> 对象地址: com.bestqiang.singleton.Singleton@<span class="number">4</span>c680a74</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span> 对象地址: com.bestqiang.singleton.Singleton@<span class="number">4</span>c680a74</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 对象地址: com.bestqiang.singleton.Singleton@<span class="number">3f</span>41a236</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span> 对象地址: com.bestqiang.singleton.Singleton@<span class="number">4</span>c680a74</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span> 对象地址: com.bestqiang.singleton.Singleton@<span class="number">4</span>c680a74</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> 对象地址: com.bestqiang.singleton.Singleton@<span class="number">4</span>c680a74</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>上图中，地址出现了不同的现象，这不是单例模式吗？为什么获取的对象会出现不同？</p><h3 id="内存不可见问题："><a href="#内存不可见问题：" class="headerlink" title="内存不可见问题："></a>内存不可见问题：</h3><p>当判断 if(uniqueInstance == null) 时，不同线程的本地内存都有uniqueInstance 的副本，这个副本可以理解为从主内存获取，然后放到本地内存，如下图JMM内存模型所示，注意这个本地内存是虚拟的，其实并不存在。</p><h4 id="JMM内存模型："><a href="#JMM内存模型：" class="headerlink" title="JMM内存模型："></a>JMM内存模型：</h4><p><img src="/2019/06/20/HeaFirst设计模式-单件模式-单例模式-Singleton-Pattern/20190614171451823.png" alt="tu1"><br>当线程更改本地内存中的值的时候，会刷新到主内存。使用的时候，本地内存有副本，那就不必再从主内存加载值了。<br>比如现在线程A和线程B使用不同的CPU执行，<br>第一种情况：<br>现在线程A启动，发现本地内存没有uniqueInstance的副本，然后就从主内存获取，获取后，新建了Singleton对象，赋值给 uniqueInstance,然后刷新给主内存。线程B启动时发现自己本地内存没有uniqueInstance，然后从主内存获取，存在本地缓存中，此时这个变量已经被线程A赋值过了，不为空，就直接返回这个对象，这种情况下，是正常的。<br><img src="/2019/06/20/HeaFirst设计模式-单件模式-单例模式-Singleton-Pattern/20190614172631551.png" alt="tu2"><br>第二种情况，线程A启动，发现本地内存没有uniqueInstance的副本，然后就从主内存获取，获取后，新建了Singleton对象，赋值给 uniqueInstance,然后刷新给主内存。线程B启动的时候，发现本地内存没有uniqueInstance的副本，然后就从主内存获取，存在本地缓存中（此时线程A修改的值还没有刷新给主内存），获取后，新建了Singleton对象，赋值给 uniqueInstance,然后刷新给主内存。这样一来，就出现了单件模式出现不同对象的情况，造成这种情况的是内存不可见问题导致的。</p><h3 id="原子性问题："><a href="#原子性问题：" class="headerlink" title="原子性问题："></a>原子性问题：</h3><p>如果内存不可见问题有人不了解，那么下面这个问题应该很多人都有所了解<br>当判断 if(uniqueInstance == null) 时，假设现在uniqueInstance 不存在内存可见性的问题，这个操作包含两步，第一步是从主内存获取，第二部是进行比较，那么A线程获取的时候是null，接下来一瞬间此时B线程对uniqueInstance 进行了修改，产生了一个实例，并刷新到了主内存，但是A线程并不知道，紧接着继续比较，这时候为null，A线程会都执行到方法内部，创建对象，出现了两个实例，对于这种问题，可以使用加锁的方式来解决。</p><h2 id="多线程下的单件模式实现的三种方式"><a href="#多线程下的单件模式实现的三种方式" class="headerlink" title="多线程下的单件模式实现的三种方式"></a>多线程下的单件模式实现的三种方式</h2><h3 id="第一种：加锁解决线程安全问题"><a href="#第一种：加锁解决线程安全问题" class="headerlink" title="第一种：加锁解决线程安全问题"></a>第一种：加锁解决线程安全问题</h3><p>从上面导致线程不安全的问题中，我们了解到单件模式中导致线程不安全的有两个重要因素，可见性和原子性，那么如何解决？加锁是一种较好的方式：<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.multithreading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bestqiang.singleton.Singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他有用的实例化的变量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他有用的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有同学在这里可能会疑惑，为什么加synchronized锁就解决了原子性和可见性的问题？<br>这里我科普一下：<br>synchronized块是Java提供的一种原子性内置锁，Java中的每个对象都可以把它单做一个同步锁来使用，这些Java内置的使用者看不到的锁被称为内部锁，也叫监视器锁。内置锁是排它锁，也就是当一个线程获取这个锁后，其他线程必须等待该线程释放锁后才能获取该锁。</p><h4 id="synchronized的内存语义（重点）："><a href="#synchronized的内存语义（重点）：" class="headerlink" title="synchronized的内存语义（重点）："></a>synchronized的内存语义（重点）：</h4><p>进入synchronized块的内存语义是把在synchronized块内使用到的变量从线程的工作内存中清除，这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取，而是直接冲主内存中获取。退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存。</p><p>从它的内存语义中可得，它解决了变量的可见性的问题。它是Java提供的一种原子内置锁，解决了原子性的问题，二者都得到解决，所以，用它来实现同步方法，非常合适。</p><h3 id="第二种：使用“急切”创建实例，而不用延迟实例化的做法"><a href="#第二种：使用“急切”创建实例，而不用延迟实例化的做法" class="headerlink" title="第二种：使用“急切”创建实例，而不用延迟实例化的做法"></a>第二种：使用“急切”创建实例，而不用延迟实例化的做法</h3><p>上面的加同步锁的方法，会大大降低程序的性能，只有第一次执行此方法时，才真正需要同步。换句话说，一旦设置好uniqueInstance变量，就不再需要同步这个方法了。之后每次调用这个方法，同步都是一种累赘。<br>如何改善呢？有一种方法简单有效，就是使用“急切”创建实例。话不多说，代码亮出来，就能明白了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.multithreading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bestqiang.singleton.Singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在静态初始化器中创建单件。这段代码保证了线程安全。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 uniqueInstance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中静态单件在类的生命周期的连接的阶段创建，JVM在类的初始化方法\&lt;clinit>中创建。然后在jdk1.8的环境下存在堆中，类的元信息存在方法区。<br>对于类的生命周期和JVM，可以从下面两篇文章做一下了解<br><a href="https://blog.csdn.net/qq_29951485/article/details/89789436" target="_blank" rel="noopener">“init”与”clinit”的区别</a><br><a href="https://blog.csdn.net/qq_29951485/article/details/89212868" target="_blank" rel="noopener">深入分析ClassLoader工作机制</a></p><p>因为uniqueInstance 创建过后就没有再改动，所以，不会出现线程安全的问题。</p><h3 id="第三种：用“双重检查加锁”，在getInstance-）中减少使用同步"><a href="#第三种：用“双重检查加锁”，在getInstance-）中减少使用同步" class="headerlink" title="第三种：用“双重检查加锁”，在getInstance(）中减少使用同步"></a>第三种：用“双重检查加锁”，在getInstance(）中减少使用同步</h3><p>利用双重检查加锁(double-checked locking),首先检查是否实例已经创建 了，如果尚未创建，”才”进行同步。这样一来，只有第一次会同步，这正是我们想要的。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.multithreading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bestqiang.singleton.Singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton3 uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是其他的有用实例化变量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用getInstance方法实例化对象，并返回这个实例。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查实例，如果不存在，就进入同步区块，只有第一次，才彻底的执行这里的代码</span></span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 进入区块后，再检查一次，如果仍是null，才创建实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不为空就直接返回，保证只有一个实例</span></span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，为了解决对象创建时的指令重排序问题，使用了volatile关键字。为了解决原子性的问题，使用了synchronized 加锁。</p><h4 id="volatile关键字（重要）"><a href="#volatile关键字（重要）" class="headerlink" title="volatile关键字（重要）"></a>volatile关键字（重要）</h4><p>关于Java中的<strong>volatile</strong>关键字，在这里做一下介绍：<br>上面介绍了使用锁的方式可以解决共享变量内存可见性的问题，但是使用锁太笨重因为它会带来线程上下文的切换开销。对于解决内存可见性问题，Java还提供了一种弱形式的同步，也就是使用volatile关键字。该关键字可以确保对一个变量的更新对其他线程马上可见。当一个变量被声明为volatile时，线程在写入变量时不会吧值缓存再寄存器或者其他地方，而是会把值刷新回主内存。当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。volatile的内存语义和synchronized有相似之处，具体来说就是，当线程写入了volatile变量值时就等价于线程退出synchronized同步块(把写入工作内存的变量值同步到主内存)，读取volatile变量值时就相当于进入同步块( 先清空本地内存变量值，再从主内存获取最新值)。</p><p>第一个方法中提到，synchronized 可解决可见性和原子性的问题，为什么还要用双重锁呢，仔细看看，第一个 <strong>if(uniqueInstance == null)</strong> 判断存在原子性的问题，因为是先取，后比较，取过来之后可能又会更改，所以在里面嵌套一个 <strong>if(uniqueInstance == null)</strong>，里面这个是加锁的，加上happens-before规则可以保证原子性和可见性，保证uniqueInstance直接从主存中获取，而且，在第一次创建后，因为里面有原子性内置锁，所以uniqueInstance不会再更改，因此外面的 <strong>if(uniqueInstance == null)</strong> 其实是安全的了，因为获取后，可以保证不再更改，不会因为原子性而造成线程不安全的问题。这样，就做到了只在第一次同步一次，避免了锁影响性能，而又可以懒加载对象。</p><p>上面的操作乍一看是没问题的，但是其实存在问题。</p><p>对象创建分为三步：</p><ol><li><p>分配对象的内存空间。memory = allocate();</p></li><li><p>初始化对象。instance = memory;</p></li><li><p>设置instance指向内存空间。ctorInstance(memory);</p></li></ol><p>这不是一个原子性操作，但即使不是原子性，这个操作也是没问题的，问题出在这个操作会进行重排序，可能第二部和第三步的顺序会发生变化，这时候第3步如果先执行，那么判断对象的值会依然为空，导致其他对象继续创建，导致单例模式的失败。</p><p>为什么要用volatile关键字呢？原因是volatile不仅仅可以保证程序的可见性，而且可以禁止指令重排序。至此，这个问题解决了。</p><p><strong>注意：</strong> jdk 1.4 及更早的版本中，许多JVM对于volatile关键字的实现会导致双重检查加锁的失效。如果不能使用Java 1.4以上的版本，而必须使用旧版的Java，就请不要利用此技巧实现单件模式。</p><p>本次对单例模式的实现做了相对深入的分析，希望读完这篇文章的朋友都能有所收获，共同进步。</p><p>参考的书籍：<br>《并发编程之美》，<br>《HeadFirst设计模式》</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深入分析单件模式&quot;&gt;&lt;a href=&quot;#深入分析单件模式&quot; class=&quot;headerlink&quot; title=&quot;深入分析单件模式&quot;&gt;&lt;/a&gt;深入分析单件模式&lt;/h1&gt;&lt;p&gt;本次主要介绍的内容有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#单件模式：&quot;&gt;单件模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#单线程下的单件模式的实现&quot;&gt;单线程下的单件模式实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#多线程下实现单件模式出现的问题&quot;&gt;多线程下实现单件模式出现的问题分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#JMM内存模型：&quot;&gt;JMM内存模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#多线程下的单件模式实现的三种方式&quot;&gt;多线程下的单件模式实现的三种方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些内容，可以从最根本理解单例模式的代码，不信你就来看看吧。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HeadFirst设计模式-工厂模式(基于汽车工厂和手机工厂)</title>
    <link href="http://yoursite.com/2019/06/20/HeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E5%9F%BA%E4%BA%8E%E6%B1%BD%E8%BD%A6%E5%B7%A5%E5%8E%82%E5%92%8C%E6%89%8B%E6%9C%BA%E5%B7%A5%E5%8E%82/"/>
    <id>http://yoursite.com/2019/06/20/HeadFirst设计模式-工厂模式-基于汽车工厂和手机工厂/</id>
    <published>2019-06-20T07:01:28.000Z</published>
    <updated>2020-07-27T09:25:36.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>本次主要讲述三个内容：</p><ul><li><a href="#简单工厂模式">简单工厂模式</a></li><li><a href="#工厂方法模式">工厂方法模式</a></li><li><a href="#抽象工厂模式">抽象工厂模式</a></li></ul><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>设计原则：<strong>要依赖抽象，不要依赖具体类。</strong></p><p>不能让高层组件依赖底层组件，而且，不管高层或底层组件，“两者”都应该依赖于抽象。<br>这个原则告诉我们，应该重写代码以便于我们依赖抽象类，而不依赖具体类。</p><p>指导方针：</p><ul><li>变量不可以持有具体类的引用。（如果使用new，就会持有具体类的引用。你可以改用工厂类避开这样的做法。）</li><li>不要让类派生自具体类。（如果派生自具体类，你就会依赖具体类。请派生自一个抽象（接口或抽象类））</li><li>不要覆盖基类中已实现的方法。（如果覆盖基类已经实现的方法，那么你的基类将就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享）</li></ul><a id="more"></a><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式不是一个“真正的”设计模式，只能说是一种编程习惯。<br>比如建立一个抽象类Car，然后用子类来继承。用SimpleCarFactory来生成对象（里面包含选择相应对象的逻辑处理），CarStrore直接调用SimpleCarFactory即可。<br><img src="/2019/06/20/HeadFirst设计模式-工厂模式-基于汽车工厂和手机工厂/2019061314233792.png" alt="tu1"><br>如上图所示。<br>代码实现如下：<br>Car ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.easyfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> String price;</span><br><span class="line">    <span class="keyword">private</span> String speed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Car&#123;"</span> +</span><br><span class="line">                <span class="string">"color='"</span> + color + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", price='"</span> + price + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", speed='"</span> + speed + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是"</span> + color + <span class="string">"汽车,"</span> + <span class="string">" 我的价格是: "</span> + price + <span class="string">","</span> + <span class="string">"速度是:"</span></span><br><span class="line">                + speed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpeed</span><span class="params">(String speed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.speed = speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(String price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlueCar:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.easyfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlueCar</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlueCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"blue"</span>,<span class="string">"2000$"</span>, <span class="string">"888km/s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"蓝汽车清洗完成了！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"蓝汽车可以开走了！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedCar:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.easyfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedCar</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"red"</span>,<span class="string">"1000$"</span>, <span class="string">"999km/s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"红汽车可以开走了！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"红汽车清洗完成了！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.easyfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"red"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RedCar();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"blue"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BlueCar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CarStore:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.easyfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarStore</span> </span>&#123;</span><br><span class="line">    SimpleCarFactory simpleCarFactory = <span class="keyword">new</span> SimpleCarFactory();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">orderCar</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Car car = simpleCarFactory.createCar(type);</span><br><span class="line">        car.sayHello();</span><br><span class="line">        car.clear();</span><br><span class="line">        car.go();</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.easyfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有依赖抽象类，下面的工厂模式会对其改进</span></span><br><span class="line">        CarStore carStore = <span class="keyword">new</span> CarStore();</span><br><span class="line">        Car blue = carStore.orderCar(<span class="string">"blue"</span>);</span><br><span class="line">        Car red = carStore.orderCar(<span class="string">"red"</span>);</span><br><span class="line">        System.out.println(blue);</span><br><span class="line">        System.out.println(red);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我是blue汽车, 我的价格是: <span class="number">2000</span>$,速度是:<span class="number">888</span>km/s</span><br><span class="line">蓝汽车可以开走了！</span><br><span class="line">蓝汽车清洗完成了！</span><br><span class="line">我是red汽车, 我的价格是: <span class="number">1000</span>$,速度是:<span class="number">999</span>km/s</span><br><span class="line">红汽车清洗完成了！</span><br><span class="line">红汽车可以开走了！</span><br><span class="line">Car&#123;color=<span class="string">'blue'</span>, price=<span class="string">'2000$'</span>, speed=<span class="string">'888km/s'</span>&#125;</span><br><span class="line">Car&#123;color=<span class="string">'red'</span>, price=<span class="string">'1000$'</span>, speed=<span class="string">'999km/s'</span>&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>刚才的简单工厂模式，只有一个工厂，不能动态的切换工厂。<br>所有的工厂模式都用来封装对象的创建。工厂方法模式（Factory Method Pattern）通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p><p>简单工厂把全部的事情，在一个地方都处理完了，然而工厂方法却是创建一个框架，让子类决定要如何实现。等于说是<br>如下图所示：<br><img src="/2019/06/20/HeadFirst设计模式-工厂模式-基于汽车工厂和手机工厂/20190613151430169.png" alt="tu2"><br>简单工厂的做法，可以将对象的创建封装起来，但是简单工程不具备工厂方法的弹性，因为简单工厂不能变更正在创建的产品。Main新建工厂的时候直接new抽象类就ok了。</p><p>工厂类的实现代码：<br>CarStoreF:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.Car;</span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.SimpleCarFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarStoreF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">orderCar</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Car car = createCar(type);</span><br><span class="line">        car.sayHello();</span><br><span class="line">        car.clear();</span><br><span class="line">        car.go();</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Car <span class="title">createCar</span><span class="params">(String type)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HuaweiCarStore:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.BlueCar;</span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.Car;</span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.RedCar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiCarStore</span> <span class="keyword">extends</span> <span class="title">CarStoreF</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Car <span class="title">createCar</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"red"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Huawei出品"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RedCar();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"blue"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Huawei出品"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BlueCar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XiaomiCarStore:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.BlueCar;</span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.Car;</span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.RedCar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiCarStore</span> <span class="keyword">extends</span> <span class="title">CarStoreF</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Car <span class="title">createCar</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"red"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"小米出品"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RedCar();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"blue"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"小米出品"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BlueCar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.Car;</span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.CarStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 依赖于抽象类</span></span><br><span class="line">        CarStoreF carStore = <span class="keyword">new</span> HuaweiCarStore();</span><br><span class="line">        Car blue = carStore.orderCar(<span class="string">"blue"</span>);</span><br><span class="line">        Car red = carStore.orderCar(<span class="string">"red"</span>);</span><br><span class="line">        System.out.println(blue);</span><br><span class="line">        System.out.println(red);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我是blue汽车, 我的价格是: <span class="number">2000</span>$,速度是:<span class="number">888</span>km/s</span><br><span class="line">蓝汽车可以开走了！</span><br><span class="line">蓝汽车清洗完成了！</span><br><span class="line">我是red汽车, 我的价格是: <span class="number">1000</span>$,速度是:<span class="number">999</span>km/s</span><br><span class="line">红汽车清洗完成了！</span><br><span class="line">红汽车可以开走了！</span><br><span class="line">Car&#123;color=<span class="string">'blue'</span>, price=<span class="string">'2000$'</span>, speed=<span class="string">'888km/s'</span>&#125;</span><br><span class="line">Car&#123;color=<span class="string">'red'</span>, price=<span class="string">'1000$'</span>, speed=<span class="string">'999km/s'</span>&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><strong>抽象工程模式：</strong> <strong>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</strong></p><p>抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道（或关心）实际产出的具体产品是什么。这样一来，客户就从具体的产品中被解耦。</p><p>抽象工厂定义了一个接口，所有的具体工程都必须实现此接口，这个接口包含一组方法用来生产产品。<br>当要创建产品家族和想<strong>让制造的相关产品集合起来</strong>时，可以使用抽象工厂。</p><p>可以这样理解，现在汽车工厂只生产汽车，现在如果还想生产手机，再继承原来汽车的抽象类，复用抽象类的已有的方法，实现抽象方法，就不合适了。那就建立一个抽象工厂，而且把抽象工厂设置为接口，把所有涉及的产品都写进去，然后后面再实现这个接口。<br>又可以这样理解，抽象工厂比工厂模式高一个级别，抽象工厂在乎的是生产的汽车还是手机，而工厂模式在乎的是生产的手机是什么样子的。在确定生产什么以后，工厂模式往往隐含在抽象工厂中。</p><p>下图中新增一个手机类，然后使用抽象工厂进行创建。<br><img src="/2019/06/20/HeadFirst设计模式-工厂模式-基于汽车工厂和手机工厂/20190613171604438.png" alt="img"><br>实现代码如下：<br>Phone：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.AFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Phone&#123;"</span> +</span><br><span class="line">                <span class="string">"color="</span> + color +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HuaweiPhone：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.AFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"华为，非一般的感觉！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XiaomiPhone：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.AFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小米，永不止步！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Factory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.AFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.Car;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title">phoneFactory</span><span class="params">(String type)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Car <span class="title">carFactory</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FactoryA：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.AFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.BlueCar;</span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.Car;</span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.RedCar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">phoneFactory</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"huawei"</span>)) &#123;</span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HuaweiPhone();</span><br><span class="line">        &#125; <span class="keyword">if</span> (type.equals(<span class="string">"XiaomiPhone"</span>)) &#123;</span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> XiaomiPhone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">carFactory</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"red"</span>)) &#123;</span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RedCar();</span><br><span class="line">        &#125; <span class="keyword">if</span> (type.equals(<span class="string">"blue"</span>)) &#123;</span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BlueCar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A工厂出品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FactoryB：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.AFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.BlueCar;</span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.Car;</span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.RedCar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">phoneFactory</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"huawei"</span>)) &#123;</span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HuaweiPhone();</span><br><span class="line">        &#125; <span class="keyword">if</span> (type.equals(<span class="string">"XiaomiPhone"</span>)) &#123;</span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> XiaomiPhone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">carFactory</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"red"</span>)) &#123;</span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RedCar();</span><br><span class="line">        &#125; <span class="keyword">if</span>(type.equals(<span class="string">"blue"</span>)) &#123;</span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BlueCar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B工厂出品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.AFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bestqiang.easyfactory.Car;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BestQiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> FactoryA();</span><br><span class="line">        Car red = factory.carFactory(<span class="string">"red"</span>);</span><br><span class="line">        System.out.println(red);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A工厂出品</span><br><span class="line">Car&#123;color=<span class="string">'red'</span>, price=<span class="string">'1000$'</span>, speed=<span class="string">'999km/s'</span>&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>三种工厂模式算是介绍完了，总结一下，</p><ul><li>简单工厂模式不能动态切换工厂，不依赖与抽象。</li><li>工厂方法模式创建一个抽象的工厂类，子类进行继承实现，可以动态切换工厂，适合同一种类。</li><li>抽象工厂模式把多个工厂隐含在里面，可以把相关的产品集合起来。是工厂模式的升级。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h1&gt;&lt;p&gt;本次主要讲述三个内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#简单工厂模式&quot;&gt;简单工厂模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#工厂方法模式&quot;&gt;工厂方法模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#抽象工厂模式&quot;&gt;抽象工厂模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;依赖倒置原则&quot;&gt;&lt;a href=&quot;#依赖倒置原则&quot; class=&quot;headerlink&quot; title=&quot;依赖倒置原则&quot;&gt;&lt;/a&gt;依赖倒置原则&lt;/h3&gt;&lt;p&gt;设计原则：&lt;strong&gt;要依赖抽象，不要依赖具体类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不能让高层组件依赖底层组件，而且，不管高层或底层组件，“两者”都应该依赖于抽象。&lt;br&gt;这个原则告诉我们，应该重写代码以便于我们依赖抽象类，而不依赖具体类。&lt;/p&gt;
&lt;p&gt;指导方针：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量不可以持有具体类的引用。（如果使用new，就会持有具体类的引用。你可以改用工厂类避开这样的做法。）&lt;/li&gt;
&lt;li&gt;不要让类派生自具体类。（如果派生自具体类，你就会依赖具体类。请派生自一个抽象（接口或抽象类））&lt;/li&gt;
&lt;li&gt;不要覆盖基类中已实现的方法。（如果覆盖基类已经实现的方法，那么你的基类将就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>J2EE基础知识总结</title>
    <link href="http://yoursite.com/2019/06/19/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/06/19/J2EE基础知识总结/</id>
    <published>2019-06-19T03:30:24.000Z</published>
    <updated>2020-07-27T09:25:36.427Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#servlet总结">Servlet总结</a></li><li><a href="#阐述servlet和cgi的区别">阐述Servlet和CGI的区别?</a><ul><li><a href="#cgi的不足之处">CGI的不足之处:</a></li><li><a href="#servlet的优点">Servlet的优点：</a></li></ul></li><li><a href="#servlet接口中有哪些方法及servlet生命周期探秘">Servlet接口中有哪些方法及Servlet生命周期探秘</a></li><li><a href="#get和post请求的区别">get和post请求的区别</a></li><li><a href="#什么情况下调用doget和dopost">什么情况下调用doGet()和doPost()</a></li><li><a href="#转发forward和重定向redirect的区别">转发（Forward）和重定向（Redirect）的区别</a></li><li><a href="#自动刷新refresh">自动刷新(Refresh)</a></li><li><a href="#servlet与线程安全">Servlet与线程安全</a></li><li><a href="#jsp和servlet是什么关系">JSP和Servlet是什么关系</a></li><li><a href="#jsp工作原理">JSP工作原理</a></li><li><a href="#jsp有哪些内置对象、作用分别是什么">JSP有哪些内置对象、作用分别是什么</a></li><li><a href="#request对象的主要方法有哪些">Request对象的主要方法有哪些</a></li><li><a href="#requestgetattribute和-requestgetparameter有何区别">request.getAttribute()和 request.getParameter()有何区别</a></li><li><a href="#include指令include的行为的区别">include指令include的行为的区别</a></li><li><a href="#jsp九大内置对象，七大动作，三大指令">JSP九大内置对象，七大动作，三大指令</a></li><li><a href="#讲解jsp中的四种作用域">讲解JSP中的四种作用域</a></li><li><a href="#如何实现jsp或servlet的单线程模式">如何实现JSP或Servlet的单线程模式</a></li><li><a href="#实现会话跟踪的技术有哪些">实现会话跟踪的技术有哪些</a></li><li><a href="#cookie和session的的区别">Cookie和Session的的区别</a></li></ul><a id="more"></a><h2 id="Servlet总结"><a href="#Servlet总结" class="headerlink" title="Servlet总结"></a>Servlet总结</h2><p>在Java Web程序中，<strong>Servlet</strong>主要负责接收用户请求 <code>HttpServletRequest</code>,在<code>doGet()</code>,<code>doPost()</code>中做相应的处理，并将回应<code>HttpServletResponse</code>反馈给用户。<strong>Servlet</strong> 可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用<code>init()</code>方法，销毁时调用<code>destroy()</code>方法<strong>。</strong>Servlet需要在web.xml中配置（MyEclipse中创建Servlet会自动配置），<strong>一个Servlet可以设置多个URL访问</strong>。<strong>Servlet不是线程安全</strong>，因此要谨慎使用类变量。</p><h2 id="阐述Servlet和CGI的区别"><a href="#阐述Servlet和CGI的区别" class="headerlink" title="阐述Servlet和CGI的区别?"></a>阐述Servlet和CGI的区别?</h2><h3 id="CGI的不足之处"><a href="#CGI的不足之处" class="headerlink" title="CGI的不足之处:"></a>CGI的不足之处:</h3><p>1，需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。</p><p>2，需要为每个请求加载和运行一个CGI程序，这将带来很大的开销 </p><p>3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。</p><h3 id="Servlet的优点"><a href="#Servlet的优点" class="headerlink" title="Servlet的优点:"></a>Servlet的优点:</h3><p>1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销</p><p>2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销</p><p>3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。</p><p>4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。</p><p>补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。</p><p>参考：《javaweb整合开发王者归来》P7</p><h2 id="Servlet接口中有哪些方法及Servlet生命周期探秘"><a href="#Servlet接口中有哪些方法及Servlet生命周期探秘" class="headerlink" title="Servlet接口中有哪些方法及Servlet生命周期探秘"></a>Servlet接口中有哪些方法及Servlet生命周期探秘</h2><p>Servlet接口定义了5个方法，其中<strong>前三个方法与Servlet生命周期相关</strong>：</p><ul><li><code>void init(ServletConfig config) throws ServletException</code></li><li><code>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</code></li><li><code>void destory()</code></li><li><code>java.lang.String getServletInfo()</code></li><li><code>ServletConfig getServletConfig()</code></li></ul><p><strong>生命周期：</strong> <strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。<strong>init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p><p>参考：《javaweb整合开发王者归来》P81</p><h2 id="get和post请求的区别"><a href="#get和post请求的区别" class="headerlink" title="get和post请求的区别"></a>get和post请求的区别</h2><blockquote><p>网上也有文章说：get和post请求实际上是没有区别，大家可以自行查询相关文章（参考文章：<a href="https://www.cnblogs.com/logsharing/p/8448446.html" target="_blank" rel="noopener">https://www.cnblogs.com/logsharing/p/8448446.html</a>，知乎对应的问题链接：<a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">get和post区别？</a>）！我下面给出的只是一种常见的答案。</p></blockquote><p>①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；</p><p>②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；</p><p>③get传输的数据要受到URL长度限制（最大长度是 2048 个字符）；而post可以传输大量的数据，上传文件通常要使用post方式；</p><p>④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；</p><p>⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。</p><p>补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。</p><p>还有另外一种回答。推荐大家看一下：</p><ul><li><a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">https://www.zhihu.com/question/28586791</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd</a></li></ul><h2 id="什么情况下调用doGet-和doPost"><a href="#什么情况下调用doGet-和doPost" class="headerlink" title="什么情况下调用doGet()和doPost()"></a>什么情况下调用doGet()和doPost()</h2><p>Form标签里的method的属性为get时调用doGet()，为post时调用doPost()。</p><h2 id="转发-Forward-和重定向-Redirect-的区别"><a href="#转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="转发(Forward)和重定向(Redirect)的区别"></a>转发(Forward)和重定向(Redirect)的区别</h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p><p><strong>转发（Forward）</strong><br>通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"login_success.jsp"</span>).forward(request, response);</span><br></pre></td></tr></table></figure><p><strong>重定向（Redirect）</strong>  是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 <code>HttpServletResponse</code> 的 <code>setStatus(int status)</code> 方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p><ol><li><strong>从地址栏显示来说</strong></li></ol><p>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.<br>redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p><ol start="2"><li><strong>从数据共享来说</strong></li></ol><p>forward:转发页面和转发到的页面可以共享request里面的数据.<br>redirect:不能共享数据.</p><ol start="3"><li><strong>从运用地方来说</strong></li></ol><p>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p><ol start="4"><li>从效率来说</li></ol><p>forward:高.<br>redirect:低.</p><h2 id="自动刷新-Refresh"><a href="#自动刷新-Refresh" class="headerlink" title="自动刷新(Refresh)"></a>自动刷新(Refresh)</h2><p>自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response.setHeader(<span class="string">"Refresh"</span>,<span class="string">"5;URL=http://localhost:8080/servlet/example.htm"</span>);</span><br></pre></td></tr></table></figure><p>其中5为时间，单位为秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现每过5秒自动刷新本页面一次）</p><h2 id="Servlet与线程安全"><a href="#Servlet与线程安全" class="headerlink" title="Servlet与线程安全"></a>Servlet与线程安全</h2><p><strong>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong> 解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。<br>注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p><p>参考：《javaweb整合开发王者归来》P92</p><h2 id="JSP和Servlet是什么关系"><a href="#JSP和Servlet是什么关系" class="headerlink" title="JSP和Servlet是什么关系"></a>JSP和Servlet是什么关系</h2><p>其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</p><h2 id="JSP工作原理"><a href="#JSP工作原理" class="headerlink" title="JSP工作原理"></a>JSP工作原理</h2><p>JSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。<br>工程JspLoginDemo下有一个名为login.jsp的Jsp文件，把工程第一次部署到服务器上后访问这个Jsp文件，我们发现这个目录下多了下图这两个东东。<br>.class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。<br><img src="/2019/06/19/J2EE基础知识总结/1560915357148.png" alt="1560915357148"><br>由于JSP只会在客户端第一次请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP。</p><p>开发Web程序时经常需要修改JSP。Tomcat能够自动检测到JSP程序的改动。如果检测到JSP源代码发生了改动。Tomcat会在下次客户端请求JSP时重新编译JSP，而不需要重启Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署Web应用的时候可以在web.xml中将它关掉。</p><p>参考：《javaweb整合开发王者归来》P97</p><h2 id="JSP有哪些内置对象、作用分别是什么"><a href="#JSP有哪些内置对象、作用分别是什么" class="headerlink" title="JSP有哪些内置对象、作用分别是什么"></a>JSP有哪些内置对象、作用分别是什么</h2><p><a href="http://blog.csdn.net/qq_34337272/article/details/64310849" target="_blank" rel="noopener">JSP内置对象 - CSDN博客 </a> </p><p>JSP有9个内置对象：</p><ul><li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li><li>response：封装服务器对客户端的响应；</li><li>pageContext：通过该对象可以获取其他对象；</li><li>session：封装用户会话的对象；</li><li>application：封装服务器运行环境的对象；</li><li>out：输出服务器响应的输出流对象；</li><li>config：Web应用的配置对象；</li><li>page：JSP页面本身（相当于Java程序中的this）；</li><li>exception：封装页面抛出异常的对象。</li></ul><h2 id="Request对象的主要方法有哪些"><a href="#Request对象的主要方法有哪些" class="headerlink" title="Request对象的主要方法有哪些"></a>Request对象的主要方法有哪些</h2><ul><li>setAttribute(String name,Object)：设置名字为name的request 的参数值 </li><li>getAttribute(String name)：返回由name指定的属性值 </li><li>getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例 </li><li>getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组 </li><li>getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度 </li><li>getHeader(String name) ：获得HTTP协议定义的文件头信息 </li><li>getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例 </li><li>getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例 </li><li>getInputStream() ：返回请求的输入流，用于获得请求中的数据 </li><li>getMethod() ：获得客户端向服务器端传送数据的方法 </li><li>getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值 </li><li>getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例 </li><li>getParameterValues(String name)：获得有name指定的参数的所有值 </li><li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称 </li><li>getQueryString() ：获得查询字符串 </li><li>getRequestURI() ：获取发出请求字符串的客户端地址 </li><li>getRemoteAddr()：获取客户端的 IP 地址 </li><li>getRemoteHost() ：获取客户端的名字 </li><li>getSession([Boolean create]) ：返回和请求相关 Session </li><li>getServerName() ：获取服务器的名字 </li><li>getServletPath()：获取客户端所请求的脚本文件的路径 </li><li>getServerPort()：获取服务器的端口号 </li><li>removeAttribute(String name)：删除请求中的一个属性 </li></ul><h2 id="request-getAttribute-和-request-getParameter-有何区别"><a href="#request-getAttribute-和-request-getParameter-有何区别" class="headerlink" title="request.getAttribute()和 request.getParameter()有何区别"></a>request.getAttribute()和 request.getParameter()有何区别</h2><p><strong>从获取方向来看：</strong></p><p><code>getParameter()</code>是获取 POST/GET 传递的参数值；</p><p><code>getAttribute()</code>是获取对象容器中的数据值；</p><p><strong>从用途来看：</strong></p><p><code>getParameter()</code>用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。</p><p><code>getAttribute()</code> 用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了<br>mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。</p><p>另外，可以用 <code>setAttribute()</code>,<code>getAttribute()</code> 发送接收对象.而 <code>getParameter()</code> 显然只能传字符串。<br><code>setAttribute()</code> 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样<code>getAttribute()</code>就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。<code>getParameter()</code>只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。</p><p><strong>总结：</strong></p><p><code>getParameter()</code>返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）</p><p><code>getAttribute()</code>返回的是Object，需进行转换,可用<code>setAttribute()</code>设置成任意对象，使用很灵活，可随时用</p><h2 id="include指令include的行为的区别"><a href="#include指令include的行为的区别" class="headerlink" title="include指令include的行为的区别"></a>include指令include的行为的区别</h2><p><strong>include指令：</strong> JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 语法格式如下：<br>&lt;%@ include file=”文件相对 url 地址” %&gt;</p><p>i<strong>nclude动作：</strong> <code>&lt;jsp:include&gt;</code>动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下：<br>&lt;jsp:include page=”相对 URL 地址” flush=”true” /&gt;</p><h2 id="JSP九大内置对象，七大动作，三大指令"><a href="#JSP九大内置对象，七大动作，三大指令" class="headerlink" title="JSP九大内置对象，七大动作，三大指令"></a>JSP九大内置对象，七大动作，三大指令</h2><p><a href="http://blog.csdn.net/qq_34337272/article/details/64310849" target="_blank" rel="noopener">JSP九大内置对象，七大动作，三大指令总结</a></p><h2 id="讲解JSP中的四种作用域"><a href="#讲解JSP中的四种作用域" class="headerlink" title="讲解JSP中的四种作用域"></a>讲解JSP中的四种作用域</h2><p>JSP中的四种作用域包括page、request、session和application，具体来说：</p><ul><li><strong>page</strong>代表与一个页面相关的对象和属性。</li><li><strong>request</strong>代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li><li><strong>session</strong>代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li><li><strong>application</strong>代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li></ul><h2 id="如何实现JSP或Servlet的单线程模式"><a href="#如何实现JSP或Servlet的单线程模式" class="headerlink" title="如何实现JSP或Servlet的单线程模式"></a>如何实现JSP或Servlet的单线程模式</h2><p>对于JSP页面，可以通过page指令进行设置。<br><code>&lt;%@page isThreadSafe=”false”%&gt;</code></p><p>对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。</p><p>说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。</p><h2 id="实现会话跟踪的技术有哪些"><a href="#实现会话跟踪的技术有哪些" class="headerlink" title="实现会话跟踪的技术有哪些"></a>实现会话跟踪的技术有哪些</h2><ol><li><strong>使用Cookie</strong></li></ol><p>向客户端发送Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie c =<span class="keyword">new</span> Cookie(<span class="string">"name"</span>,<span class="string">"value"</span>); <span class="comment">//创建Cookie </span></span><br><span class="line">c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>); <span class="comment">//设置最大时效，此处设置的最大时效为一天</span></span><br><span class="line">response.addCookie(c); <span class="comment">//把Cookie放入到HTTP响应中</span></span><br></pre></td></tr></table></figure><p>从客户端读取Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String name =<span class="string">"name"</span>; </span><br><span class="line">Cookie[]cookies =request.getCookies(); </span><br><span class="line"><span class="keyword">if</span>(cookies !=<span class="keyword">null</span>)&#123; </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;cookies.length;i++)&#123; </span><br><span class="line">    Cookie cookie =cookies[i]; </span><br><span class="line">    <span class="keyword">if</span>(name.equals(cookis.getName())) </span><br><span class="line">    <span class="comment">//something is here. </span></span><br><span class="line">    <span class="comment">//you can get the value </span></span><br><span class="line">    cookie.getValue(); </span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>优点:</strong> 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value</p><p><strong>缺点:</strong> 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。</p><ol start="2"><li>URL 重写</li></ol><p>在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。 </p><p><strong>优点：</strong> 在Cookie被禁用的时候依然可以使用</p><p><strong>缺点：</strong> 必须对网站的URL进行编码，所有页面必须动态生成，不能用预先记录下来的URL进行访问。</p><p>3.隐藏的表单域</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span> =<span class="string">"session"</span> <span class="attr">value</span>=<span class="string">"..."</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>优点：</strong> Cookie被禁时可以使用</p><p><strong>缺点：</strong> 所有页面必须是表单提交之后的结果。</p><ol start="4"><li><p>HttpSession</p><p>在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</p></li></ol><h2 id="Cookie和Session的的区别"><a href="#Cookie和Session的的区别" class="headerlink" title="Cookie和Session的的区别"></a>Cookie和Session的的区别</h2><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p> <strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#servlet总结&quot;&gt;Servlet总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#阐述servlet和cgi的区别&quot;&gt;阐述Servlet和CGI的区别?&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#cgi的不足之处&quot;&gt;CGI的不足之处:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#servlet的优点&quot;&gt;Servlet的优点：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#servlet接口中有哪些方法及servlet生命周期探秘&quot;&gt;Servlet接口中有哪些方法及Servlet生命周期探秘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#get和post请求的区别&quot;&gt;get和post请求的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#什么情况下调用doget和dopost&quot;&gt;什么情况下调用doGet()和doPost()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#转发forward和重定向redirect的区别&quot;&gt;转发（Forward）和重定向（Redirect）的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#自动刷新refresh&quot;&gt;自动刷新(Refresh)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#servlet与线程安全&quot;&gt;Servlet与线程安全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jsp和servlet是什么关系&quot;&gt;JSP和Servlet是什么关系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jsp工作原理&quot;&gt;JSP工作原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jsp有哪些内置对象、作用分别是什么&quot;&gt;JSP有哪些内置对象、作用分别是什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#request对象的主要方法有哪些&quot;&gt;Request对象的主要方法有哪些&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#requestgetattribute和-requestgetparameter有何区别&quot;&gt;request.getAttribute()和 request.getParameter()有何区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#include指令include的行为的区别&quot;&gt;include指令include的行为的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jsp九大内置对象，七大动作，三大指令&quot;&gt;JSP九大内置对象，七大动作，三大指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#讲解jsp中的四种作用域&quot;&gt;讲解JSP中的四种作用域&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#如何实现jsp或servlet的单线程模式&quot;&gt;如何实现JSP或Servlet的单线程模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#实现会话跟踪的技术有哪些&quot;&gt;实现会话跟踪的技术有哪些&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#cookie和session的的区别&quot;&gt;Cookie和Session的的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="J2EE" scheme="http://yoursite.com/categories/J2EE/"/>
    
    
      <category term="J2EE" scheme="http://yoursite.com/tags/J2EE/"/>
    
  </entry>
  
  <entry>
    <title>NIO源码分析之Selector</title>
    <link href="http://yoursite.com/2019/06/08/NIO%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BSelector/"/>
    <id>http://yoursite.com/2019/06/08/NIO源码分析之Selector/</id>
    <published>2019-06-08T00:18:30.000Z</published>
    <updated>2020-07-27T09:25:36.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NIO源码分析之Selector"><a href="#NIO源码分析之Selector" class="headerlink" title="NIO源码分析之Selector"></a>NIO源码分析之Selector</h1><p>NIO的Selector源码第一句话就是 A multiplexor of {@link SelectableChannel} objects.</p><p>即 SelectableChannel对象的多路复用器。这很清楚的说明了Selector的作用。</p><p>这篇文章主要从以下几个点对Selector进行分析：</p><ul><li>选择器（Selector）</li><li>可选择通道（SelectableChannel）</li><li>选择键（SelectionKey）</li><li>Selector完整实例</li></ul><a id="more"></a><h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><p>Selector选择器类管理着一个被注册的通道集合的信息和它们的就绪状态。通道是和选择器一起被注册的，并且使用选择器来更新通道的就绪状态。当这么做的时候，可以选择将被激发的线程挂起，直到有就绪的的通道。</p><p>下面是使用Selector管理多个channel的结构图： </p><p><img src="/2019/06/08/NIO源码分析之Selector/20151214194029453" alt="Selector图"></p><ul><li>Selector的创建</li></ul><p>A selector may be created by invoking the open method of this class, which will use the system’s default selector provider to create a new selector. A selector may also be created by invoking the openSelector method of a custom selector provider. A selector remains open until it is closed via its close method. </p><p>可以通过调用此类的open方法来创建选择器，该方法将使用系统的默认选择器提供程序来创建新的选择器。 还可以通过调用自定义选择器提供程序的openSelector方法来创建选择器。 选择器保持打开状态，直到通过其关闭方法关闭。</p><p>Selector可以调用静态方法open()来创建Selector</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector Selector=Selector.open()；</span><br></pre></td></tr></table></figure><p>openSelector() 是通过系统的默认获取</p><p><img src="/2019/06/08/NIO源码分析之Selector/1559911406587.png" alt="1559911406587"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java.nio.channels.spi.SelectorProvider public static SelectorProvider provider()</span><br><span class="line">Returns the system-wide default selector provider for this invocation of the Java virtual machine.</span><br><span class="line">The first invocation of this method locates the default provider object as follows:</span><br><span class="line">If the system property java.nio.channels.spi.SelectorProvider is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</span><br><span class="line">If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named java.nio.channels.spi.SelectorProvider in the resource directory META-INF/services, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</span><br><span class="line">Finally, if no provider has been specified by any of the above means then the system-default provider class is instantiated and the result is returned.</span><br><span class="line">Subsequent invocations of this method return the provider that was returned by the first invocation.</span><br><span class="line"></span><br><span class="line">java.nio.channels.spi.SelectorProvider public static SelectorProvider provider（）</span><br><span class="line">返回此Java虚拟机调用的系统范围默认选择器提供程序。</span><br><span class="line">第一次调用此方法将按如下方式定位默认提供程序对象：</span><br><span class="line">如果定义了系统属性java.nio.channels.spi.SelectorProvider，那么它将被视为具体提供程序类的完全限定名称。该类被加载并实例化;如果此过程失败，则抛出未指定的错误。</span><br><span class="line">如果提供程序类已安装在对系统类加载器可见的jar文件中，并且该jar文件在资源目录META-INF / services中包含名为java.nio.channels.spi.SelectorProvider的提供程序配置文件，然后获取该文件中指定的第一个类名。该类被加载并实例化;如果此过程失败，则抛出未指定的错误。</span><br><span class="line">最后，如果没有通过上述任何方式指定提供程序，则实例化系统缺省提供程序类并返回结果。</span><br><span class="line">此方法的后续调用将返回第一次调用返回的提供程序。</span><br></pre></td></tr></table></figure><p><img src="/2019/06/08/NIO源码分析之Selector/1559911644365.png" alt="1559911644365"></p><p><img src="/2019/06/08/NIO源码分析之Selector/1559911657130.png" alt="1559911657130">为provider的类。</p><p>由以上的源码可见它加了锁，是线程安全的</p><h1 id="SelectableChannel"><a href="#SelectableChannel" class="headerlink" title="SelectableChannel"></a>SelectableChannel</h1><ul><li><p>SelectableChannel这个抽象类提供了实现通道的可选择性所需要的公共方法。它是所有支持就绪检查的通道类的父类。因为FileChannel类没有继承SelectableChannel因此是不是可选通道，而所有socket通道都是可选择的，包括从管道(Pipe)对象的中获得的通道。SelectableChannel可以被注册到Selector对象上，同时可以指定对那个选择器而言，那种操作是感兴趣的。一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。</p></li><li><p>源码上对它的介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">A channel that can be multiplexed via a Selector.</span><br><span class="line">In order to be used with a selector, an instance of this class must first be registered via the register method. This method returns a new SelectionKey object that represents the channel&apos;s registration with the selector.</span><br><span class="line">Once registered with a selector, a channel remains registered until it is deregistered. This involves deallocating whatever resources were allocated to the channel by the selector.</span><br><span class="line">A channel cannot be deregistered directly; instead, the key representing its registration must be cancelled. Cancelling a key requests that the channel be deregistered during the selector&apos;s next selection operation. A key may be cancelled explicitly by invoking its cancel method. All of a channel&apos;s keys are cancelled implicitly when the channel is closed, whether by invoking its close method or by interrupting a thread blocked in an I/O operation upon the channel.</span><br><span class="line">If the selector itself is closed then the channel will be deregistered, and the key representing its registration will be invalidated, without further delay.</span><br><span class="line">A channel may be registered at most once with any particular selector.</span><br><span class="line">Whether or not a channel is registered with one or more selectors may be determined by invoking the isRegistered method.</span><br><span class="line">Selectable channels are safe for use by multiple concurrent threads.</span><br><span class="line"></span><br><span class="line">可以通过选择器进行多路复用的通道。</span><br><span class="line">为了与选择器一起使用，必须首先通过register方法注册该类的实例。此方法返回一个新的SelectionKey对象，该对象表示通道与选择器的注册。</span><br><span class="line">一旦注册选择器，通道将保持注册状态，直到它被注销。这涉及解除分配选择器分配给通道的任何资源。</span><br><span class="line">渠道不能直接注销;相反，必须取消代表其注册的密钥。取消密钥请求在选择器的下一个选择操作期间取消注册该通道。可以通过调用其cancel方法显式取消密钥。当通道关闭时，无论是通过调用其close方法还是通过中断在通道上的I / O操作中阻塞的线程，所有通道的键都会被隐式取消。</span><br><span class="line">如果选择器本身已关闭，则将取消注册该通道，并且表示其注册的密钥将无效，而不会有进一步的延迟。</span><br><span class="line">一个频道最多可以与任何特定选择器一起注册一次。</span><br><span class="line">可以通过调用isRegistered方法来确定是否向一个或多个选择器注册了频道。</span><br><span class="line">多个并发线程可以安全地使用可选择的通道。</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>SelectableChannel中有两个个方法为register，但是其实是一个方法<img src="/2019/06/08/NIO源码分析之Selector/1559913710363.png" alt="1559913710363"></p><p><img src="/2019/06/08/NIO源码分析之Selector/1559913853013.png" alt="1559913853013"></p><p>因为底层实现都是一样的，只不过第一个方法调用时第三个参数设置为null。</p></li></ul><p>它的抽象类<strong>AbstractSelectableChannel</strong>实现了这个抽象方法，注释为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">使用给定的选择器注册此通道，返回选择键。</span><br><span class="line">此方法首先验证此通道是否已打开，以及给定的初始兴趣集是否有效。</span><br><span class="line">如果此通道已在给定选择器中注册，则在将其兴趣设置为给定值后，将返回表示该注册的选择键。</span><br><span class="line">否则，此通道尚未在给定的选择器中注册，因此在保持适当的锁定时调用选择器的register方法。返回后，生成的密钥将添加到此通道的密钥集中。</span><br><span class="line"></span><br><span class="line">具体说明：</span><br><span class="line">在SelectableChannel类中注册</span><br><span class="line">PARAMS：</span><br><span class="line">sel  - 要注册此通道的选择器</span><br><span class="line">ops  - 为结果密钥设置的兴趣</span><br><span class="line">att  - 生成密钥的附件;可能是<span class="keyword">null</span></span><br><span class="line">返回：</span><br><span class="line">表示使用给定选择器注册此通道的键</span><br><span class="line">抛出：</span><br><span class="line">ClosedSelectorException  - 如果选择器已关闭</span><br><span class="line">IllegalBlockingModeException  - 如果此通道处于阻塞模式</span><br><span class="line">IllegalSelectorException  - 如果此通道不是由与给定选择器相同的提供程序创建的</span><br><span class="line">CancelledKeyException  - 如果此通道当前已在给定选择器中注册，但相应的键已被取消</span><br><span class="line">IllegalArgumentException  - 如果ops set中的某个位与此通道支持的操作不对应，即，如果set＆~validOps（）！= <span class="number">0</span></span><br><span class="line">ClosedChannelException  - 如果此通道已关闭</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers this channel with the given selector, returning a selection key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;  This method first verifies that this channel is open and that the</span></span><br><span class="line"><span class="comment">     * given initial interest set is valid.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If this channel is already registered with the given selector then</span></span><br><span class="line"><span class="comment">     * the selection key representing that registration is returned after</span></span><br><span class="line"><span class="comment">     * setting its interest set to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; Otherwise this channel has not yet been registered with the given</span></span><br><span class="line"><span class="comment">     * selector, so the &#123;<span class="doctag">@link</span> AbstractSelector#register register&#125; method of</span></span><br><span class="line"><span class="comment">     * the selector is invoked while holding the appropriate locks.  The</span></span><br><span class="line"><span class="comment">     * resulting key is added to this channel's key set before being returned.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  ClosedSelectorException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalBlockingModeException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalSelectorException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  CancelledKeyException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Object att)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">            <span class="keyword">if</span> ((ops &amp; ~validOps()) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            <span class="keyword">if</span> (blocking)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line">            SelectionKey k = findKey(sel);</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line">                k.attach(att);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// New registration</span></span><br><span class="line">                <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">                    k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att);</span><br><span class="line">                    addKey(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>要实现Selector管理Channel，需要将channel注册到相应的Selector上，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key= channel.register(selector,SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><p>通过调用通道的register()方法会将它注册到一个选择器上。与Selector一起使用时，<strong>Channel必须处于非阻塞模式</strong>下，否则将抛出IllegalBlockingModeException异常，这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式，而套接字通道都可以。另外通道一旦被注册，将不能再回到阻塞状态，此时若调用通道的configureBlocking(true)将抛出BlockingModeException异常。</p><p>register()方法的第二个参数是“interest集合”，表示选择器所关心的通道操作，它实际上是一个表示选择器在检查通道就绪状态时需要关心的操作的比特掩码。比如一个选择器对通道的read和write操作感兴趣，那么选择器在检查该通道时，只会检查通道的read和write操作是否已经处在就绪状态。<br>它有以下四种操作类型：</p><ol><li><p><strong>Connect 连接</strong></p></li><li><p><strong>Accept 接受</strong></p></li><li><p><strong>Read 读</strong></p></li><li><p><strong>Write 写</strong></p></li></ol><p>需要注意并非所有的操作在所有的可选择通道上都能被支持，比如ServerSocketChannel支持Accept，而SocketChannel中不支持。我们可以通过通道上的validOps()方法来获取特定通道下所有支持的操作集合。</p><p>JAVA中定义了四个常量来表示这四种操作类型：</p><ol><li><strong>SelectionKey.OP_CONNECT</strong></li><li><strong>SelectionKey.OP_ACCEPT</strong></li><li><strong>SelectionKey.OP_READ</strong></li><li><strong>SelectionKey.OP_WRITE</strong></li></ol><p>如果Selector对通道的多操作类型感兴趣，可以用“位或”操作符来实现：</p><p><strong>int interestSet=SelectionKey.OP_READ|SelectionKey.OP_WRITE;</strong><br>当通道触发了某个操作之后，表示该通道的某个操作已经就绪，可以被操作。因此，某个SocketChannel成功连接到另一个服务器称为“连接就绪”(OP_CONNECT)。一个ServerSocketChannel准备好接收新进入的连接称为“接收就绪”（OP_ACCEPT）。一个有数据可读的通道可以说是“读就绪”(OP_READ)。等待写数据的通道可以说是“写就绪”(OP_WRITE)。</p><p>我们注意到register（）方法会返回一个SelectionKey对象，我们称之为键对象。下面会对键对象详细说明。</p><ul><li><p>ServerSocketChannel</p><p>源码上的介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">A selectable channel for stream-oriented listening sockets.</span><br><span class="line">A server-socket channel is created by invoking the open method of this class. It is not possible to create a channel for an arbitrary, pre-existing ServerSocket. A newly-created server-socket channel is open but not yet bound. An attempt to invoke the accept method of an unbound server-socket channel will cause a NotYetBoundException to be thrown. A server-socket channel can be bound by invoking one of the bind methods defined by this class.</span><br><span class="line">Socket options are configured using the setOption method. Server-socket channels support the following options:</span><br><span class="line">Option Name</span><br><span class="line">Description</span><br><span class="line">SO_RCVBUF</span><br><span class="line">The size of the socket receive buffer</span><br><span class="line">SO_REUSEADDR</span><br><span class="line">Re-use address</span><br><span class="line">Additional (implementation specific) options may also be supported.</span><br><span class="line">Server-socket channels are safe for use by multiple concurrent threads.</span><br><span class="line"></span><br><span class="line">面向流的侦听套接字的可选通道。</span><br><span class="line">通过调用此类的open方法创建服务器套接字通道。 无法为任意预先存在的ServerSocket创建通道。 新创建的服务器套接字通道已打开但尚未绑定。 尝试调用未绑定的服务器套接字通道的accept方法将导致抛出NotYetBoundException。 可以通过调用此类定义的绑定方法之一来绑定服务器套接字通道。</span><br><span class="line">使用setOption方法配置套接字选项。 服务器套接字通道支持以下选项：</span><br><span class="line">选项名称</span><br><span class="line">描述</span><br><span class="line">SO_RCVBUF</span><br><span class="line">套接字接收缓冲区的大小</span><br><span class="line">SO_REUSEADDR</span><br><span class="line">重复使用地址</span><br><span class="line">还可以支持其他（特定于实现的）选项。</span><br><span class="line">服务器套接字通道可供多个并发线程使用。</span><br></pre></td></tr></table></figure><p><img src="/2019/06/08/NIO源码分析之Selector/1559912425948.png" alt="1559912425948">ServerSocketChannel继承了AbstractSelectableChannel</p><p><img src="/2019/06/08/NIO源码分析之Selector/1559912485036.png" alt="1559912485036">AbstractSelectableChannel继承了SelectableChannel,所以，ServerSocketChannel注册到Selector上</p></li><li><p>SocketChannel</p><p>源码上的介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">A selectable channel for stream-oriented connecting sockets.</span><br><span class="line">A socket channel is created by invoking one of the open methods of this class. It is not possible to create a channel for an arbitrary, pre-existing socket. A newly-created socket channel is open but not yet connected. An attempt to invoke an I/O operation upon an unconnected channel will cause a NotYetConnectedException to be thrown. A socket channel can be connected by invoking its connect method; once connected, a socket channel remains connected until it is closed. Whether or not a socket channel is connected may be determined by invoking its isConnected method.</span><br><span class="line">Socket channels support non-blocking connection: A socket channel may be created and the process of establishing the link to the remote socket may be initiated via the connect method for later completion by the finishConnect method. Whether or not a connection operation is in progress may be determined by invoking the isConnectionPending method.</span><br><span class="line">Socket channels support asynchronous shutdown, which is similar to the asynchronous close operation specified in the Channel class. If the input side of a socket is shut down by one thread while another thread is blocked in a read operation on the socket&apos;s channel, then the read operation in the blocked thread will complete without reading any bytes and will return -1. If the output side of a socket is shut down by one thread while another thread is blocked in a write operation on the socket&apos;s channel, then the blocked thread will receive an AsynchronousCloseException.</span><br><span class="line">Socket options are configured using the setOption method. Socket channels support the following options:</span><br><span class="line">Option Name</span><br><span class="line">Description</span><br><span class="line">SO_SNDBUF</span><br><span class="line">The size of the socket send buffer</span><br><span class="line">SO_RCVBUF</span><br><span class="line">The size of the socket receive buffer</span><br><span class="line">SO_KEEPALIVE</span><br><span class="line">Keep connection alive</span><br><span class="line">SO_REUSEADDR</span><br><span class="line">Re-use address</span><br><span class="line">SO_LINGER</span><br><span class="line">Linger on close if data is present (when configured in blocking mode only)</span><br><span class="line">TCP_NODELAY</span><br><span class="line">Disable the Nagle algorithm</span><br><span class="line">Additional (implementation specific) options may also be supported.</span><br><span class="line">Socket channels are safe for use by multiple concurrent threads. They support concurrent reading and writing, though at most one thread may be reading and at most one thread may be writing at any given time. The connect and finishConnect methods are mutually synchronized against each other, and an attempt to initiate a read or write operation while an invocation of one of these methods is in progress will block until that invocation is complete.</span><br><span class="line"></span><br><span class="line">用于面向流的连接套接字的可选通道。</span><br><span class="line">通过调用此类的一个打开方法来创建套接字通道。无法为任意预先存在的套接字创建通道。新创建的套接字通道已打开但尚未连接。尝试在未连接的通道上调用I / O操作将导致抛出NotYetConnectedException。可以通过调用connect方法连接套接字通道;连接后，插座通道保持连接状态，直到它关闭。是否连接套接字通道可以通过调用其isConnected方法来确定。</span><br><span class="line">套接字通道支持非阻塞连接：可以创建套接字通道，并且可以通过connect方法启动建立到远程套接字的链接的过程，以便稍后通过finishConnect方法完成。可以通过调用isConnectionPending方法来确定连接操作是否正在进行。</span><br><span class="line">套接字通道支持异步关闭，这类似于Channel类中指定的异步关闭操作。如果套接字的输入端被一个线程关闭而另一个线程在套接字通道上的读操作中被阻塞，那么被阻塞线程中的读操作将完成而不读取任何字节并返回-1。如果套接字的输出端被一个线程关闭而另一个线程在套接字通道上的写操作中被阻塞，则被阻塞的线程将收到AsynchronousCloseException。</span><br><span class="line">使用setOption方法配置套接字选项。套接字通道支持以下选项：</span><br><span class="line">选项名称</span><br><span class="line">描述</span><br><span class="line">SO_SNDBUF</span><br><span class="line">套接字发送缓冲区的大小</span><br><span class="line">SO_RCVBUF</span><br><span class="line">套接字接收缓冲区的大小</span><br><span class="line">SO_KEEPALIVE</span><br><span class="line">保持连接活着</span><br><span class="line">SO_REUSEADDR</span><br><span class="line">重复使用地址</span><br><span class="line">SO_LINGER</span><br><span class="line">如果存在数据则关闭（仅在阻止模式下配置时）</span><br><span class="line">TCP_NODELAY</span><br><span class="line">禁用Nagle算法</span><br><span class="line">还可以支持其他（特定于实现的）选项。</span><br><span class="line">套接字通道可以安全地由多个并发线程使用。它们支持并发读写，但最多只有一个线程可能正在读取，并且最多一个线程可能在任何给定时间写入。 connect和finishConnect方法彼此相互同步，并且在调用其中一个方法时尝试启动读取或写入操作将阻塞，直到该调用完成。</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/06/08/NIO源码分析之Selector/1559912629829.png" alt="1559912629829"></p><p>SocketChannel 继承了AbstractSelectableChannel，同ServerSocketChannel一样，可以注册到Selector。</p><h1 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h1><p>选择键封装了特定的通道与特定的选择器的注册关系。选择键对象被SelectableChannel.register()返回并提供一个表示这种注册关系的标记。选择键包含了两个比特集(以整数的形式进行编码)，指示了该注册关系所关心的通道操作，以及通道已经准备好的操作。</p><p>源码中这样说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A token representing the registration of a SelectableChannel with a Selector.</span><br><span class="line">A selection key is created each time a channel is registered with a selector. A key remains valid until it is cancelled by invoking its cancel method, by closing its channel, or by closing its selector. Cancelling a key does not immediately remove it from its selector; it is instead added to the selector&apos;s cancelled-key set for removal during the next selection operation. The validity of a key may be tested by invoking its isValid method. </span><br><span class="line">A selection key contains two operation sets represented as integer values. Each bit of an operation set denotes a category of selectable operations that are supported by the key&apos;s channel.</span><br><span class="line">The interest set determines which operation categories will be tested for readiness the next time one of the selector&apos;s selection methods is invoked. The interest set is initialized with the value given when the key is created; it may later be changed via the interestOps(int) method.</span><br><span class="line">The ready set identifies the operation categories for which the key&apos;s channel has been detected to be ready by the key&apos;s selector. The ready set is initialized to zero when the key is created; it may later be updated by the selector during a selection operation, but it cannot be updated directly.</span><br><span class="line">That a selection key&apos;s ready set indicates that its channel is ready for some operation category is a hint, but not a guarantee, that an operation in such a category may be performed by a thread without causing the thread to block. A ready set is most likely to be accurate immediately after the completion of a selection operation. It is likely to be made inaccurate by external events and by I/O operations that are invoked upon the corresponding channel.</span><br><span class="line">This class defines all known operation-set bits, but precisely which bits are supported by a given channel depends upon the type of the channel. Each subclass of SelectableChannel defines an validOps() method which returns a set identifying just those operations that are supported by the channel. An attempt to set or test an operation-set bit that is not supported by a key&apos;s channel will result in an appropriate run-time exception.</span><br><span class="line">It is often necessary to associate some application-specific data with a selection key, for example an object that represents the state of a higher-level protocol and handles readiness notifications in order to implement that protocol. Selection keys therefore support the attachment of a single arbitrary object to a key. An object can be attached via the attach method and then later retrieved via the attachment method.</span><br><span class="line">Selection keys are safe for use by multiple concurrent threads. The operations of reading and writing the interest set will, in general, be synchronized with certain operations of the selector. Exactly how this synchronization is performed is implementation-dependent: In a naive implementation, reading or writing the interest set may block indefinitely if a selection operation is already in progress; in a high-performance implementation, reading or writing the interest set may block briefly, if at all. In any case, a selection operation will always use the interest-set value that was current at the moment that the operation began.</span><br><span class="line"></span><br><span class="line">表示SelectableChannel与Selector注册的标记。</span><br><span class="line">每次向选择器注册通道时，都会创建一个选择键。密钥保持有效，直到通过调用其取消方法，关闭其通道或关闭其选择器来取消密钥。取消密钥不会立即将其从选择器中删除;而是将其添加到选择器的已取消键集中，以便在下一个选择操作期间将其删除。可以通过调用其isValid方法来测试密钥的有效性。</span><br><span class="line">选择键包含表示为整数值的两个操作集。操作集的每个位表示密钥通道支持的可选操作的类别。</span><br><span class="line">- 兴趣集确定下次调用选择器的一个选择方法时将测试哪些操作类别的准备情况。利息集初始化为创建密钥时给定的值;稍后可以通过interestOps（int）方法进行更改。</span><br><span class="line">就绪集合通过键的选择器识别检测到键的通道准备就绪的操作类别。创建密钥时，就绪集初始化为零;稍后可以在选择操作期间由选择器更新，但不能直接更新。</span><br><span class="line">- 选择键的就绪集指示其通道已准备好用于某些操作类别是提示但不保证这样的类别中的操作可由线程执行而不会导致线程阻塞。在完成选择操作之后，就绪设置最有可能是准确的。外部事件和在相应通道上调用的I / O操作可能会使其不准确。</span><br><span class="line">该类定义了所有已知的操作集位，但是精确地由给定通道支持哪些位取决于通道的类型。 SelectableChannel的每个子类定义一个validOps（）方法，该方法返回一个集合，该集合仅标识通道支持的那些操作。尝试设置或测试密钥通道不支持的操作设置位将导致适当的运行时异常。</span><br><span class="line">通常需要将一些特定于应用程序的数据与选择键相关联，例如，表示更高级别协议状态的对象，并处理准备就绪通知以实现该协议。因此，选择键支持将单个任意对象附加到键。可以通过attach方法附加对象，然后通过附加方法检索。</span><br><span class="line">选择键可安全地供多个并发线程使用。通常，读取和写入兴趣集的操作将与选择器的某些操作同步。具体如何执行此同步依赖于实现：在一个简单的实现中，如果选择操作已在进行中，则读取或写入兴趣集可能会无限期地阻塞;在高性能实现中，如果有的话，读取或写入兴趣集可能会暂时阻止。在任何情况下，选择操作将始终使用操作开始时当前的兴趣设定值。</span><br></pre></td></tr></table></figure><p>下图格式较为清晰：</p><p><img src="/2019/06/08/NIO源码分析之Selector/1559959788470.png" alt="1559959788470"></p><p><img src="/2019/06/08/NIO源码分析之Selector/1559960109410.png" alt="1559960109410"></p><p>可见interestOps()  和 readyOps()都是返回的int类型，其实他们返回的是上面OP_READ等四个常量的 “|”。</p><p>判断集合中是否有某一个常量，可以使用“&amp;”来判断，如 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT</span><br></pre></td></tr></table></figure><p>返回值为true则代表存在。</p><ul><li><h3 id="该对象可以获取以下四种属性："><a href="#该对象可以获取以下四种属性：" class="headerlink" title="该对象可以获取以下四种属性："></a><strong>该对象可以获取以下四种属性：</strong></h3><ul><li>interest集合（其实是int类型，上面解释过了）</li><li>ready集合（其实是int类型，上面解释过了）</li><li>Channel</li><li>Selector</li></ul></li></ul><p>interest集合是Selector感兴趣的集合，用于指示选择器对通道关心的操作，可通过SelectionKey对象的interestOps()获取。最初，该兴趣集合是通道被注册到Selector时传进来的值。该集合不会被选择器改变，但是可通过interestOps()改变。</p><p><img src="/2019/06/08/NIO源码分析之Selector/1559961179277.png" alt="1559961179277"></p><p>我们可以通过以下方法来判断Selector是否对Channel的某种事件感兴趣：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet=selectionKey.interestOps();</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br></pre></td></tr></table></figure><p><strong>ready</strong> 集合是通道已经就绪的操作的集合，表示一个通道准备好要执行的操作了,可通过SelctionKey对象的readyOps()来获取相关通道已经就绪的操作。它是interest集合的子集，并且表示了interest集合中从上次调用select()以后已经就绪的那些操作。（比如选择器对通道的ready,write操作感兴趣，而某时刻通道的read操作已经准备就绪可以被选择器获知了，前一种就是interest集合，后一种则是ready集合。）。JAVA中定义以下几个方法用来检查这些操作是否就绪：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int readSet=selectionKey.readOps();</span></span><br><span class="line">selectionKey.isAcceptable();<span class="comment">//等价于selectionKey.readyOps()&amp;SelectionKey.OP_ACCEPT</span></span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure><p>需要注意的是，通过相关的选择键的readyOps()方法返回的就绪状态指示只是一个提示，底层的通道在任何时候都会不断改变，而其他线程也可能在通道上执行操作并影响到它的就绪状态。另外，我们不能直接修改ready集合。</p><p><strong>取出SelectionKey所关联的Selector和Channel</strong><br>通过SelectionKey访问对应的Selector和Channel：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel channel =selectionKey.channel();</span><br><span class="line">Selector selector=selectionKey.selector();</span><br></pre></td></tr></table></figure><ul><li><p><strong>关于取消SelectionKey对象的那点事</strong></p><p>我们可以通过SelectionKey对象的cancel()方法来取消特定的注册关系。</p><p><img src="/2019/06/08/NIO源码分析之Selector/1559959631484.png" alt="1559959631484"></p><p>该方法调用之后，该SelectionKey对象将会被”拷贝”至已取消键的集合中，该键此时已经失效，但是该注册关系并不会立刻终结。在下一次select()时，已取消键的集合中的元素会被清除，相应的注册关系也真正终结。</p></li><li><p><strong>为SelectionKey绑定附加对象</strong></p></li></ul><p>可以将一个或者多个附加对象绑定到SelectionKey上，以便容易的识别给定的通道。通常有两种方式： </p><ol><li><p>在注册的时候直接绑定： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key=channel.register(selector,SelectionKey.OP_READ,theObject);</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>在绑定完成之后附加： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);<span class="comment">//绑定</span></span><br></pre></td></tr></table></figure></li></ol><p>绑定之后，可通过对应的SelectionKey取出该对象:<br>selectionKey.attachment();。<br>如果要取消该对象，则可以通过该种方式:<br>selectionKey.attach(null).</p><p>需要注意的是如果附加的对象不再使用，一定要人为清除，因为垃圾回收器不会回收该对象，若不清除的话会成内存泄漏。</p><p>一个单独的通道可被注册到多个选择器中，有些时候我们需要通过isRegistered（）方法来检查一个通道是否已经被注册到任何一个选择器上。 通常来说，我们并不会这么做。</p><ul><li>通过Selector选择通道</li></ul><p>我们知道选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中。接下来我们简单的了解一下Selector维护的三种类型SelectionKey集合：</p><p>我们知道选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中。接下来我们简单的了解一下</p><h3 id="Selector维护的三种类型SelectionKey集合：（重点）"><a href="#Selector维护的三种类型SelectionKey集合：（重点）" class="headerlink" title="Selector维护的三种类型SelectionKey集合：（重点）"></a><strong>Selector维护的三种类型SelectionKey集合</strong>：（重点）</h3><p>源码中已经说明了一切：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">A multiplexor of SelectableChannel objects.</span><br><span class="line">A selector may be created by invoking the open method of this class, which will use the system&apos;s default selector provider to create a new selector. A selector may also be created by invoking the openSelector method of a custom selector provider. A selector remains open until it is closed via its close method. </span><br><span class="line">A selectable channel&apos;s registration with a selector is represented by a SelectionKey object. A selector maintains three sets of selection keys:</span><br><span class="line">The key set contains the keys representing the current channel registrations of this selector. This set is returned by the keys method.</span><br><span class="line">The selected-key set is the set of keys such that each key&apos;s channel was detected to be ready for at least one of the operations identified in the key&apos;s interest set during a prior selection operation. This set is returned by the selectedKeys method. The selected-key set is always a subset of the key set.</span><br><span class="line">The cancelled-key set is the set of keys that have been cancelled but whose channels have not yet been deregistered. This set is not directly accessible. The cancelled-key set is always a subset of the key set.</span><br><span class="line">All three sets are empty in a newly-created selector.</span><br><span class="line">A key is added to a selector&apos;s key set as a side effect of registering a channel via the channel&apos;s register method. Cancelled keys are removed from the key set during selection operations. The key set itself is not directly modifiable.</span><br><span class="line">A key is added to its selector&apos;s cancelled-key set when it is cancelled, whether by closing its channel or by invoking its cancel method. Cancelling a key will cause its channel to be deregistered during the next selection operation, at which time the key will removed from all of the selector&apos;s key sets. </span><br><span class="line">Keys are added to the selected-key set by selection operations. A key may be removed directly from the selected-key set by invoking the set&apos;s remove method or by invoking the remove method of an iterator obtained from the set. Keys are never removed from the selected-key set in any other way; they are not, in particular, removed as a side effect of selection operations. Keys may not be added directly to the selected-key set.</span><br><span class="line"></span><br><span class="line">SelectableChannel对象的多路复用器。</span><br><span class="line">- 可以通过调用此类的open方法来创建选择器，该方法将使用系统的默认选择器提供程序来创建新的选择器。还可以通过调用自定义选择器提供程序的openSelector方法来创建选择器。选择器保持打开状态，直到通过其关闭方法关闭。</span><br><span class="line">可选择通道的选择器注册由SelectionKey对象表示。选择器维护三组选择键：</span><br><span class="line">重点： 密钥集包含表示此选择器的当前通道注册的键。该方法由keys方法返回。</span><br><span class="line">重点： 所选择的密钥集是一组密钥，使得检测到每个密钥的信道准备好用于在先前选择操作期间在密钥的兴趣集中识别的至少一个操作。这个集由selectedKeys方法返回。选定键集始终是键集的子集。</span><br><span class="line">重点： 取消密钥集是已取消但其通道尚未取消注册的密钥集。此套装无法直接访问。取消密钥集始终是密钥集的子集。</span><br><span class="line">在新创建的选择器中，所有三个组都是空的。</span><br><span class="line">将一个键添加到选择器的键集中，作为通过通道的寄存器方法注册通道的副作用。在选择操作期间，取消的密钥将从密钥集中删除。密钥集本身不能直接修改。</span><br><span class="line">无论是通过关闭其通道还是通过调用其cancel方法，都会在取消选择器的取消键集时添加一个键。取消密钥将导致其通道在下一个选择操作期间取消注册，此时密钥将从所有选择器的密钥集中删除。</span><br><span class="line">通过选择操作将键添加到选定键集。可以通过调用set的remove方法或通过调用从set中获取的迭代器的remove方法，直接从selected-key集中删除键。密钥永远不会以任何其他方式从选定密钥集中删除;特别是，它们不会作为选择操作的副作用而被删除。密钥可能无法直接添加到选定密钥集。</span><br></pre></td></tr></table></figure><ul><li>密钥集（key set）包含表示此选择器的当前通道注册的键。该方法由keys方法返回。</li><li>所选择的密钥集（selected-key set）是一组密钥，使得检测到每个密钥的信道准备好用于在先前选择操作期间在密钥的兴趣集中识别的至少一个操作。这个集由selectedKeys方法返回。选定键集始终是键集的子集。</li><li>取消密钥集（ cancelled-key set）是已取消但其通道尚未取消注册的密钥集。此套装无法直接访问。取消密钥集始终是密钥集的子集。</li></ul><p>在刚初始化的Selector对象中，这三个集合都是空的。通过Selector的select（）方法可以选择已经准备就绪的通道（这些通道包含你感兴趣的的事件）。比如你对读就绪的通道感兴趣，那么select（）方法就会返回读事件已经就绪的那些通道。下面是Selector几个重载的select()方法：<br>select():阻塞到至少有一个通道在你注册的事件上就绪了。<br>select(long timeout)：和select()一样，但最长阻塞事件为timeout毫秒。<br>selectNow():非阻塞，只要有通道就绪就立刻返回。</p><p>select()方法返回的int值表示有多少通道已经就绪,是自上次调用select()方法后有多少通道变成就绪状态。之前在select（）调用时进入就绪的通道不会在本次调用中被记入，而在前一次select（）调用进入就绪但现在已经不在处于就绪的通道也不会被记入。例如：首次调用select()方法，如果有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p><p>一旦调用select()方法，并且返回值不为0时，则可以通过调用Selector的selectedKeys()方法来访问已选择键集合。如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys=selector.selectedKeys();</span><br></pre></td></tr></table></figure><p>进而可以放到和某SelectionKey关联的Selector和Channel。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于Selector执行选择的过程（重点）"><a href="#关于Selector执行选择的过程（重点）" class="headerlink" title="关于Selector执行选择的过程（重点）"></a>关于Selector执行选择的过程（重点）</h3><p>我们知道调用select（）方法进行通道，现在我们再来深入一下选择的过程，也就是select（）执行过程。当select（）被调用时将执行以下几步：</p><ol><li><p>首先检查已取消键集合，也就是通过cancle()取消的键。如果该集合不为空，则清空该集合里的键，同时该集合中每个取消的键也将从已注册键集合和已选择键集合中移除。（<strong>注意：</strong>一个键被取消时，并不会立刻从集合中移除，而是将该键“拷贝”至已取消键集合中，这种取消策略就是我们常提到的“延迟取消”。）</p></li><li><p>再次检查已注册键集合（准确说是该集合中每个键的interest集合）。系统底层会依次询问每个已经注册的通道是否准备好选择器所感兴趣的某种操作，一旦发现某个通道已经就绪了，则会首先判断该通道是否已经存在在已选择键集合当中，如果已经存在，则更新该通道在已注册键集合中对应的键的ready集合，如果不存在，则首先清空该通道的对应的键的ready集合，然后重设ready集合，最后将该键存至已注册键集合中。这里需要明白，当更新ready集合时，在<strong>上次select（）中已经就绪的操作不会被删除</strong>，也就是ready集合中的元素是累积的，比如在第一次的selector对某个通道的read和write操作感兴趣，在第一次执行select（）时，该通道的read操作就绪，此时该通道对应的键中的ready集合存有read元素，在第二次执行select()时，该通道的write操作也就绪了，此时该通道对应的ready集合中将同时有read和write元素。</p></li></ol><h3 id="深入已注册键集合的管理（重点）"><a href="#深入已注册键集合的管理（重点）" class="headerlink" title="深入已注册键集合的管理（重点）"></a>深入已注册键集合的管理（重点）</h3><p>由上面贴出的源码可以知道。通过选择操作将键添加到选定键集。可以通过调用set的remove方法或通过调用从set中获取的迭代器的remove方法，直接从selected-key集中删除键。密钥永远不会以任何其他方式从选定密钥集中删除;特别是，它们不会作为选择操作的副作用而被删除。密钥可能无法直接添加到选定密钥集。</p><p>首先要记住：选择器不会主动删除被添加到已选择键集合中的键，而且被添加到已选择键集合中的键的ready集合只能被设置，而不能被清理。如果我们希望清空已选择键集合中某个键的ready集合该怎么办？我们知道一个键在新加入已选择键集合之前会首先置空该键的ready集合，这样的话我们可以人为的将某个键从已注册键集合中移除最终实现置空某个键的ready集合。被移除的键如果在下一次的select（）中再次就绪，它将会重新被添加到已选择的键的集合中。这就是为什么要在每次迭代的末尾调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyIterator.remove()</span><br></pre></td></tr></table></figure><h3 id="停止选择"><a href="#停止选择" class="headerlink" title="停止选择"></a>停止选择</h3><p>选择器执行选择的过程，系统底层会依次询问每个通道是否已经就绪，这个过程可能会造成调用线程进入阻塞状态,那么我们有以下三种方式可以唤醒在select（）方法中阻塞的线程。</p><ol><li><p>通过调用Selector对象的wakeup（）方法让处在阻塞状态的select()方法立刻返回 </p><p>该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中的选择操作，那么下一次对select()方法的一次调用将立即返回。</p></li><li><p>通过close（）方法关闭Selector</p><p>该方法使得任何一个在选择操作中阻塞的线程都被唤醒（类似wakeup（）），同时使得注册到该Selector的所有Channel被注销，所有的键将被取消，但是Channel本身并不会关闭。</p></li><li><p>调用interrupt()</p><p>调用该方法会使睡眠的线程抛出InterruptException异常，捕获该异常并在调用wakeup()</p></li></ol><h1 id="Selector完整实例"><a href="#Selector完整实例" class="headerlink" title="Selector完整实例"></a>Selector完整实例</h1><p>这里我们结合ServerSocketChannel和Selector构建简单的服务器，下面是完整的代码示例。<br>服务端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerSocketChannelTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer byteBuffer;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port = <span class="number">8998</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> remoteClientNum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerSocketChannelTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initChannel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        socketChannel = ServerSocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        socketChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        System.out.println(<span class="string">"listener on port:"</span> + port);</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        byteBuffer = ByteBuffer.allocateDirect(size);</span><br><span class="line">        byteBuffer.order(ByteOrder.BIG_ENDIAN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">listener</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = selector.select();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; ite = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (ite.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = ite.next();</span><br><span class="line">                <span class="comment">//a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">                    SocketChannel channel = server.accept();</span><br><span class="line">                    registerChannel(selector, channel, SelectionKey.OP_READ);</span><br><span class="line">                    remoteClientNum++;</span><br><span class="line">                    System.out.println(<span class="string">"online client num="</span>+remoteClientNum);</span><br><span class="line">                    replyClient(channel);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//a channel is ready for reading</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    readDataFromSocket(key);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ite.remove();<span class="comment">//must</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">readDataFromSocket</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        <span class="keyword">while</span> ((count = socketChannel.read(byteBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            byteBuffer.flip(); <span class="comment">// Make buffer readable</span></span><br><span class="line">            <span class="comment">// Send the data; don't assume it goes all at once</span></span><br><span class="line">            <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">                socketChannel.write(byteBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">            byteBuffer.clear(); <span class="comment">// Empty buffer</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            socketChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replyClient</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        byteBuffer.put(<span class="string">"hello client!\r\n"</span>.getBytes());</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        channel.write(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerChannel</span><span class="params">(Selector selector, SocketChannel channel, <span class="keyword">int</span> ops)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        channel.register(selector, ops);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> ServerSocketChannelTest().listener();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannelTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer byteBuffer;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8998</span>));</span><br><span class="line">        byteBuffer = ByteBuffer.allocate(size);</span><br><span class="line">        byteBuffer.order(ByteOrder.BIG_ENDIAN);</span><br><span class="line">        receive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count;</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            <span class="keyword">while</span> ((count = socketChannel.read(byteBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) byteBuffer.get());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//send("send data to server\r\n".getBytes());</span></span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        byteBuffer.put(data);</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SocketChannelTest().connectServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文参考了：<a href="https://blog.csdn.net/dd864140130/article/details/50299687" target="_blank" rel="noopener">https://blog.csdn.net/dd864140130/article/details/50299687</a>，修正了其中的错误，并以源代码为依据，重新梳理了整个Selector。整个过程花费时间长，收获也很多，特别是对Selector，SelectorKey有了更深一个层次的了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;NIO源码分析之Selector&quot;&gt;&lt;a href=&quot;#NIO源码分析之Selector&quot; class=&quot;headerlink&quot; title=&quot;NIO源码分析之Selector&quot;&gt;&lt;/a&gt;NIO源码分析之Selector&lt;/h1&gt;&lt;p&gt;NIO的Selector源码第一句话就是 A multiplexor of {@link SelectableChannel} objects.&lt;/p&gt;
&lt;p&gt;即 SelectableChannel对象的多路复用器。这很清楚的说明了Selector的作用。&lt;/p&gt;
&lt;p&gt;这篇文章主要从以下几个点对Selector进行分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择器（Selector）&lt;/li&gt;
&lt;li&gt;可选择通道（SelectableChannel）&lt;/li&gt;
&lt;li&gt;选择键（SelectionKey）&lt;/li&gt;
&lt;li&gt;Selector完整实例&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="NIO" scheme="http://yoursite.com/categories/NIO/"/>
    
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>NIO源码分析之Buffer</title>
    <link href="http://yoursite.com/2019/06/07/NIO%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BBuffer/"/>
    <id>http://yoursite.com/2019/06/07/NIO源码分析之Buffer/</id>
    <published>2019-06-07T09:07:05.000Z</published>
    <updated>2020-07-27T09:25:36.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NIO源码分析之Buffer"><a href="#NIO源码分析之Buffer" class="headerlink" title="NIO源码分析之Buffer"></a>NIO源码分析之Buffer</h1><p>NIO博大精深，探寻NIO的源码后收获很多，在此进行记录。这次主要分析Buffer的源码，主要有以下几个内容。</p><ul><li>绝对方法和相对方法（position，limit，capacity属性的含义）</li><li>Clearing，flipping，and rewinding 的作用</li><li>线程不安全</li><li>链式调用</li><li>常用API源码分析</li></ul><a id="more"></a><h1 id="绝对方法和相对方法"><a href="#绝对方法和相对方法" class="headerlink" title="绝对方法和相对方法"></a>绝对方法和相对方法</h1><ol><li>相对方法: limit值与position值会在操作时被考虑到.</li><li>绝对方法,完全忽略掉limit值与position值.</li></ol><h2 id="三个重要属性的含义：-position，-limit，-capacity"><a href="#三个重要属性的含义：-position，-limit，-capacity" class="headerlink" title="三个重要属性的含义： position， limit， capacity"></a>三个重要属性的含义： position， limit， capacity</h2><p>源码中的解析：<br>A buffer’s capacity is the number of elements it contains. The capacity of a buffer is never negative and never changes.</p><p>一个buffer的capacity是它锁包含的元素的数量。buffer的capacity不为负而且不能改变。</p><p>A buffer’s limit is the index of the first element that should not be read or written. A buffer’s limit is never negative and is never greater than its capacity.</p><p>一个buffer的limit是第一个不能被读写的元素的索引。一个buffer的limit不能为负而且不能大于它的capacity。</p><p>A buffer’s position is the index of the next element to be read or written. A buffer’s position is never negative and is never greater than its limit.</p><p>一个buffer 的position是下一个被读写的元素的索引。一个buffer 的position不能为负而且不能大于limit。</p><p>创建时调用Buffer的一个子类ByteBuffer的 allocate申请空间。返回的是HeapByteBuffer(capacity, capacity)</p><p><img src="/2019/06/07/NIO源码分析之Buffer/1559900213755.png" alt="1559900213755"></p><p>层层跟进</p><p><img src="/2019/06/07/NIO源码分析之Buffer/1559900229280.png" alt="1559900229280"></p><p>它调用了父类ByteBuffer中的构造方法</p><p><img src="/2019/06/07/NIO源码分析之Buffer/1559900251780.png" alt="1559900251780"></p><p>由此可得出cpacity和limit的初始值是相同的，position为0。</p><p>另外调用ByteBuffer的allocateDirect，为</p><p><img src="/2019/06/07/NIO源码分析之Buffer/1559900299881.png" alt="1559900299881"></p><p>它调用了DirectByteBuffer的构造方法来进行初始化。</p><p><img src="/2019/06/07/NIO源码分析之Buffer/1559900323457.png" alt="1559900323457"></p><p>可见limit和capacity依然是相同的。position为0。</p><p> 所以初始时为：</p><p><img src="/2019/06/07/NIO源码分析之Buffer/1559898867716.png" alt="1559898867716"></p><p>其中capacity永不变。读了四个以后为：</p><p><img src="/2019/06/07/NIO源码分析之Buffer/1559898879731.png" alt="1559898879731"></p><p>flip方法：将p指向0，将limit指向原来position的位置。</p><p><img src="/2019/06/07/NIO源码分析之Buffer/1559898898600.png" alt="1559898898600"></p><p>这样进行写或者读的时候，随着position向limit的移动就可以成功读取响应的数据。<br>mark作用为进行标记，以便返回标记处。<br>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</p><h1 id="Clearing-flipping-and-rewinding"><a href="#Clearing-flipping-and-rewinding" class="headerlink" title="Clearing, flipping, and rewinding"></a>Clearing, flipping, and rewinding</h1><ul><li>clear makes a buffer ready for a new sequence of channel-read or relative put operations: It sets the limit to the capacity and the position to zero.<br>使得limit和capacity归零，相当于重置。</li><li>flip makes a buffer ready for a new sequence of channel-write or relative get operations: It sets the limit to the current position and then sets the position to zero.<br>使得limit放在position的位置，使position归零，用于下一次读写。</li><li>rewind makes a buffer ready for re-reading the data that it already contains: It leaves the limit unchanged and sets the position to zero.<br>使得position归零，进行新的读写相当于恢复为上一次读写前的状态，进行新的读写</li></ul><h1 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h1><p>Thread safety<br>Buffers are not safe for use by multiple concurrent threads. If a buffer is to be used by more than one thread then access to the buffer should be controlled by appropriate synchronization.</p><p>使用多线程的时候Buffer不是多线程的，如果Buffer要在多于一个线程中使用，需要进行适当的同步。</p><h1 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h1><p>Invocation chaining<br>Methods in this class that do not otherwise have a value to return are specified to return the buffer upon which they are invoked. This allows method invocations to be chained; for example, the sequence of statements</p><p>此类中没有要返回的值的方法被指定为返回调用它们的缓冲区。这允许将方法调用链接起来；例如，语句序列</p><p>   b.flip();<br>   b.position(23);<br>   b.limit(42);<br>can be replaced by the single, more compact statement<br>   b.flip().position(23).limit(42);</p><h1 id="常用API源码分析"><a href="#常用API源码分析" class="headerlink" title="常用API源码分析"></a>常用API源码分析</h1><ul><li>allocate()</li></ul><p><img src="/2019/06/07/NIO源码分析之Buffer/1559900988375.png" alt="1559900988375"></p><p>HeapIntBuffer与IntBuffer为父子关系。</p><p><img src="/2019/06/07/NIO源码分析之Buffer/1559901004884.png" alt="1559901004884"></p><p>IntBuffer调用父类 IntBuffer的构造方法进行初始化</p><p><img src="/2019/06/07/NIO源码分析之Buffer/1559901021472.png" alt="1559901021472"></p><ul><li>allocateDerect() 零拷贝</li></ul><p>直接申请堆外内存.实现了零拷贝.之前为什么要拷贝?因为直接操作堆上的内存（可以看做用户空间的内存）,然后分配一个address给buffer的话，期间可能会出现GC等,导致数据内存地址发生改变.所以只好把内容拷贝给buffer。直接操作堆外内存（内核空间的内存）的话，不会出现GC，所以把地址直接给buffer，可以实现零拷贝。</p><p><img src="/2019/06/07/NIO源码分析之Buffer/1559901063264.png" alt="1559901063264"></p><p>进入DerecByteBuffer()方法,如下图,以看出里面用JNI,unsafe的方法直接申请内存</p><p><img src="/2019/06/07/NIO源码分析之Buffer/1559901126260.png" alt="1559901126260"></p><p> 在Buffer类中可以找到address变量,表示在对外内存分配的内存的地址,为什么不直接放在DerectByteBuffer呢,上面注释说了,为了加快GetDirectBufferAddress的调用方法.</p><p> <img src="/2019/06/07/NIO源码分析之Buffer/1559901151138.png" alt="1559901151138"></p><ul><li>mark()</li></ul><p><img src="/2019/06/07/NIO源码分析之Buffer/1559901454025.png" alt="1559901454025"></p><p>将mark标记设置为position处</p><ul><li>reset()</li></ul><p><img src="/2019/06/07/NIO源码分析之Buffer/1559901481681.png" alt="1559901481681"></p><p>重新设置position位置为之前标记的m处</p><ul><li>clear()</li></ul><p><img src="/2019/06/07/NIO源码分析之Buffer/1559901520443.png" alt="1559901520443"></p><p>清空buffer,想象一下,即将position置零(最左端),limit被赋值为capacity(limit和capacity在最右端),一切都回到了最开始的地方.<br><strong>注意:</strong>  这个数组不会理所当然的被抹去,这个数组会随着之后的写入而把之前的值给覆盖.</p><ul><li>flip()</li></ul><p><img src="/2019/06/07/NIO源码分析之Buffer/1559901567243.png" alt="1559901567243"></p><p>翻转,意思就是把limit置为position,position置为0,mark置为-1(代表丢弃),准备给channel进行读写.</p><ul><li>rewind()</li></ul><p><img src="/2019/06/07/NIO源码分析之Buffer/1559901608889.png" alt="1559901608889"></p><p>非常好理解,倒带,就是把position置为0,重复利用buffer,解进行下一次channel-write或者get操作.它和flip()的区别是,flip操作了limit,而这个limit是定的,只是为了再次重复利用buffer.</p><ul><li>remaining()&amp;&amp;hasRemaining()</li></ul><p><img src="/2019/06/07/NIO源码分析之Buffer/1559901643187.png" alt="1559901643187"></p><p>remaining意思为剩余,顾名思义,remaining()方法利用limit - position成功得出剩余的处理的数量.<br>hasRemaining返回一个boolean值,表示是否还有剩余.</p><ul><li>slice()</li></ul><p><img src="/2019/06/07/NIO源码分析之Buffer/1559901716482.png" alt="1559901716482"></p><p>Slice Buffer 和 原有 Buffer 共享相同的底层数组,但是不共享limit和position</p><ul><li>asReadOnlyBuffer()</li></ul><p><img src="/2019/06/07/NIO源码分析之Buffer/1559901749370.png" alt="1559901749370"></p><p>点开实现类,为 HeapByteBufferR,</p><p><img src="/2019/06/07/NIO源码分析之Buffer/1559901768633.png" alt="1559901768633"></p><p>它的put方法全都抛出ReadOnlyBufferException()异常.</p><p>以上解析了部分核心API的源码，更多的源码，原理大概相似，可以自行看源码进行理解。下面会分析Selector的相关源码，对其进行更深入的理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;NIO源码分析之Buffer&quot;&gt;&lt;a href=&quot;#NIO源码分析之Buffer&quot; class=&quot;headerlink&quot; title=&quot;NIO源码分析之Buffer&quot;&gt;&lt;/a&gt;NIO源码分析之Buffer&lt;/h1&gt;&lt;p&gt;NIO博大精深，探寻NIO的源码后收获很多，在此进行记录。这次主要分析Buffer的源码，主要有以下几个内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绝对方法和相对方法（position，limit，capacity属性的含义）&lt;/li&gt;
&lt;li&gt;Clearing，flipping，and rewinding 的作用&lt;/li&gt;
&lt;li&gt;线程不安全&lt;/li&gt;
&lt;li&gt;链式调用&lt;/li&gt;
&lt;li&gt;常用API源码分析&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="NIO" scheme="http://yoursite.com/categories/NIO/"/>
    
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构 VS Java内存模型 VS Java对象模型</title>
    <link href="http://yoursite.com/2019/05/30/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-VS-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-VS-Java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/05/30/JVM内存结构-VS-Java内存模型-VS-Java对象模型/</id>
    <published>2019-05-30T08:56:57.000Z</published>
    <updated>2020-07-27T09:25:36.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM内存结构-VS-Java内存模型-VS-Java对象模型"><a href="#JVM内存结构-VS-Java内存模型-VS-Java对象模型" class="headerlink" title="JVM内存结构 VS Java内存模型 VS Java对象模型"></a>JVM内存结构 VS Java内存模型 VS Java对象模型</h1><p>Java作为一种面向对象的，跨平台语言，其对象、内存等一直是比较难的知识点。而且很多概念的名称看起来又那么相似，很多人会傻傻分不清楚。比如本文我们要讨论的<strong>JVM内存结构</strong>、<strong>Java内存模型</strong>和<strong>Java对象模型</strong>，这就是<strong>三个截然不同的概念</strong>，但是很多人容易弄混。</p><p>可以这样说，很多高级开发甚至都搞不不清楚JVM内存结构、Java内存模型和Java对象模型这三者的概念及其间的区别。甚至我见过有些面试官自己也搞的不是太清楚。不信的话，你去网上搜索Java内存模型，还会有很多文章的内容其实介绍的是JVM内存结构。</p><p>首先，这三个概念是完全不同的三个概念。<strong>本文主要对这三个概念加以区分以及简单介绍。</strong></p><a id="more"></a><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p>我们都知道，Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。在《<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4" target="_blank" rel="noopener">Java虚拟机规范（Java SE 8）</a>》中描述了JVM运行时内存区域结构如下：</p><p><img src="/2019/05/30/JVM内存结构-VS-Java内存模型-VS-Java对象模型/QQ20180624-150918.png" alt="QQ20180624-150918"></p><p>各个区域的功能不是本文重点，就不在这里详细介绍了。这里简单提几个需要特别注意的点：</p><ol><li><p>以上是Java虚拟机规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。</p></li><li><p>规范中定义的方法区，只是一种概念上的区域，并说明了其应该具有什么功能。但是并没有规定这个区域到底应该处于何处。所以，对于不同的虚拟机实现来说，是由一定的自由度的。</p></li><li><p>不同版本的方法区所处位置不同，上图中划分的是逻辑区域，并不是绝对意义上的物理区域。因为某些版本的JDK中方法区其实是在堆中实现的。</p></li><li><p>运行时常量池用于存放编译期生成的各种字面量和符号应用。但是，Java语言并不要求常量只有在编译期才能产生。比如在运行期，String.intern也会把新的常量放入池中。</p></li><li><p>除了以上介绍的JVM运行时内存外，还有一块内存区域可供使用，那就是直接内存。Java虚拟机规范并没有定义这块内存区域，所以他并不由JVM管理，是利用本地方法库直接在堆外申请的内存区域。</p></li><li><p>堆和栈的数据划分也不是绝对的，如HotSpot的JIT会针对对象分配做相应的优化。</p></li></ol><p>如上，做个总结，JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型看上去和Java内存结构（JVM内存结构）差不多，很多人会误以为两者是一回事儿，这也就导致面试过程中经常答非所为。</p><p>在前面的关于JVM的内存结构的图中，我们可以看到，其中Java堆和方法区的区域是多个线程共享的数据区域。也就是说，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。</p><p>Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf" target="_blank" rel="noopener">JSR-133: Java Memory Model and Thread Specification</a>中描述了，JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。</p><p>那么，简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字。</p><p><img src="/2019/05/30/JVM内存结构-VS-Java内存模型-VS-Java对象模型/11.png" alt="11"></p><p>在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题。这里就不对Java内存模型做更加详细的介绍了，想了解更多的朋友可以参考《Java并发编程的艺术》。</p><h2 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h2><p>Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。</p><p>HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。</p><p>每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个<code>instanceKlass</code>，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个<code>instanceOopDesc</code>对象，这个对象中包含了对象头以及实例数据。</p><p><img src="/2019/05/30/JVM内存结构-VS-Java内存模型-VS-Java对象模型/20170615230126453.jpeg" alt="20170615230126453"></p><p>这就是一个简单的Java对象的OOP-Klass模型，即Java对象模型。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们再来区分下JVM内存结构、 Java内存模型 以及 Java对象模型 三个概念。</p><p>JVM内存结构，和Java虚拟机的运行时区域有关。 Java内存模型，和Java的并发编程有关。 Java对象模型，和Java对象在虚拟机中的表现形式有关。</p><p>关于这三部分内容，本文并未分别展开，因为涉及到的知识点实在太多，如果读者感兴趣，可以自行学习。</p><p>特别感谢<a href="https://www.hollischuang.com/" target="_blank" rel="noopener">https://www.hollischuang.com/</a>的总结，很专业，很清晰！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM内存结构-VS-Java内存模型-VS-Java对象模型&quot;&gt;&lt;a href=&quot;#JVM内存结构-VS-Java内存模型-VS-Java对象模型&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构 VS Java内存模型 VS Java对象模型&quot;&gt;&lt;/a&gt;JVM内存结构 VS Java内存模型 VS Java对象模型&lt;/h1&gt;&lt;p&gt;Java作为一种面向对象的，跨平台语言，其对象、内存等一直是比较难的知识点。而且很多概念的名称看起来又那么相似，很多人会傻傻分不清楚。比如本文我们要讨论的&lt;strong&gt;JVM内存结构&lt;/strong&gt;、&lt;strong&gt;Java内存模型&lt;/strong&gt;和&lt;strong&gt;Java对象模型&lt;/strong&gt;，这就是&lt;strong&gt;三个截然不同的概念&lt;/strong&gt;，但是很多人容易弄混。&lt;/p&gt;
&lt;p&gt;可以这样说，很多高级开发甚至都搞不不清楚JVM内存结构、Java内存模型和Java对象模型这三者的概念及其间的区别。甚至我见过有些面试官自己也搞的不是太清楚。不信的话，你去网上搜索Java内存模型，还会有很多文章的内容其实介绍的是JVM内存结构。&lt;/p&gt;
&lt;p&gt;首先，这三个概念是完全不同的三个概念。&lt;strong&gt;本文主要对这三个概念加以区分以及简单介绍。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM优化基础和JDK工具的使用</title>
    <link href="http://yoursite.com/2019/05/30/JVM%E4%BC%98%E5%8C%96%E5%9F%BA%E7%A1%80%E5%92%8CJDK%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/05/30/JVM优化基础和JDK工具的使用/</id>
    <published>2019-05-30T08:44:29.000Z</published>
    <updated>2020-07-27T09:25:36.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM优化基础和JDK工具的使用"><a href="#JVM优化基础和JDK工具的使用" class="headerlink" title="JVM优化基础和JDK工具的使用"></a>JVM优化基础和JDK工具的使用</h1><ul><li>了解下我们为什么要学习JVM优化</li><li>掌握jvm的运行参数以及参数的设置</li><li>掌握jvm的内存结构（堆内存）</li><li>掌握jamp命令的使用以及通过MAT工具进行分析</li><li>掌握定位分析内存溢出的方法</li><li>掌握jstack命令的使用</li><li>掌握VisualJVM工具的使用</li></ul><a id="more"></a><h2 id="1、我们为什么要对jvm做优化？"><a href="#1、我们为什么要对jvm做优化？" class="headerlink" title="1、我们为什么要对jvm做优化？"></a>1、我们为什么要对jvm做优化？</h2><p>在本地开发环境中我们很少会遇到需要对jvm进行优化的需求，但是到了生产环境，我们可能将有下面的需求：</p><ul><li>运行的应用“卡住了”，日志不输出，程序没有反应</li><li>服务器的CPU负载突然升高</li><li>在多线程应用下，如何分配线程的数量？</li><li>……</li></ul><p>在本次课程中，我们将对jvm有更深入的学习，我们不仅要让程序能跑起来，而且是可以跑的更快！可以分析解决在生产环境中所遇到的各种“棘手”的问题。</p><blockquote><p>说明：本套课程使用的jdk版本为1.8。</p></blockquote><h2 id="2、jvm的运行参数"><a href="#2、jvm的运行参数" class="headerlink" title="2、jvm的运行参数"></a>2、jvm的运行参数</h2><p>在jvm中有很多的参数可以进行设置，这样可以让jvm在各种环境中都能够高效的运行。绝大部分的参数保持默认即可。</p><h3 id="2-1、三种参数类型"><a href="#2-1、三种参数类型" class="headerlink" title="2.1、三种参数类型"></a>2.1、三种参数类型</h3><p>jvm的参数类型分为三类，分别是：</p><ul><li>标准参数<ul><li>-help</li><li>-version</li></ul></li><li>-X参数 （非标准参数）<ul><li>-Xint</li><li>-Xcomp</li></ul></li><li>-XX参数（使用率较高）<ul><li>-XX:newSize</li><li>-XX:+UseSerialGC</li></ul></li></ul><h3 id="2-2、标准参数"><a href="#2-2、标准参数" class="headerlink" title="2.2、标准参数"></a>2.2、标准参数</h3><p>jvm的标准参数，一般都是很稳定的，在未来的JVM版本中不会改变，可以使用java -help检索出所有的标准参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# java -help</span><br><span class="line">用法: java [-options] class [args...]</span><br><span class="line">           (执行类)</span><br><span class="line">   或  java [-options] -jar jarfile [args...]</span><br><span class="line">           (执行 jar 文件)</span><br><span class="line">其中选项包括:</span><br><span class="line">    -d32  使用 32 位数据模型 (如果可用)</span><br><span class="line">    -d64  使用 64 位数据模型 (如果可用)</span><br><span class="line">    -server  选择 "server" VM</span><br><span class="line">                  默认 VM 是 server,</span><br><span class="line">                  因为您是在服务器类计算机上运行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">                  用 : 分隔的目录, JAR 档案</span><br><span class="line">                  和 ZIP 档案列表, 用于搜索类文件。</span><br><span class="line">    -D&lt;名称&gt;=&lt;值&gt;</span><br><span class="line">                  设置系统属性</span><br><span class="line">    -verbose:[class|gc|jni]</span><br><span class="line">                  启用详细输出</span><br><span class="line">    -version      输出产品版本并退出</span><br><span class="line">    -version:&lt;值&gt;</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  需要指定的版本才能运行</span><br><span class="line">    -showversion  输出产品版本并继续</span><br><span class="line">    -jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  在版本搜索中包括/排除用户专用 JRE</span><br><span class="line">    -? -help      输出此帮助消息</span><br><span class="line">    -X            输出非标准选项的帮助</span><br><span class="line">    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  按指定的粒度启用断言</span><br><span class="line">    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  禁用具有指定粒度的断言</span><br><span class="line">    -esa | -enablesystemassertions</span><br><span class="line">                  启用系统断言</span><br><span class="line">    -dsa | -disablesystemassertions</span><br><span class="line">                  禁用系统断言</span><br><span class="line">    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">                  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help</span><br><span class="line">    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  按完整路径名加载本机代理库</span><br><span class="line">    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br><span class="line">    -splash:&lt;imagepath&gt;</span><br><span class="line">                  使用指定的图像显示启动屏幕</span><br></pre></td></tr></table></figure><h4 id="2-2-1、实战"><a href="#2-2-1、实战" class="headerlink" title="2.2.1、实战"></a>2.2.1、实战</h4><blockquote><p><strong>实战1：查看jvm版本</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# java -version</span><br><span class="line">java version "1.8.0_141"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -showversion参数是表示，先打印版本信息，再执行后面的命令，在调试时非常有用，后面会使用到。</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>实战2：通过-D设置系统属性参数</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJVM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = System.getProperty(<span class="string">"str"</span>);</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"bestqiang"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行编译、测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line">[root@node01 test]# javac TestJVM.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">测试</span></span><br><span class="line">[root@node01 test]# java TestJVM</span><br><span class="line">bestqiang</span><br><span class="line">[root@node01 test]# java -Dstr=123 TestJVM</span><br><span class="line">123</span><br></pre></td></tr></table></figure><h4 id="2-2-2、-server与-client参数"><a href="#2-2-2、-server与-client参数" class="headerlink" title="2.2.2、-server与-client参数"></a>2.2.2、-server与-client参数</h4><p>可以通过-server或-client设置jvm的运行参数。</p><ul><li>它们的区别是Server VM的初始堆空间会大一些，默认使用的是并行垃圾回收器，启动慢运行快。</li><li>Client VM相对来讲会保守一些，初始堆空间会小一些，使用串行的垃圾回收器，它的目标是为了让JVM的启动速度更快，但运行速度会比Serverm模式慢些。</li><li>JVM在启动的时候会根据硬件和操作系统自动选择使用Server还是Client类型的JVM。 </li><li>32位操作系统<ul><li>如果是Windows系统，不论硬件配置如何，都默认使用Client类型的JVM。 </li><li>如果是其他操作系统上，机器配置有2GB以上的内存同时有2个以上CPU的话默认使用server模式，否则使用client模式。</li></ul></li><li>64位操作系统<ul><li>只有server类型，不支持client类型。</li></ul></li></ul><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 test]# java -client -showversion TestJVM</span><br><span class="line">java version "1.8.0_141"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)</span><br><span class="line"></span><br><span class="line">bestqiang</span><br><span class="line"></span><br><span class="line">[root@node01 test]# java -server -showversion TestJVM</span><br><span class="line">java version "1.8.0_141"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)</span><br><span class="line"></span><br><span class="line">bestqiang</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">由于机器是64位系统，所以不支持client模式</span></span><br></pre></td></tr></table></figure><h3 id="2-3、-X参数"><a href="#2-3、-X参数" class="headerlink" title="2.3、-X参数"></a>2.3、-X参数</h3><p>jvm的-X参数是非标准参数，在不同版本的jvm中，参数可能会有所不同，可以通过java -X查看非标准参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 test]# java -X</span><br><span class="line">    -Xmixed           混合模式执行 (默认)</span><br><span class="line">    -Xint             仅解释模式执行</span><br><span class="line">    -Xbootclasspath:&lt;用 : 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      设置搜索路径以引导类和资源</span><br><span class="line">    -Xbootclasspath/a:&lt;用 : 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      附加在引导类路径末尾</span><br><span class="line">    -Xbootclasspath/p:&lt;用 : 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      置于引导类路径之前</span><br><span class="line">    -Xdiag            显示附加诊断消息</span><br><span class="line">    -Xnoclassgc       禁用类垃圾收集</span><br><span class="line">    -Xincgc           启用增量垃圾收集</span><br><span class="line">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)</span><br><span class="line">    -Xbatch           禁用后台编译</span><br><span class="line">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class="line">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class="line">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class="line">    -Xprof            输出 cpu 配置文件数据</span><br><span class="line">    -Xfuture          启用最严格的检查, 预期将来的默认值</span><br><span class="line">    -Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)</span><br><span class="line">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class="line">    -Xshare:off       不尝试使用共享类数据</span><br><span class="line">    -Xshare:auto      在可能的情况下使用共享类数据 (默认)</span><br><span class="line">    -Xshare:on        要求使用共享类数据, 否则将失败。</span><br><span class="line">    -XshowSettings    显示所有设置并继续</span><br><span class="line">    -XshowSettings:all</span><br><span class="line">                      显示所有设置并继续</span><br><span class="line">    -XshowSettings:vm 显示所有与 vm 相关的设置并继续</span><br><span class="line">    -XshowSettings:properties</span><br><span class="line">                      显示所有属性设置并继续</span><br><span class="line">    -XshowSettings:locale</span><br><span class="line">                      显示所有与区域设置相关的设置并继续</span><br><span class="line"></span><br><span class="line">-X 选项是非标准选项, 如有更改, 恕不另行通知。</span><br></pre></td></tr></table></figure><h4 id="2-3-1、-Xint、-Xcomp、-Xmixed"><a href="#2-3-1、-Xint、-Xcomp、-Xmixed" class="headerlink" title="2.3.1、-Xint、-Xcomp、-Xmixed"></a>2.3.1、-Xint、-Xcomp、-Xmixed</h4><ul><li>在解释模式(interpreted mode)下，-Xint标记会强制JVM执行所有的字节码，当然这会降低运行速度，通常低10倍或更多。</li><li>-Xcomp参数与它（-Xint）正好相反，JVM在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。<ul><li>然而，很多应用在使用-Xcomp也会有一些性能损失，当然这比使用-Xint损失的少，原因是-xcomp没有让JVM启用JIT编译器的全部功能。JIT编译器可以对是否需要编译做判断，如果所有代码都进行编译的话，对于一些只执行一次的代码就没有意义了。</li></ul></li><li>-Xmixed是混合模式，将解释模式与编译模式进行混合使用，由jvm自己决定，这是jvm默认的模式，也是推荐使用的模式。</li></ul><p>示例：强制设置运行模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">强制设置为解释模式</span></span><br><span class="line">[root@node01 test]# java  -showversion -Xint TestJVM</span><br><span class="line">java version "1.8.0_141"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, interpreted mode)</span><br><span class="line"></span><br><span class="line">bestqiang</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">强制设置为编译模式</span></span><br><span class="line">[root@node01 test]# java  -showversion -Xcomp TestJVM</span><br><span class="line">java version "1.8.0_141"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, compiled mode)</span><br><span class="line"></span><br><span class="line">bestqiang</span><br><span class="line"><span class="meta">#</span><span class="bash">注意：编译模式下，第一次执行会比解释模式下执行慢一些，注意观察。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">默认的混合模式</span></span><br><span class="line">[root@node01 test]# java  -showversion TestJVM</span><br><span class="line">java version "1.8.0_141"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)</span><br><span class="line"></span><br><span class="line">bestqiang</span><br></pre></td></tr></table></figure><h3 id="2-4、-XX参数"><a href="#2-4、-XX参数" class="headerlink" title="2.4、-XX参数"></a>2.4、-XX参数</h3><p>-XX参数也是非标准参数，主要用于jvm的调优和debug操作。</p><p>-XX参数的使用有2种方式，一种是boolean类型，一种是非boolean类型：</p><ul><li>boolean类型<ul><li>格式：-XX:[+-]\<name> 表示启用或禁用\<name>属性</name></name></li><li>如：-XX:+DisableExplicitGC 表示禁用手动调用gc操作，也就是说调用System.gc()无效</li></ul></li><li>非boolean类型<ul><li>格式：-XX:\<name>=\<value>  表示\<name>属性的值为\<value></value></name></value></name></li><li>如：-XX:NewRatio=1 表示新生代和老年代的比值</li></ul></li></ul><p>用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 test]# java -showversion -XX:+DisableExplicitGC TestJVM</span><br><span class="line">java version "1.8.0_141"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)</span><br><span class="line"></span><br><span class="line">bestqiang</span><br></pre></td></tr></table></figure><h3 id="2-5、-Xms与-Xmx参数"><a href="#2-5、-Xms与-Xmx参数" class="headerlink" title="2.5、-Xms与-Xmx参数"></a>2.5、-Xms与-Xmx参数</h3><p>-Xms与-Xmx分别是设置jvm的堆内存的初始大小和最大大小。</p><p>-Xmx2048m：等价于-XX:MaxHeapSize，设置JVM最大堆内存为2048M。</p><p>-Xms512m：等价于-XX:InitialHeapSize，设置JVM初始堆内存为512M。</p><p>适当的调整jvm的内存大小，可以充分利用服务器资源，让程序跑的更快。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 test]# java -Xms512m -Xmx2048m TestJVM</span><br><span class="line">bestqiang</span><br></pre></td></tr></table></figure><h3 id="2-6、查看jvm的运行参数"><a href="#2-6、查看jvm的运行参数" class="headerlink" title="2.6、查看jvm的运行参数"></a>2.6、查看jvm的运行参数</h3><p>有些时候我们需要查看jvm的运行参数，这个需求可能会存在2种情况：</p><p>第一，运行java命令时打印出运行参数；</p><p>第二，查看正在运行的java进程的参数；</p><h4 id="2-6-1、运行java命令时打印参数"><a href="#2-6-1、运行java命令时打印参数" class="headerlink" title="2.6.1、运行java命令时打印参数"></a>2.6.1、运行java命令时打印参数</h4><p>运行java命令时打印参数，需要添加-XX:+PrintFlagsFinal参数即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 test]# java -XX:+PrintFlagsFinal -version</span><br><span class="line">[Global flags]</span><br><span class="line">    uintx AdaptiveSizeDecrementScaleFactor          = 4                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePausePolicy                   = 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyCollectionCostMargin    = 50                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyInitializingSteps       = 20                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyOutputInterval          = 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyWeight                  = 10                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeThroughPutPolicy              = 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveTimeWeight                        = 25                                  &#123;product&#125;</span><br><span class="line">     bool AdjustConcurrency                         = false                               &#123;product&#125;</span><br><span class="line">     bool AggressiveOpts                            = false                               &#123;product&#125;</span><br><span class="line">     intx AliasLevel                                = 3                                   &#123;C2 product&#125;</span><br><span class="line">     bool AlignVector                               = true                                &#123;C2 product&#125;</span><br><span class="line">     intx AllocateInstancePrefetchLines             = 1                                   &#123;product&#125;</span><br><span class="line">     intx AllocatePrefetchDistance                  = 256                                 &#123;product&#125;</span><br><span class="line">     intx AllocatePrefetchInstr                     = 0                                   &#123;product&#125;</span><br><span class="line">     </span><br><span class="line">     …………………………略…………………………………………</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">     bool UseXmmI2D                                 = false                               &#123;ARCH product&#125;</span><br><span class="line">     bool UseXmmI2F                                 = false                               &#123;ARCH product&#125;</span><br><span class="line">     bool UseXmmLoadAndClearUpper                   = true                                &#123;ARCH product&#125;</span><br><span class="line">     bool UseXmmRegToRegMoveAll                     = true                                &#123;ARCH product&#125;</span><br><span class="line">     bool VMThreadHintNoPreempt                     = false                               &#123;product&#125;</span><br><span class="line">     intx VMThreadPriority                          = -1                                  &#123;product&#125;</span><br><span class="line">     intx VMThreadStackSize                         = 1024                                &#123;pd product&#125;</span><br><span class="line">     intx ValueMapInitialSize                       = 11                                  &#123;C1 product&#125;</span><br><span class="line">     intx ValueMapMaxLoopSize                       = 8                                   &#123;C1 product&#125;</span><br><span class="line">     intx ValueSearchLimit                          = 1000                                &#123;C2 product&#125;</span><br><span class="line">     bool VerifyMergedCPBytecodes                   = true                                &#123;product&#125;</span><br><span class="line">     bool VerifySharedSpaces                        = false                               &#123;product&#125;</span><br><span class="line">     intx WorkAroundNPTLTimedWaitHang               = 1                                   &#123;product&#125;</span><br><span class="line">    uintx YoungGenerationSizeIncrement              = 20                                  &#123;product&#125;</span><br><span class="line">    uintx YoungGenerationSizeSupplement             = 80                                  &#123;product&#125;</span><br><span class="line">    uintx YoungGenerationSizeSupplementDecay        = 8                                   &#123;product&#125;</span><br><span class="line">    uintx YoungPLABSize                             = 4096                                &#123;product&#125;</span><br><span class="line">     bool ZeroTLAB                                  = false                               &#123;product&#125;</span><br><span class="line">     intx hashCode                                  = 5                                   &#123;product&#125;</span><br><span class="line">java version "1.8.0_141"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)</span><br></pre></td></tr></table></figure><p>由上述的信息可以看出，参数有boolean类型和数字类型，值的操作符是=或:=，分别代表默认值和被修改的值。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -XX:+VerifySharedSpaces -version</span><br><span class="line"></span><br><span class="line">     intx ValueMapInitialSize                       = 11                                  &#123;C1 product&#125;</span><br><span class="line">     intx ValueMapMaxLoopSize                       = 8                                   &#123;C1 product&#125;</span><br><span class="line">     intx ValueSearchLimit                          = 1000                                &#123;C2 product&#125;</span><br><span class="line">     bool VerifyMergedCPBytecodes                   = true                                &#123;product&#125;</span><br><span class="line">     bool VerifySharedSpaces                       := true                                &#123;product&#125;</span><br><span class="line">     intx WorkAroundNPTLTimedWaitHang               = 1                                   &#123;product&#125;</span><br><span class="line">    uintx YoungGenerationSizeIncrement              = 20                                  &#123;product&#125;</span><br><span class="line">    uintx YoungGenerationSizeSupplement             = 80                                  &#123;product&#125;</span><br><span class="line">    uintx YoungGenerationSizeSupplementDecay        = 8                                   &#123;product&#125;</span><br><span class="line">    uintx YoungPLABSize                             = 4096                                &#123;product&#125;</span><br><span class="line">     bool ZeroTLAB                                  = false                               &#123;product&#125;</span><br><span class="line">     intx hashCode                                  = 5                                   &#123;product&#125;</span><br><span class="line">java version "1.8.0_141"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">可以看到VerifySharedSpaces这个参数已经被修改了。</span></span><br></pre></td></tr></table></figure><h4 id="2-6-2、查看正在运行的jvm参数"><a href="#2-6-2、查看正在运行的jvm参数" class="headerlink" title="2.6.2、查看正在运行的jvm参数"></a>2.6.2、查看正在运行的jvm参数</h4><p>如果想要查看正在运行的jvm就需要借助于jinfo命令查看。</p><p>首先，启动一个tomcat用于测试，来观察下运行的jvm参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp/</span><br><span class="line">rz 上传</span><br><span class="line">tar -xvf apache-tomcat-7.0.57.tar.gz </span><br><span class="line">cd apache-tomcat-7.0.57</span><br><span class="line">cd bin/</span><br><span class="line">./startup.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">http://192.168.40.133:8080/ 进行访问</span></span><br></pre></td></tr></table></figure><p>访问成功： <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536488631901.png" alt="1536488631901"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看所有的参数，用法：jinfo -flags &lt;进程id&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">通过jps 或者  jps -l 查看java进程</span></span><br><span class="line">[root@node01 bin]# jps</span><br><span class="line">6346 Jps</span><br><span class="line">6219 Bootstrap</span><br><span class="line">[root@node01 bin]# jps -l</span><br><span class="line">6358 sun.tools.jps.Jps</span><br><span class="line">6219 org.apache.catalina.startup.Bootstrap</span><br><span class="line">[root@node01 bin]#</span><br><span class="line"></span><br><span class="line">[root@node01 bin]# jinfo -flags 6219</span><br><span class="line">Attaching to process ID 6219, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.141-b15</span><br><span class="line">Non-default VM flags: -XX:CICompilerCount=2 -XX:InitialHeapSize=31457280 -XX:MaxHeapSize=488636416 -XX:MaxNewSize=162529280 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=10485760 -XX:OldSize=20971520 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC </span><br><span class="line">Command line:  -Djava.util.logging.config.file=/tmp/apache-tomcat-7.0.57/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djava.endorsed.dirs=/tmp/apache-tomcat-7.0.57/endorsed -Dcatalina.base=/tmp/apache-tomcat-7.0.57 -Dcatalina.home=/tmp/apache-tomcat-7.0.57 -Djava.io.tmpdir=/tmp/apache-tomcat-7.0.57/temp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看某一参数的值，用法：jinfo -flag &lt;参数名&gt; &lt;进程id&gt;</span></span><br><span class="line">[root@node01 bin]# jinfo -flag MaxHeapSize 6219</span><br><span class="line">-XX:MaxHeapSize=488636416</span><br></pre></td></tr></table></figure><h2 id="3、jvm的内存结构"><a href="#3、jvm的内存结构" class="headerlink" title="3、jvm的内存结构"></a>3、jvm的内存结构</h2><p>jvm的内存结构在1.7和1.8有较大的区别，虽然本套课程是以1.8为例进行讲解，但是我们也是需要对1.7的内存结构有所了解，所以接下里，我们将先学习1.7再学习1.8的内存结构。</p><h3 id="3-1、jdk1-7的堆内存结构"><a href="#3-1、jdk1-7的堆内存结构" class="headerlink" title="3.1、jdk1.7的堆内存结构"></a>3.1、jdk1.7的堆内存结构</h3><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536501289198.png" alt="1536501289198"></p><ul><li><p>Young 年轻区（代）</p><p>Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用，在Eden区间变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。</p></li><li><p>Tenured 年老区</p><p>Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区，一般如果系统中用了application级别的缓存，缓存中的对象往往会被转移到这一区间。</p></li><li><p>Perm 永久区</p><p>Perm代主要保存class,method,filed对象，这部份的空间一般不会溢出，除非一次性加载了很多的类，不过在涉及到热部署的应用服务器的时候，有时候会遇到java.lang.OutOfMemoryError : PermGen space 的错误，造成这个错误的很大原因就有可能是每次都重新部署，但是重新部署后，类的class没有被卸载掉，这样就造成了大量的class对象保存在了perm中，这种情况下，一般重新启动应用服务器可以解决问题。</p></li><li><p>Virtual区：</p><ul><li>最大内存和初始内存的差值，就是Virtual区。</li></ul></li></ul><h3 id="3-2、jdk1-8的堆内存结构"><a href="#3-2、jdk1-8的堆内存结构" class="headerlink" title="3.2、jdk1.8的堆内存结构"></a>3.2、jdk1.8的堆内存结构</h3><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536501652150.png" alt="1536501652150"></p><p>由上图可以看出，jdk1.8的内存结构是由2部分组成，年轻代 + 年老代。</p><p>年轻代：Eden + 2*Survivor</p><p>年老代：OldGen</p><p>在jdk1.8中变化最大的Perm区，用Metaspace（元数据空间）进行了替换。</p><p>需要特别说明的是：Metaspace所占用的内存空间不是在虚拟机内部，而是在本地内存空间中，这也是与1.7的永久代最大的区别所在。 </p><pre><code>![1536507420882](JVM优化基础和JDK工具的使用/1536507420882.png)</code></pre><h3 id="3-3、为什么要废弃1-7中的永久区？"><a href="#3-3、为什么要废弃1-7中的永久区？" class="headerlink" title="3.3、为什么要废弃1.7中的永久区？"></a>3.3、为什么要废弃1.7中的永久区？</h3><p>官网给出了解释：<a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">http://openjdk.java.net/jeps/122</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.</span><br><span class="line"></span><br><span class="line">移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</span><br></pre></td></tr></table></figure><p>现实使用中，由于永久代内存经常不够用或发生内存泄露，爆出异常java.lang.OutOfMemoryError: PermGen。</p><p>基于此，将永久区废弃，而改用元空间，改为了使用本地内存空间。</p><h3 id="3-4、通过jstat命令进行查看堆内存使用情况"><a href="#3-4、通过jstat命令进行查看堆内存使用情况" class="headerlink" title="3.4、通过jstat命令进行查看堆内存使用情况"></a>3.4、通过jstat命令进行查看堆内存使用情况</h3><p>jstat命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下：</p><p>jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]</p><h4 id="3-4-1、查看class加载统计"><a href="#3-4-1、查看class加载统计" class="headerlink" title="3.4.1、查看class加载统计"></a>3.4.1、查看class加载统计</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# jps</span><br><span class="line">7080 Jps</span><br><span class="line">6219 Bootstrap</span><br><span class="line"></span><br><span class="line">[root@node01 ~]# jstat -class 6219</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line">  3273  7122.3        0     0.0       3.98</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>Loaded：加载class的数量</li><li>Bytes：所占用空间大小</li><li>Unloaded：未加载数量</li><li>Bytes：未加载占用空间</li><li>Time：时间</li></ul><h4 id="3-4-2、查看编译统计"><a href="#3-4-2、查看编译统计" class="headerlink" title="3.4.2、查看编译统计"></a>3.4.2、查看编译统计</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# jstat -compiler 6219</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">    2376      1       0     8.04          1 org/apache/tomcat/util/IntrospectionUtils setProperty</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>Compiled：编译数量。</li><li>Failed：失败数量</li><li>Invalid：不可用数量</li><li>Time：时间</li><li>FailedType：失败类型</li><li>FailedMethod：失败的方法</li></ul><h4 id="3-4-3、垃圾回收统计"><a href="#3-4-3、垃圾回收统计" class="headerlink" title="3.4.3、垃圾回收统计"></a>3.4.3、垃圾回收统计</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# jstat -gc 6219</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">9216.0 8704.0  0.0   6127.3 62976.0   3560.4   33792.0    20434.9   23808.0 23196.1 2560.0 2361.6      7    1.078   1      0.244    1.323</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">也可以指定打印的间隔和次数，每1秒中打印一次，共打印5次</span></span><br><span class="line">[root@node01 ~]# jstat -gc 6219 1000 5</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">9216.0 8704.0  0.0   6127.3 62976.0   3917.3   33792.0    20434.9   23808.0 23196.1 2560.0 2361.6      7    1.078   1      0.244    1.323</span><br><span class="line">9216.0 8704.0  0.0   6127.3 62976.0   3917.3   33792.0    20434.9   23808.0 23196.1 2560.0 2361.6      7    1.078   1      0.244    1.323</span><br><span class="line">9216.0 8704.0  0.0   6127.3 62976.0   3917.3   33792.0    20434.9   23808.0 23196.1 2560.0 2361.6      7    1.078   1      0.244    1.323</span><br><span class="line">9216.0 8704.0  0.0   6127.3 62976.0   3917.3   33792.0    20434.9   23808.0 23196.1 2560.0 2361.6      7    1.078   1      0.244    1.323</span><br><span class="line">9216.0 8704.0  0.0   6127.3 62976.0   3917.3   33792.0    20434.9   23808.0 23196.1 2560.0 2361.6      7    1.078   1      0.244    1.323</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>S0C：第一个Survivor区的大小（KB）</li><li>S1C：第二个Survivor区的大小（KB）</li><li>S0U：第一个Survivor区的使用大小（KB）</li><li>S1U：第二个Survivor区的使用大小（KB）</li><li>EC：Eden区的大小（KB）</li><li>EU：Eden区的使用大小（KB）</li><li>OC：Old区大小（KB）</li><li>OU：Old使用大小（KB）</li><li>MC：方法区大小（KB）</li><li>MU：方法区使用大小（KB）</li><li>CCSC：压缩类空间大小（KB）</li><li>CCSU：压缩类空间使用大小（KB）</li><li>YGC：年轻代垃圾回收次数</li><li>YGCT：年轻代垃圾回收消耗时间</li><li>FGC：老年代垃圾回收次数</li><li>FGCT：老年代垃圾回收消耗时间</li><li>GCT：垃圾回收消耗总时间</li></ul><h2 id="4、jmap的使用以及内存溢出分析"><a href="#4、jmap的使用以及内存溢出分析" class="headerlink" title="4、jmap的使用以及内存溢出分析"></a>4、jmap的使用以及内存溢出分析</h2><p>前面通过jstat可以对jvm堆的内存进行统计分析，而jmap可以获取到更加详细的内容，如：内存使用情况的汇总、对内存溢出的定位与分析。</p><h3 id="4-1、查看内存使用情况"><a href="#4-1、查看内存使用情况" class="headerlink" title="4.1、查看内存使用情况"></a>4.1、查看内存使用情况</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# jmap -heap 6219</span><br><span class="line">Attaching to process ID 6219, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.141-b15</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 2 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration: #堆内存配置信息</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 488636416 (466.0MB)</span><br><span class="line">   NewSize                  = 10485760 (10.0MB)</span><br><span class="line">   MaxNewSize               = 162529280 (155.0MB)</span><br><span class="line">   OldSize                  = 20971520 (20.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage: # 堆内存的使用情况</span><br><span class="line">PS Young Generation #年轻代</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 123731968 (118.0MB)</span><br><span class="line">   used     = 1384736 (1.320587158203125MB)</span><br><span class="line">   free     = 122347232 (116.67941284179688MB)</span><br><span class="line">   1.1191416594941737% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 9437184 (9.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 9437184 (9.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 9437184 (9.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 9437184 (9.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation #年老代</span><br><span class="line">   capacity = 28311552 (27.0MB)</span><br><span class="line">   used     = 13698672 (13.064071655273438MB)</span><br><span class="line">   free     = 14612880 (13.935928344726562MB)</span><br><span class="line">   48.38545057508681% used</span><br><span class="line"></span><br><span class="line">13648 interned Strings occupying 1866368 bytes.</span><br></pre></td></tr></table></figure><h3 id="4-2、查看内存中对象数量及大小"><a href="#4-2、查看内存中对象数量及大小" class="headerlink" title="4.2、查看内存中对象数量及大小"></a>4.2、查看内存中对象数量及大小</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看所有对象，包括活跃以及非活跃的</span></span><br><span class="line">jmap -histo &lt;pid&gt; | more</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看活跃对象</span></span><br><span class="line">jmap -histo:live &lt;pid&gt; | more</span><br><span class="line"></span><br><span class="line">[root@node01 ~]# jmap -histo:live 6219 | more</span><br><span class="line"></span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:         37437        7914608  [C</span><br><span class="line">   2:         34916         837984  java.lang.String</span><br><span class="line">   3:           884         654848  [B</span><br><span class="line">   4:         17188         550016  java.util.HashMap$Node</span><br><span class="line">   5:          3674         424968  java.lang.Class</span><br><span class="line">   6:          6322         395512  [Ljava.lang.Object;</span><br><span class="line">   7:          3738         328944  java.lang.reflect.Method</span><br><span class="line">   8:          1028         208048  [Ljava.util.HashMap$Node;</span><br><span class="line">   9:          2247         144264  [I</span><br><span class="line">  10:          4305         137760  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">  11:          1270         109080  [Ljava.lang.String;</span><br><span class="line">  12:            64          84128  [Ljava.util.concurrent.ConcurrentHashMap$Node;</span><br><span class="line">  13:          1714          82272  java.util.HashMap</span><br><span class="line">  14:          3285          70072  [Ljava.lang.Class;</span><br><span class="line">  15:          2888          69312  java.util.ArrayList</span><br><span class="line">  16:          3983          63728  java.lang.Object</span><br><span class="line">  17:          1271          61008  org.apache.tomcat.util.digester.CallMethodRule</span><br><span class="line">  18:          1518          60720  java.util.LinkedHashMap$Entry</span><br><span class="line">  19:          1671          53472  com.sun.org.apache.xerces.internal.xni.QName</span><br><span class="line">  20:            88          50880  [Ljava.util.WeakHashMap$Entry;</span><br><span class="line">  21:           618          49440  java.lang.reflect.Constructor</span><br><span class="line">  22:          1545          49440  java.util.Hashtable$Entry</span><br><span class="line">  23:          1027          41080  java.util.TreeMap$Entry</span><br><span class="line">  24:           846          40608  org.apache.tomcat.util.modeler.AttributeInfo</span><br><span class="line">  25:           142          38032  [S</span><br><span class="line">  26:           946          37840  java.lang.ref.SoftReference</span><br><span class="line">  27:           226          36816  [[C</span><br><span class="line">  。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。</span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash">对象说明</span></span><br><span class="line">B  byte</span><br><span class="line">C  char</span><br><span class="line">D  double</span><br><span class="line">F  float</span><br><span class="line">I  int</span><br><span class="line">J  long</span><br><span class="line">Z  boolean</span><br><span class="line">[  数组，如[I表示int[]</span><br><span class="line">[L+类名 其他对象</span><br></pre></td></tr></table></figure><h3 id="4-3、将内存使用情况dump到文件中"><a href="#4-3、将内存使用情况dump到文件中" class="headerlink" title="4.3、将内存使用情况dump到文件中"></a>4.3、将内存使用情况dump到文件中</h3><p>有些时候我们需要将jvm当前内存中的情况dump到文件中，然后对它进行分析，jmap也是支持dump到文件中的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">用法：</span></span><br><span class="line">jmap -dump:format=b,file=dumpFileName &lt;pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">示例</span></span><br><span class="line">jmap -dump:format=b,file=/tmp/dump.dat 6219</span><br></pre></td></tr></table></figure><p>  <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536512769514.png" alt="1536512769514"></p><p>可以看到已经在/tmp下生成了dump.dat的文件。</p><h3 id="4-4、通过jhat对dump文件进行分析"><a href="#4-4、通过jhat对dump文件进行分析" class="headerlink" title="4.4、通过jhat对dump文件进行分析"></a>4.4、通过jhat对dump文件进行分析</h3><p>在上一小节中，我们将jvm的内存dump到文件中，这个文件是一个二进制的文件，不方便查看，这时我们可以借助于jhat工具进行查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">用法：</span></span><br><span class="line">jhat -port &lt;port&gt; &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">示例：</span></span><br><span class="line">[root@node01 tmp]# jhat -port 9999 /tmp/dump.dat </span><br><span class="line">Reading from /tmp/dump.dat...</span><br><span class="line">Dump file created Mon Sep 10 01:04:21 CST 2018</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 204094 objects...</span><br><span class="line">Chasing references, expect 40 dots........................................</span><br><span class="line">Eliminating duplicate references........................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 9999</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure><p>打开浏览器进行访问：<a href="http://192.168.40.133:9999/" target="_blank" rel="noopener">http://192.168.40.133:9999/</a></p><p><img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536513416186.png" alt="1536513416186"></p><p>在最后面有OQL查询功能。</p><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536513474958.png" alt="1536513474958"></p><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536513591638.png" alt="1536513591638"></p><h3 id="4-5、通过MAT工具对dump文件进行分析"><a href="#4-5、通过MAT工具对dump文件进行分析" class="headerlink" title="4.5、通过MAT工具对dump文件进行分析"></a>4.5、通过MAT工具对dump文件进行分析</h3><h4 id="4-5-1、MAT工具介绍"><a href="#4-5-1、MAT工具介绍" class="headerlink" title="4.5.1、MAT工具介绍"></a>4.5.1、MAT工具介绍</h4><p>MAT(Memory Analyzer Tool)，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的JAVA heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。</p><p>官网地址：<a href="https://www.eclipse.org/mat/" target="_blank" rel="noopener">https://www.eclipse.org/mat/</a></p><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536515331814.png" alt="1536515331814"></p><h4 id="4-5-2、下载安装"><a href="#4-5-2、下载安装" class="headerlink" title="4.5.2、下载安装"></a>4.5.2、下载安装</h4><p>下载地址：<a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">https://www.eclipse.org/mat/downloads.php</a></p><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536515395914.png" alt="1536515395914"></p><p>将下载得到的MemoryAnalyzer-1.8.0.20180604-win32.win32.x86_64.zip进行解压：</p><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536515524838.png" alt="1536515524838"></p><h4 id="4-5-3、使用"><a href="#4-5-3、使用" class="headerlink" title="4.5.3、使用"></a>4.5.3、使用</h4><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536515700264.png" alt="1536515700264"></p><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536515764096.png" alt="1536515764096"></p><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536515922938.png" alt="1536515922938"></p><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536516001249.png" alt="1536516001249"></p><p>查看对象以及它的依赖： </p><p><img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536516171924.png" alt="1536516171924"></p><p>查看可能存在内存泄露的分析： <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536516259369.png" alt="1536516259369"></p><h2 id="5、实战：内存溢出的定位与分析"><a href="#5、实战：内存溢出的定位与分析" class="headerlink" title="5、实战：内存溢出的定位与分析"></a>5、实战：内存溢出的定位与分析</h2><p>内存溢出在实际的生产环境中经常会遇到，比如，不断的将数据写入到一个集合中，出现了死循环，读取超大的文件等等，都可能会造成内存溢出。</p><p>如果出现了内存溢出，首先我们需要定位到发生内存溢出的环节，并且进行分析，是正常还是非正常情况，如果是正常的需求，就应该考虑加大内存的设置，如果是非正常需求，那么就要对代码进行修改，修复这个bug。</p><p>首先，我们得先学会如何定位问题，然后再进行分析。如何定位问题呢，我们需要借助于jmap与MAT工具进行定位分析。</p><p>接下来，我们模拟内存溢出的场景。</p><h3 id="5-1、模拟内存溢出"><a href="#5-1、模拟内存溢出" class="headerlink" title="5.1、模拟内存溢出"></a>5.1、模拟内存溢出</h3><p>编写代码，向List集合中添加100万个字符串，每个字符串由1000个UUID组成。如果程序能够正常执行，最后打印ok。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bestqiang.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJvmOutOfMemory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            String str = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                str += UUID.randomUUID().toString();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了演示效果，我们将设置执行的参数，这里使用的是Idea编辑器。</p><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536591244437.png" alt="1536591244437"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">参数如下：</span></span><br><span class="line">-Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure><h3 id="5-2、运行测试"><a href="#5-2、运行测试" class="headerlink" title="5.2、运行测试"></a>5.2、运行测试</h3><p>测试结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid5348.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">8137186</span> bytes in <span class="number">0.032</span> secs]</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:<span class="number">3332</span>)</span><br><span class="line">at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:<span class="number">124</span>)</span><br><span class="line">at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:<span class="number">448</span>)</span><br><span class="line">at java.lang.StringBuilder.append(StringBuilder.java:<span class="number">136</span>)</span><br><span class="line">at cn.bestqiang.jvm.TestJvmOutOfMemory.main(TestJvmOutOfMemory.java:<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到，当发生内存溢出时，会dump文件到java_pid5348.hprof。 <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536591747657.png" alt="1536591747657"></p><h3 id="5-3、导入到MAT工具中进行分析"><a href="#5-3、导入到MAT工具中进行分析" class="headerlink" title="5.3、导入到MAT工具中进行分析"></a>5.3、导入到MAT工具中进行分析</h3><p><img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536592135948.png" alt="1536592135948"></p><p>可以看到，有91.03%的内存由Object[]数组占有，所以比较可疑。</p><p>分析：这个可疑是正确的，因为已经有超过90%的内存都被它占有，这是非常有可能出现内存溢出的。</p><p>查看详情：</p><p><img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536594010544.png" alt="1536594010544"></p><p>可以看到集合中存储了大量的uuid字符串。</p><h2 id="6、jstack的使用"><a href="#6、jstack的使用" class="headerlink" title="6、jstack的使用"></a>6、jstack的使用</h2><p>有些时候我们需要查看下jvm中的线程执行情况，比如，发现服务器的CPU的负载突然增高了、出现了死锁、死循环等，我们该如何分析呢？</p><p>由于程序是正常运行的，没有任何的输出，从日志方面也看不出什么问题，所以就需要看下jvm的内部线程的执行情况，然后再进行分析查找出原因。</p><p>这个时候，就需要借助于jstack命令了，jstack的作用是将正在运行的jvm的线程情况进行快照，并且打印出来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">用法：jstack &lt;pid&gt;</span></span><br><span class="line"></span><br><span class="line">[root@node01 bin]# jstack 2203</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.141-b15 mixed mode):</span><br><span class="line"></span><br><span class="line">"Attach Listener" #24 daemon prio=9 os_prio=0 tid=0x00007fabb4001000 nid=0x906 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"http-bio-8080-exec-5" #23 daemon prio=5 os_prio=0 tid=0x00007fabb057c000 nid=0x8e1 waiting on condition [0x00007fabd05b8000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x00000000f8508360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"http-bio-8080-exec-4" #22 daemon prio=5 os_prio=0 tid=0x00007fab9c113800 nid=0x8e0 waiting on condition [0x00007fabd06b9000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x00000000f8508360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"http-bio-8080-exec-3" #21 daemon prio=5 os_prio=0 tid=0x0000000001aeb800 nid=0x8df waiting on condition [0x00007fabd09ba000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x00000000f8508360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"http-bio-8080-exec-2" #20 daemon prio=5 os_prio=0 tid=0x0000000001aea000 nid=0x8de waiting on condition [0x00007fabd0abb000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x00000000f8508360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"http-bio-8080-exec-1" #19 daemon prio=5 os_prio=0 tid=0x0000000001ae8800 nid=0x8dd waiting on condition [0x00007fabd0bbc000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x00000000f8508360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"ajp-bio-8009-AsyncTimeout" #17 daemon prio=5 os_prio=0 tid=0x00007fabe8128000 nid=0x8d0 waiting on condition [0x00007fabd0ece000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at org.apache.tomcat.util.net.JIoEndpoint$AsyncTimeout.run(JIoEndpoint.java:152)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"ajp-bio-8009-Acceptor-0" #16 daemon prio=5 os_prio=0 tid=0x00007fabe82d4000 nid=0x8cf runnable [0x00007fabd0fcf000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.net.PlainSocketImpl.socketAccept(Native Method)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)</span><br><span class="line">at java.net.ServerSocket.implAccept(ServerSocket.java:545)</span><br><span class="line">at java.net.ServerSocket.accept(ServerSocket.java:513)</span><br><span class="line">at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket(DefaultServerSocketFactory.java:60)</span><br><span class="line">at org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:220)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"http-bio-8080-AsyncTimeout" #15 daemon prio=5 os_prio=0 tid=0x00007fabe82d1800 nid=0x8ce waiting on condition [0x00007fabd10d0000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at org.apache.tomcat.util.net.JIoEndpoint$AsyncTimeout.run(JIoEndpoint.java:152)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"http-bio-8080-Acceptor-0" #14 daemon prio=5 os_prio=0 tid=0x00007fabe82d0000 nid=0x8cd runnable [0x00007fabd11d1000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.net.PlainSocketImpl.socketAccept(Native Method)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)</span><br><span class="line">at java.net.ServerSocket.implAccept(ServerSocket.java:545)</span><br><span class="line">at java.net.ServerSocket.accept(ServerSocket.java:513)</span><br><span class="line">at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket(DefaultServerSocketFactory.java:60)</span><br><span class="line">at org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:220)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"ContainerBackgroundProcessor[StandardEngine[Catalina]]" #13 daemon prio=5 os_prio=0 tid=0x00007fabe82ce000 nid=0x8cc waiting on condition [0x00007fabd12d2000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1513)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"GC Daemon" #10 daemon prio=2 os_prio=0 tid=0x00007fabe83b4000 nid=0x8b3 in Object.wait() [0x00007fabd1c2f000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;0x00000000e315c2d0&gt; (a sun.misc.GC$LatencyLock)</span><br><span class="line">at sun.misc.GC$Daemon.run(GC.java:117)</span><br><span class="line">- locked &lt;0x00000000e315c2d0&gt; (a sun.misc.GC$LatencyLock)</span><br><span class="line"></span><br><span class="line">"Service Thread" #7 daemon prio=9 os_prio=0 tid=0x00007fabe80c3800 nid=0x8a5 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"C1 CompilerThread1" #6 daemon prio=9 os_prio=0 tid=0x00007fabe80b6800 nid=0x8a4 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"C2 CompilerThread0" #5 daemon prio=9 os_prio=0 tid=0x00007fabe80b3800 nid=0x8a3 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"Signal Dispatcher" #4 daemon prio=9 os_prio=0 tid=0x00007fabe80b2000 nid=0x8a2 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"Finalizer" #3 daemon prio=8 os_prio=0 tid=0x00007fabe807f000 nid=0x8a1 in Object.wait() [0x00007fabd2a67000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;0x00000000e3162918&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)</span><br><span class="line">- locked &lt;0x00000000e3162918&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)</span><br><span class="line">at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)</span><br><span class="line"></span><br><span class="line">"Reference Handler" #2 daemon prio=10 os_prio=0 tid=0x00007fabe807a800 nid=0x8a0 in Object.wait() [0x00007fabd2b68000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;0x00000000e3162958&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">at java.lang.Object.wait(Object.java:502)</span><br><span class="line">at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">- locked &lt;0x00000000e3162958&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)</span><br><span class="line"></span><br><span class="line">"main" #1 prio=5 os_prio=0 tid=0x00007fabe8009000 nid=0x89c runnable [0x00007fabed210000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.net.PlainSocketImpl.socketAccept(Native Method)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)</span><br><span class="line">at java.net.ServerSocket.implAccept(ServerSocket.java:545)</span><br><span class="line">at java.net.ServerSocket.accept(ServerSocket.java:513)</span><br><span class="line">at org.apache.catalina.core.StandardServer.await(StandardServer.java:453)</span><br><span class="line">at org.apache.catalina.startup.Catalina.await(Catalina.java:777)</span><br><span class="line">at org.apache.catalina.startup.Catalina.start(Catalina.java:723)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:321)</span><br><span class="line">at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:455)</span><br><span class="line"></span><br><span class="line">"VM Thread" os_prio=0 tid=0x00007fabe8073000 nid=0x89f runnable </span><br><span class="line"></span><br><span class="line">"GC task thread#0 (ParallelGC)" os_prio=0 tid=0x00007fabe801e000 nid=0x89d runnable </span><br><span class="line"></span><br><span class="line">"GC task thread#1 (ParallelGC)" os_prio=0 tid=0x00007fabe8020000 nid=0x89e runnable </span><br><span class="line"></span><br><span class="line">"VM Periodic Task Thread" os_prio=0 tid=0x00007fabe80d6800 nid=0x8a6 waiting on condition </span><br><span class="line"></span><br><span class="line">JNI global references: 43</span><br></pre></td></tr></table></figure><h3 id="6-1、线程的状态"><a href="#6-1、线程的状态" class="headerlink" title="6.1、线程的状态"></a>6.1、线程的状态</h3><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536601656694.png" alt="1536601656694"></p><p>在Java中线程的状态一共被分成6种：</p><ul><li>初始态（NEW）<ul><li>创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。</li></ul></li><li>运行态（RUNNABLE），在Java中，运行态包括 就绪态 和 运行态。<ul><li>就绪态<ul><li>该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。</li><li>所有就绪态的线程存放在就绪队列中。</li></ul></li><li>运行态<ul><li>获得CPU执行权，正在执行的线程。</li><li>由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。</li></ul></li></ul></li><li>阻塞态（BLOCKED）<ul><li>当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。</li><li>而在Java中，阻塞态专指请求锁失败时进入的状态。</li><li>由一个阻塞队列存放所有阻塞态的线程。</li><li>处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。</li></ul></li><li>等待态（WAITING）<ul><li>当前线程中调用wait、join、park函数时，当前线程就会进入等待态。</li><li>也有一个等待队列存放所有等待态的线程。</li><li>线程处于等待态表示它需要等待其他线程的指示才能继续运行。</li><li>进入等待态的线程会释放CPU执行权，并释放资源（如：锁）</li></ul></li><li>超时等待态（TIMED_WAITING）<ul><li>当运行中的线程调用sleep(time)、wait、join、parkNanos、parkUntil时，就会进入该状态；</li><li>它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒；</li><li>进入该状态后释放CPU执行权 和 占有的资源。</li><li>与等待态的区别：到了超时时间后自动进入阻塞队列，开始竞争锁。</li></ul></li><li>终止态（TERMINATED）<ul><li>线程执行结束后的状态。</li></ul></li></ul><h3 id="6-2、实战：死锁问题"><a href="#6-2、实战：死锁问题" class="headerlink" title="6.2、实战：死锁问题"></a>6.2、实战：死锁问题</h3><p>如果在生产环境发生了死锁，我们将看到的是部署的程序没有任何反应了，这个时候我们可以借助jstack进行分析，下面我们实战下查找死锁的原因。</p><h4 id="6-2-1、构造死锁"><a href="#6-2-1、构造死锁" class="headerlink" title="6.2.1、构造死锁"></a>6.2.1、构造死锁</h4><p>编写代码，启动2个线程，Thread1拿到了obj1锁，准备去拿obj2锁时，obj2已经被Thread2锁定，所以发送了死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread1 拿到了 obj1 的锁！"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 停顿2秒的意义在于，让Thread2线程拿到obj2的锁</span></span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread1 拿到了 obj2 的锁！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj2)&#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread2 拿到了 obj2 的锁！"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 停顿2秒的意义在于，让Thread1线程拿到obj1的锁</span></span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (obj1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread2 拿到了 obj1 的锁！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-2、在linux上运行"><a href="#6-2-2、在linux上运行" class="headerlink" title="6.2.2、在linux上运行"></a>6.2.2、在linux上运行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 test]# javac TestDeadLock.java </span><br><span class="line">[root@node01 test]# ll</span><br><span class="line">总用量 28</span><br><span class="line">-rw-r--r--. 1 root root  184 9月  11 10:39 TestDeadLock$1.class</span><br><span class="line">-rw-r--r--. 1 root root  843 9月  11 10:39 TestDeadLock.class</span><br><span class="line">-rw-r--r--. 1 root root 1567 9月  11 10:39 TestDeadLock.java</span><br><span class="line">-rw-r--r--. 1 root root 1078 9月  11 10:39 TestDeadLock$Thread1.class</span><br><span class="line">-rw-r--r--. 1 root root 1078 9月  11 10:39 TestDeadLock$Thread2.class</span><br><span class="line">-rw-r--r--. 1 root root  573 9月   9 10:21 TestJVM.class</span><br><span class="line">-rw-r--r--. 1 root root  261 9月   9 10:21 TestJVM.java</span><br><span class="line"></span><br><span class="line">[root@node01 test]# java TestDeadLock</span><br><span class="line">Thread1 拿到了 obj1 的锁！</span><br><span class="line">Thread2 拿到了 obj2 的锁！</span><br><span class="line"><span class="meta">#</span><span class="bash">这里发生了死锁，程序一直将等待下去</span></span><br></pre></td></tr></table></figure><h4 id="6-2-3、使用jstack进行分析"><a href="#6-2-3、使用jstack进行分析" class="headerlink" title="6.2.3、使用jstack进行分析"></a>6.2.3、使用jstack进行分析</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# jstack 3256</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.141-b15 mixed mode):</span><br><span class="line"></span><br><span class="line">"Attach Listener" #11 daemon prio=9 os_prio=0 tid=0x00007f5bfc001000 nid=0xcff waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"DestroyJavaVM" #10 prio=5 os_prio=0 tid=0x00007f5c2c008800 nid=0xcb9 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"Thread-1" #9 prio=5 os_prio=0 tid=0x00007f5c2c0e9000 nid=0xcc5 waiting for monitor entry [0x00007f5c1c7f6000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at TestDeadLock$Thread2.run(TestDeadLock.java:47)</span><br><span class="line">- waiting to lock &lt;0x00000000f655dc40&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x00000000f655dc50&gt; (a java.lang.Object)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"Thread-0" #8 prio=5 os_prio=0 tid=0x00007f5c2c0e7000 nid=0xcc4 waiting for monitor entry [0x00007f5c1c8f7000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at TestDeadLock$Thread1.run(TestDeadLock.java:27)</span><br><span class="line">- waiting to lock &lt;0x00000000f655dc50&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x00000000f655dc40&gt; (a java.lang.Object)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"Service Thread" #7 daemon prio=9 os_prio=0 tid=0x00007f5c2c0d3000 nid=0xcc2 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"C1 CompilerThread1" #6 daemon prio=9 os_prio=0 tid=0x00007f5c2c0b6000 nid=0xcc1 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"C2 CompilerThread0" #5 daemon prio=9 os_prio=0 tid=0x00007f5c2c0b3000 nid=0xcc0 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"Signal Dispatcher" #4 daemon prio=9 os_prio=0 tid=0x00007f5c2c0b1800 nid=0xcbf runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"Finalizer" #3 daemon prio=8 os_prio=0 tid=0x00007f5c2c07e800 nid=0xcbe in Object.wait() [0x00007f5c1cdfc000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;0x00000000f6508ec8&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)</span><br><span class="line">- locked &lt;0x00000000f6508ec8&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)</span><br><span class="line">at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)</span><br><span class="line"></span><br><span class="line">"Reference Handler" #2 daemon prio=10 os_prio=0 tid=0x00007f5c2c07a000 nid=0xcbd in Object.wait() [0x00007f5c1cefd000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;0x00000000f6506b68&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">at java.lang.Object.wait(Object.java:502)</span><br><span class="line">at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">- locked &lt;0x00000000f6506b68&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)</span><br><span class="line"></span><br><span class="line">"VM Thread" os_prio=0 tid=0x00007f5c2c072800 nid=0xcbc runnable </span><br><span class="line"></span><br><span class="line">"GC task thread#0 (ParallelGC)" os_prio=0 tid=0x00007f5c2c01d800 nid=0xcba runnable </span><br><span class="line"></span><br><span class="line">"GC task thread#1 (ParallelGC)" os_prio=0 tid=0x00007f5c2c01f800 nid=0xcbb runnable </span><br><span class="line"></span><br><span class="line">"VM Periodic Task Thread" os_prio=0 tid=0x00007f5c2c0d6800 nid=0xcc3 waiting on condition </span><br><span class="line"></span><br><span class="line">JNI global references: 6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"Thread-1":</span><br><span class="line">  waiting to lock monitor 0x00007f5c080062c8 (object 0x00000000f655dc40, a java.lang.Object),</span><br><span class="line">  which is held by "Thread-0"</span><br><span class="line">"Thread-0":</span><br><span class="line">  waiting to lock monitor 0x00007f5c08004e28 (object 0x00000000f655dc50, a java.lang.Object),</span><br><span class="line">  which is held by "Thread-1"</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">"Thread-1":</span><br><span class="line">at TestDeadLock$Thread2.run(TestDeadLock.java:47)</span><br><span class="line">- waiting to lock &lt;0x00000000f655dc40&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x00000000f655dc50&gt; (a java.lang.Object)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">"Thread-0":</span><br><span class="line">at TestDeadLock$Thread1.run(TestDeadLock.java:27)</span><br><span class="line">- waiting to lock &lt;0x00000000f655dc50&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x00000000f655dc40&gt; (a java.lang.Object)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure><p>在输出的信息中，已经看到，发现了1个死锁，关键看这个：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"Thread-1":</span><br><span class="line">at TestDeadLock$Thread2.run(TestDeadLock.java:47)</span><br><span class="line">- waiting to lock &lt;0x00000000f655dc40&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x00000000f655dc50&gt; (a java.lang.Object)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">"Thread-0":</span><br><span class="line">at TestDeadLock$Thread1.run(TestDeadLock.java:27)</span><br><span class="line">- waiting to lock &lt;0x00000000f655dc50&gt; (a java.lang.Object)</span><br><span class="line">- locked &lt;0x00000000f655dc40&gt; (a java.lang.Object)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><p>可以清晰的看到：</p><ul><li>Thread2获取了 <0x00000000f655dc50> 的锁，等待获取 <0x00000000f655dc40> 这个锁</0x00000000f655dc40></0x00000000f655dc50></li><li>Thread1获取了 <0x00000000f655dc40> 的锁，等待获取 <0x00000000f655dc50> 这个锁</0x00000000f655dc50></0x00000000f655dc40></li><li>由此可见，发生了死锁。</li></ul><h2 id="7、VisualVM工具的使用"><a href="#7、VisualVM工具的使用" class="headerlink" title="7、VisualVM工具的使用"></a>7、VisualVM工具的使用</h2><p>VisualVM，能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈(如100个String对象分别由哪几个对象分配出来的)。</p><p>VisualVM使用简单，几乎0配置，功能还是比较丰富的，几乎囊括了其它JDK自带命令的所有功能。</p><ul><li>内存信息</li><li>线程信息</li><li>Dump堆（本地进程）</li><li>Dump线程（本地进程）</li><li>打开堆Dump。堆Dump可以用jmap来生成。</li><li>打开线程Dump</li><li>生成应用快照（包含内存信息、线程信息等等）</li><li>性能分析。CPU分析（各个方法调用时间，检查哪些方法耗时多），内存分析（各类对象占用的内存，检查哪些类占用内存多）</li><li>……</li></ul><h3 id="7-1、启动"><a href="#7-1、启动" class="headerlink" title="7.1、启动"></a>7.1、启动</h3><p>在jdk的安装目录的bin目录下，找到jvisualvm.exe，双击打开即可。</p><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536654243155.png" alt="1536654243155"></p><p><img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536654347046.png" alt="1536654347046"></p><h3 id="7-2、查看本地进程"><a href="#7-2、查看本地进程" class="headerlink" title="7.2、查看本地进程"></a>7.2、查看本地进程</h3><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536654611922.png" alt="1536654611922"></p><h3 id="7-3、查看CPU、内存、类、线程运行信息"><a href="#7-3、查看CPU、内存、类、线程运行信息" class="headerlink" title="7.3、查看CPU、内存、类、线程运行信息"></a>7.3、查看CPU、内存、类、线程运行信息</h3><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536654708421.png" alt="1536654708421"></p><h3 id="7-4、查看线程详情"><a href="#7-4、查看线程详情" class="headerlink" title="7.4、查看线程详情"></a>7.4、查看线程详情</h3><p><img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536654784904.png" alt="1536654784904"></p><p>也可以点击右上角Dump按钮，将线程的信息导出，其实就是执行的jstack命令。</p><p><img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536656468818.png" alt="1536656468818"></p><p>发现，显示的内容是一样的。</p><h3 id="7-5、抽样器"><a href="#7-5、抽样器" class="headerlink" title="7.5、抽样器"></a>7.5、抽样器</h3><p>抽样器可以对CPU、内存在一段时间内进行抽样，以供分析。</p><p><img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536678677028.png" alt="1536678677028"></p><h3 id="7-6、监控远程的jvm"><a href="#7-6、监控远程的jvm" class="headerlink" title="7.6、监控远程的jvm"></a>7.6、监控远程的jvm</h3><p>VisualJVM不仅是可以监控本地jvm进程，还可以监控远程的jvm进程，需要借助于JMX技术实现。</p><h4 id="7-6-1、什么是JMX？"><a href="#7-6-1、什么是JMX？" class="headerlink" title="7.6.1、什么是JMX？"></a>7.6.1、什么是JMX？</h4><p>JMX（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议，灵活的开发无缝集成的系统、网络和服务管理应用。</p><h4 id="7-6-2、监控远程的tomcat"><a href="#7-6-2、监控远程的tomcat" class="headerlink" title="7.6.2、监控远程的tomcat"></a>7.6.2、监控远程的tomcat</h4><p>想要监控远程的tomcat，就需要在远程的tomcat进行对JMX配置，方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在tomcat的bin目录下，修改catalina.sh，添加如下的参数</span></span><br><span class="line"></span><br><span class="line">JAVA_OPTS="-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">这几个参数的意思是：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-Dcom.sun.management.jmxremote ：允许使用JMX远程管理</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-Dcom.sun.management.jmxremote.port=9999 ：JMX远程连接端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-Dcom.sun.management.jmxremote.authenticate=<span class="literal">false</span> ：不进行身份认证，任何用户都可以连接</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-Dcom.sun.management.jmxremote.ssl=<span class="literal">false</span> ：不使用ssl</span></span><br></pre></td></tr></table></figure><p>保存退出，重启tomcat。</p><h4 id="7-6-3、使用VisualJVM连接远程tomcat"><a href="#7-6-3、使用VisualJVM连接远程tomcat" class="headerlink" title="7.6.3、使用VisualJVM连接远程tomcat"></a>7.6.3、使用VisualJVM连接远程tomcat</h4><p>添加远程主机：</p><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536681377182.png" alt="1536681377182"></p><p>在一个主机下可能会有很多的jvm需要监控，所以接下来要在该主机上添加需要监控的jvm：</p><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536681543452.png" alt="1536681543452"></p><p> <img src="/2019/05/30/JVM优化基础和JDK工具的使用/1536681575620.png" alt="1536681575620"></p><p>连接成功。使用方法和前面就一样了，就可以和监控本地jvm进程一样，监控远程的tomcat进程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM优化基础和JDK工具的使用&quot;&gt;&lt;a href=&quot;#JVM优化基础和JDK工具的使用&quot; class=&quot;headerlink&quot; title=&quot;JVM优化基础和JDK工具的使用&quot;&gt;&lt;/a&gt;JVM优化基础和JDK工具的使用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;了解下我们为什么要学习JVM优化&lt;/li&gt;
&lt;li&gt;掌握jvm的运行参数以及参数的设置&lt;/li&gt;
&lt;li&gt;掌握jvm的内存结构（堆内存）&lt;/li&gt;
&lt;li&gt;掌握jamp命令的使用以及通过MAT工具进行分析&lt;/li&gt;
&lt;li&gt;掌握定位分析内存溢出的方法&lt;/li&gt;
&lt;li&gt;掌握jstack命令的使用&lt;/li&gt;
&lt;li&gt;掌握VisualJVM工具的使用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM优化+Tomcat优化</title>
    <link href="http://yoursite.com/2019/05/30/JVM%E4%BC%98%E5%8C%96-Tomcat%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/05/30/JVM优化-Tomcat优化/</id>
    <published>2019-05-30T07:44:48.000Z</published>
    <updated>2020-07-27T09:25:36.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM优化-Tomcat优化"><a href="#JVM优化-Tomcat优化" class="headerlink" title="JVM优化+Tomcat优化"></a>JVM优化+Tomcat优化</h2><ul><li>Tomcat8的优化</li><li>看懂Java底层字节码</li><li>编码的优化建议</li></ul><a id="more"></a><h2 id="1、Tomcat8优化"><a href="#1、Tomcat8优化" class="headerlink" title="1、Tomcat8优化"></a>1、Tomcat8优化</h2><p>tomcat服务器在JavaEE项目中使用率非常高，所以在生产环境对tomcat的优化也变得非常重要了。</p><p>对于tomcat的优化，主要是从2个方面入手，一是，tomcat自身的配置，另一个是tomcat所运行的jvm虚拟机的调优。</p><p>下面我们将从这2个方面进行讲解。</p><h3 id="1-1、Tomcat配置优化"><a href="#1-1、Tomcat配置优化" class="headerlink" title="1.1、Tomcat配置优化"></a>1.1、Tomcat配置优化</h3><h4 id="1-1-1、部署安装tomcat8"><a href="#1-1-1、部署安装tomcat8" class="headerlink" title="1.1.1、部署安装tomcat8"></a>1.1.1、部署安装tomcat8</h4><p>下载并安装：</p><p><a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-80.cgi</a></p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537885756741.png" alt="1537885756741"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.34/bin/apache-tomcat-8.5.34.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xvf apache-tomcat-8.5.34.tar.gz</span><br><span class="line">cd apache-tomcat-8.5.34/conf</span><br><span class="line"><span class="meta">#</span><span class="bash">修改配置文件，配置tomcat的管理用户</span></span><br><span class="line">vim tomcat-users.xml</span><br><span class="line"><span class="meta">#</span><span class="bash">写入如下内容：</span></span><br><span class="line">&lt;role rolename="manager"/&gt;</span><br><span class="line">&lt;role rolename="manager-gui"/&gt;</span><br><span class="line">&lt;role rolename="admin"/&gt;</span><br><span class="line">&lt;role rolename="admin-gui"/&gt;</span><br><span class="line">&lt;user username="tomcat" password="tomcat" roles="admin-gui,admin,manager-gui,manager"/&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">保存退出</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果是tomcat7，配置了tomcat用户就可以登录系统了，但是tomcat8中不行，还需要修改另一个配置文件，否则访问不了，提示403</span></span><br><span class="line">vim webapps/manager/META-INF/context.xml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将&lt;Valve的内容注释掉</span></span><br><span class="line">&lt;Context antiResourceLocking="false" privileged="true" &gt;</span><br><span class="line"> &lt;!-- &lt;Valve className="org.apache.catalina.valves.RemoteAddrValve"</span><br><span class="line">         allow="127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1" /&gt; --&gt;</span><br><span class="line">  &lt;Manager sessionAttributeValueClassNameFilter="java\.lang\.(?:Boolean|Integer|Long|Number|String)|org\.apache\.catalina\.filters\.CsrfPreventionFilter\$LruCache(?:\$1)?|java\.util\.(?:Linked)?HashMap"/&gt;</span><br><span class="line">&lt;/Context&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">保存退出即可</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动tomcat</span></span><br><span class="line">cd /tmp/apache-tomcat-8.5.34/bin/</span><br><span class="line">./startup.sh &amp;&amp; tail -f ../logs/catalina.out</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">打开浏览器进行测试访问</span></span><br><span class="line">http://192.168.40.133:8080/</span><br></pre></td></tr></table></figure><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537886442880.png" alt="1537886442880"></p><p>点击“Server Status”，输入用户名、密码进行登录，tomcat/tomcat</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537886585179.png" alt="1537886585179"></p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537886617256.png" alt="1537886617256"></p><p>进入之后即可看到服务的信息。</p><h4 id="1-1-2、禁用AJP连接"><a href="#1-1-2、禁用AJP连接" class="headerlink" title="1.1.2、禁用AJP连接"></a>1.1.2、禁用AJP连接</h4><p>在服务状态页面中可以看到，默认状态下会启用AJP服务，并且占用8009端口。</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537886721693.png" alt="1537886721693"></p><p>什么是AJP呢？</p><p>AJP（Apache JServer Protocol）<br>AJPv13协议是面向包的。WEB服务器和Servlet容器通过TCP连接来交互；为了节省SOCKET创建的昂贵代价，WEB服务器会尝试维护一个永久TCP连接到servlet容器，并且在多个请求和响应周期过程会重用连接。</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537886760361.png" alt="1537886760361"></p><p>我们一般是使用Nginx+tomcat的架构，所以用不着AJP协议，所以把AJP连接器禁用。</p><p>修改conf下的server.xml文件，将AJP服务禁用掉即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt;</span><br></pre></td></tr></table></figure><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537886904896.png" alt="1537886904896"></p><p>重启tomcat，查看效果。</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537887017961.png" alt="1537887017961"></p><p>可以看到AJP服务以及不存在了。</p><h4 id="1-1-3、执行器（线程池）"><a href="#1-1-3、执行器（线程池）" class="headerlink" title="1.1.3、执行器（线程池）"></a>1.1.3、执行器（线程池）</h4><p>在tomcat中每一个用户请求都是一个线程，所以可以使用线程池提高性能。</p><p>修改server.xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--将注释打开--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec-"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxThreads</span>=<span class="string">"500"</span> <span class="attr">minSpareThreads</span>=<span class="string">"50"</span> <span class="attr">prestartminSpareThreads</span>=<span class="string">"true"</span> <span class="attr">maxQueueSize</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">参数说明：</span></span><br><span class="line"><span class="comment">maxThreads：最大并发数，默认设置 200，一般建议在 500 ~ 1000，根据硬件设施和业务来判断</span></span><br><span class="line"><span class="comment">minSpareThreads：Tomcat 初始化时创建的线程数，默认设置 25</span></span><br><span class="line"><span class="comment">prestartminSpareThreads： 在 Tomcat 初始化的时候就初始化 minSpareThreads 的参数值，如果不等于 true，minSpareThreads 的值就没啥效果了</span></span><br><span class="line"><span class="comment">maxQueueSize，最大的等待队列数，超过则拒绝请求</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在Connector中设置executor属性指向上面的执行器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span>  <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>保存退出，重启tomcat，查看效果。</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537891844779.png" alt="1537891844779"></p><p>在页面中显示最大线程数为-1，这个是正常的，仅仅是显示的问题，实际使用的指定的值。</p><p>也有人遇到这样的问题：<a href="https://blog.csdn.net/weixin_38278878/article/details/80144397" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38278878/article/details/80144397</a></p><h4 id="1-1-4、3种运行模式"><a href="#1-1-4、3种运行模式" class="headerlink" title="1.1.4、3种运行模式"></a>1.1.4、3种运行模式</h4><p>tomcat的运行模式有3种：</p><ol><li>bio<br>默认的模式,性能非常低下,没有经过任何优化处理和支持.</li><li>nio<br>nio(new I/O)，是Java SE 1.4及后续版本提供的一种新的I/O操作方式(即java.nio包及其子包)。Java nio是一个基于缓冲区、并能提供非阻塞I/O操作的Java API，因此nio也被看成是non-blocking I/O的缩写。它拥有比传统I/O操作(bio)更好的并发运行性能。</li><li>apr<br>安装起来最困难,但是从操作系统级别来解决异步的IO问题,大幅度的提高性能.</li></ol><p>推荐使用nio，不过，在tomcat8中有最新的nio2，速度更快，建议使用nio2.</p><p>设置nio2：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span>  <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11Nio2Protocol"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537892225489.png" alt="1537892225489"></p><p>可以看到已经设置为nio2了。</p><h3 id="1-2、部署测试用的java-web项目"><a href="#1-2、部署测试用的java-web项目" class="headerlink" title="1.2、部署测试用的java web项目"></a>1.2、部署测试用的java web项目</h3><p>为了方便测试性能，我们将部署一个java web项目，这个项目本身和本套课程没有什么关系，仅仅用于测试。</p><blockquote><p>注意：这里在测试时，我们使用一个新的tomcat，进行测试，后面再对其进行优化调整，再测试。</p></blockquote><h4 id="1-2-1、创建dashboard数据库"><a href="#1-2-1、创建dashboard数据库" class="headerlink" title="1.2.1、创建dashboard数据库"></a>1.2.1、创建dashboard数据库</h4><p>在资料中找到sql脚本文件dashboard.sql，在linux服务器上执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat dashboard.sql | mysql -uroot -proot</span><br></pre></td></tr></table></figure><p>创建完成后，可以看到有3张表。</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537892698827.png" alt="1537892698827"></p><h4 id="1-2-2、部署web应用"><a href="#1-2-2、部署web应用" class="headerlink" title="1.2.2、部署web应用"></a>1.2.2、部署web应用</h4><p>在资料中找到itcat-dashboard-web.war，上传到linux服务器，进行部署安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp/apache-tomcat-8.5.34/webapps</span><br><span class="line">rm -rf *</span><br><span class="line">mkdir ROOT</span><br><span class="line">cd ROOT/</span><br><span class="line"></span><br><span class="line">rz上传war包</span><br><span class="line">jar -xvf itcat-dashboard-web.war</span><br><span class="line">rm -rf itcat-dashboard-web.war</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">修改数据库配置文件</span></span><br><span class="line">cd /tmp/apache-tomcat-8.5.34/webapps/ROOT/WEB-INF/classes</span><br><span class="line">vim jdbc.properties</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">这里根据自己的实际情况进行配置</span></span><br><span class="line"></span><br><span class="line">jdbc.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://node01:3306/dashboard?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><p>重新启动tomcat。</p><p>访问首页，查看是否已经启动成功：<a href="http://192.168.40.133:8080/index" target="_blank" rel="noopener">http://192.168.40.133:8080/index</a> <img src="/2019/05/30/JVM优化-Tomcat优化/1537946855605.png" alt="1537946855605"></p><h3 id="1-3、使用Apache-JMeter进行测试"><a href="#1-3、使用Apache-JMeter进行测试" class="headerlink" title="1.3、使用Apache JMeter进行测试"></a>1.3、使用Apache JMeter进行测试</h3><p>Apache Jmeter是开源的压力测试工具，我们借助于此工具进行测试，将测试出tomcat的吞吐量等信息。</p><h4 id="1-3-1、下载安装"><a href="#1-3-1、下载安装" class="headerlink" title="1.3.1、下载安装"></a>1.3.1、下载安装</h4><p>下载地址：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi</a></p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537949454864.png" alt="1537949454864"></p><p>安装：直接将下载好的zip压缩包进行解压即可。</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537949516687.png" alt="1537949516687"></p><p>进入bin目录，找到jmeter.bat文件，双机打开即可启动。</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537949587540.png" alt="1537949587540"></p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537949628061.png" alt="1537949628061"></p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537949711256.png" alt="1537949711256"></p><h4 id="1-3-2、修改主题和语言"><a href="#1-3-2、修改主题和语言" class="headerlink" title="1.3.2、修改主题和语言"></a>1.3.2、修改主题和语言</h4><p>默认的主题是黑色风格的主题并且语言是英语，这样不太方便使用，所以需要修改下主题和中文语言。</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537949830874.png" alt="1537949830874"></p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537949884794.png" alt="1537949884794"></p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537949923207.png" alt="1537949923207"></p><p>主题修改完成。</p><p>接下来设置语言为简体中文。</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537949965832.png" alt="1537949965832"></p><p>语言修改完成。 <img src="/2019/05/30/JVM优化-Tomcat优化/1537950040975.png" alt="1537950040975"></p><h4 id="1-3-3、创建首页的测试用例"><a href="#1-3-3、创建首页的测试用例" class="headerlink" title="1.3.3、创建首页的测试用例"></a>1.3.3、创建首页的测试用例</h4><p>第一步：保存测试用例 <img src="/2019/05/30/JVM优化-Tomcat优化/1537952165502.png" alt="1537952165502"></p><p>第二步：添加线程组，使用线程模拟用户的并发</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537952849110.png" alt="1537952849110"></p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537968506080.png" alt="1537968506080"></p><p>1000个线程，每个线程循环10次，也就是tomcat会接收到10000个请求。</p><p>第三步：添加http请求</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537970361030.png" alt="1537970361030"></p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537970437128.png" alt="1537970437128"></p><p>第四步：添加请求监控</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537970530920.png" alt="1537970530920"></p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537970575424.png" alt="1537970575424"></p><h4 id="1-3-4、启动、进行测试"><a href="#1-3-4、启动、进行测试" class="headerlink" title="1.3.4、启动、进行测试"></a>1.3.4、启动、进行测试</h4><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537970641386.png" alt="1537970641386"></p><h4 id="1-3-5、聚合报告"><a href="#1-3-5、聚合报告" class="headerlink" title="1.3.5、聚合报告"></a>1.3.5、聚合报告</h4><p>在聚合报告中，重点看吞吐量。</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1538727715123.png" alt="1538727715123"></p><h3 id="1-4、调整tomcat参数进行优化"><a href="#1-4、调整tomcat参数进行优化" class="headerlink" title="1.4、调整tomcat参数进行优化"></a>1.4、调整tomcat参数进行优化</h3><p>通过上面测试可以看出，tomcat在不做任何调整时，吞吐量为73次/秒。</p><h4 id="1-4-1、禁用AJP服务"><a href="#1-4-1、禁用AJP服务" class="headerlink" title="1.4.1、禁用AJP服务"></a>1.4.1、禁用AJP服务</h4><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537971815919.png" alt="1537971815919"></p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1537971838198.png" alt="1537971838198"></p><p>可以看到，禁用AJP服务后，吞吐量会有所提升。</p><p>当然了，测试不一定准确，需要多测试几次才能看出是否有提升。</p><h4 id="1-4-2、设置线程池"><a href="#1-4-2、设置线程池" class="headerlink" title="1.4.2、设置线程池"></a>1.4.2、设置线程池</h4><p>通过设置线程池，调整线程池相关的参数进行测试tomcat的性能。</p><h5 id="1-4-2-1、最大线程数为500，初始为50"><a href="#1-4-2-1、最大线程数为500，初始为50" class="headerlink" title="1.4.2.1、最大线程数为500，初始为50"></a>1.4.2.1、最大线程数为500，初始为50</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec-"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxThreads</span>=<span class="string">"500"</span> <span class="attr">minSpareThreads</span>=<span class="string">"50"</span> <span class="attr">prestartminSpareThreads</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试结果：</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1538732278070.png" alt="1538732278070"></p><p>吞吐量为128次/秒，性能有所提升。</p><h5 id="1-4-2-2、最大线程数为1000，初始为200"><a href="#1-4-2-2、最大线程数为1000，初始为200" class="headerlink" title="1.4.2.2、最大线程数为1000，初始为200"></a>1.4.2.2、最大线程数为1000，初始为200</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec-"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxThreads</span>=<span class="string">"1000"</span> <span class="attr">minSpareThreads</span>=<span class="string">"200"</span> <span class="attr">prestartminSpareThreads</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1538732664770.png" alt="1538732664770"></p><p>吞吐量为151，性能有所提升。</p><h5 id="1-4-2-3、最大线程数为5000，初始为1000"><a href="#1-4-2-3、最大线程数为5000，初始为1000" class="headerlink" title="1.4.2.3、最大线程数为5000，初始为1000"></a>1.4.2.3、最大线程数为5000，初始为1000</h5><p>是否是线程数最多，速度越快呢？ 我们来测试下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec-"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxThreads</span>=<span class="string">"5000"</span> <span class="attr">minSpareThreads</span>=<span class="string">"1000"</span> <span class="attr">prestartminSpareThreads</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1538732998659.png" alt="1538732998659"></p><p>可以看到，虽然最大线程已经设置到5000，但是实际测试效果并不理想，并且平均的响应时间也边长了，所以单纯靠提升线程数量是不能一直得到性能提升的。</p><h5 id="1-4-2-4、设置最大等待队列数"><a href="#1-4-2-4、设置最大等待队列数" class="headerlink" title="1.4.2.4、设置最大等待队列数"></a>1.4.2.4、设置最大等待队列数</h5><p>默认情况下，请求发送到tomcat，如果tomcat正忙，那么该请求会一直等待。这样虽然可以保证每个请求都能请求到，但是请求时间就会边长。</p><p>有些时候，我们也不一定要求请求一定等待，可以设置最大等待队列大小，如果超过就不等待了。这样虽然有些请求是失败的，但是请求时间会虽短。典型的应用：12306。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--最大等待数为100--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec-"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxThreads</span>=<span class="string">"500"</span> <span class="attr">minSpareThreads</span>=<span class="string">"100"</span> <span class="attr">prestartminSpareThreads</span>=<span class="string">"true"</span> <span class="attr">maxQueueSize</span>=<span class="string">"100"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1538733508872.png" alt="1538733508872"></p><p>测试结果：</p><ul><li>平均响应时间：3.1秒<ul><li>响应时间明显缩短</li></ul></li><li>错误率：49.88%<ul><li>错误率提升到一半，也可以理解，最大线程为500，测试的并发为1000</li></ul></li><li>吞吐量：238次/秒<ul><li>吞吐量明显提升</li></ul></li></ul><p>结论：响应时间、吞吐量这2个指标需要找到平衡才能达到更好的性能。</p><h4 id="1-4-3、设置nio2的运行模式"><a href="#1-4-3、设置nio2的运行模式" class="headerlink" title="1.4.3、设置nio2的运行模式"></a>1.4.3、设置nio2的运行模式</h4><p>将最大线程设置为500进行测试：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">namePrefix</span>=<span class="string">"catalina-exec-"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxThreads</span>=<span class="string">"500"</span> <span class="attr">minSpareThreads</span>=<span class="string">"50"</span> <span class="attr">prestartminSpareThreads</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 设置nio2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">executor</span>=<span class="string">"tomcatThreadPool"</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11Nio2Protocol"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1538747028764.png" alt="1538747028764"></p><p>可以看到，平均响应时间有缩短，吞吐量有提升，可以得出结论：nio2的性能要高于nio。</p><h3 id="1-5、调整JVM参数进行优化"><a href="#1-5、调整JVM参数进行优化" class="headerlink" title="1.5、调整JVM参数进行优化"></a>1.5、调整JVM参数进行优化</h3><p>接下来，测试通过jvm参数进行优化，为了测试一致性，依然将最大线程数设置为500，启用nio2运行模式。</p><h4 id="1-5-1、设置并行垃圾回收器"><a href="#1-5-1、设置并行垃圾回收器" class="headerlink" title="1.5.1、设置并行垃圾回收器"></a>1.5.1、设置并行垃圾回收器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">年轻代、老年代均使用并行收集器，初始堆内存64M，最大堆内存512M</span></span><br><span class="line">JAVA_OPTS="-XX:+UseParallelGC -XX:+UseParallelOldGC -Xms64m -Xmx512m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:../logs/gc.log"</span><br></pre></td></tr></table></figure><p><img src="/2019/05/30/JVM优化-Tomcat优化/1538012232502.png" alt="1538012232502"></p><p>测试结果与默认的JVM参数结果接近。（执行了2次测试，结果是第二次测试的结果）</p><h4 id="1-5-2、查看gc日志文件"><a href="#1-5-2、查看gc日志文件" class="headerlink" title="1.5.2、查看gc日志文件"></a>1.5.2、查看gc日志文件</h4><p>将gc.log文件上传到gceasy.io查看gc中是否存在问题。</p><p>问题一： <img src="/2019/05/30/JVM优化-Tomcat优化/1538012634194.png" alt="1538012634194"></p><p>在报告中显示，在5次GC时，系统所消耗的时间大于用户时间，这反应出的服务器的性能存在瓶颈，调度CPU等资源所消耗的时间要长一些。</p><p>问题二： <img src="/2019/05/30/JVM优化-Tomcat优化/1538013060119.png" alt="1538013060119"></p><p>可以关键指标中可以看出，吞吐量表现不错，但是gc时，线程的暂停时间稍有点长。</p><p>问题三： <img src="/2019/05/30/JVM优化-Tomcat优化/1538013925947.png" alt="1538013925947"></p><p>通过GC的统计可以看出：</p><ul><li>年轻代的gc有74次，次数稍有多，说明年轻代设置的大小不合适需要调整</li><li>FullGC有8次，说明堆内存的大小不合适，需要调整</li></ul><p>问题四： <img src="/2019/05/30/JVM优化-Tomcat优化/1538014237594.png" alt="1538014237594"></p><p>从GC原因的可以看出，年轻代大小设置不合理，导致了多次GC。</p><h4 id="1-5-3、调整年轻代大小"><a href="#1-5-3、调整年轻代大小" class="headerlink" title="1.5.3、调整年轻代大小"></a>1.5.3、调整年轻代大小</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS="-XX:+UseParallelGC -XX:+UseParallelOldGC -Xms128m -Xmx1024m -XX:NewSize=64m -XX:MaxNewSize=256m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:../logs/gc.log"</span><br></pre></td></tr></table></figure><p>将初始堆大小设置为128m，最大为1024m</p><p>初始年轻代大小64m，年轻代最大256m <img src="/2019/05/30/JVM优化-Tomcat优化/1538015127822.png" alt="1538015127822"></p><p>从测试结果来看，吞吐量以及响应时间均有提升。</p><p>查看gc日志：</p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1538015681175.png" alt="1538015681175"></p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1538016117073.png" alt="1538016117073"></p><p>可以看到GC次数要明显减少，说明调整是有效的。</p><h4 id="1-5-4、设置G1垃圾回收器"><a href="#1-5-4、设置G1垃圾回收器" class="headerlink" title="1.5.4、设置G1垃圾回收器"></a>1.5.4、设置G1垃圾回收器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置了最大停顿时间100毫秒，初始堆内存128m，最大堆内存1024m</span></span><br><span class="line">JAVA_OPTS="-XX:+UseG1GC -XX:MaxGCPauseMillis=100 -Xms128m -Xmx1024m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:../logs/gc.log"</span><br></pre></td></tr></table></figure><p>测试结果：  <img src="/2019/05/30/JVM优化-Tomcat优化/1538019510782.png" alt="1538019510782"></p><p><img src="/2019/05/30/JVM优化-Tomcat优化/1538019458636.png" alt="1538019458636"></p><p>可以看到，吞吐量有所提升，评价响应时间也有所缩短。</p><h4 id="1-5-5、小结"><a href="#1-5-5、小结" class="headerlink" title="1.5.5、小结"></a>1.5.5、小结</h4><p>通过上述的测试，可以总结出，对tomcat性能优化就是需要不断的进行调整参数，然后测试结果，可能会调优也可能会调差，这时就需要借助于gc的可视化工具来看gc的情况。再帮我我们做出决策应该调整哪些参数。</p><h2 id="2、JVM字节码"><a href="#2、JVM字节码" class="headerlink" title="2、JVM字节码"></a>2、JVM字节码</h2><p>前面我们通过tomcat本身的参数以及jvm的参数对tomcat做了优化，其实要想将应用程序跑的更快、效率更高，除了对tomcat容器以及jvm优化外，应用程序代码本身如果写的效率不高的，那么也是不行的，所以，对于程序本身的优化也就很重要了。</p><p>对于程序本身的优化，可以借鉴很多前辈们的经验，但是有些时候，在从源码角度方面分析的话，不好鉴别出哪个效率高，如对字符串拼接的操作，是直接“+”号拼接效率高还是使用StringBuilder效率高？</p><p>这个时候，就需要通过查看编译好的class文件中字节码，就可以找到答案。</p><p>我们都知道，java编写应用，需要先通过javac命令编译成class文件，再通过jvm执行，jvm执行时是需要将class文件中的字节码载入到jvm进行运行的。</p><h3 id="2-1、通过javap命令查看class文件的字节码内容"><a href="#2-1、通过javap命令查看class文件的字节码内容" class="headerlink" title="2.1、通过javap命令查看class文件的字节码内容"></a>2.1、通过javap命令查看class文件的字节码内容</h3><p>首先，看一个简单的Test1类的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> c = b - a;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap命令查看class文件中的字节码内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">javap -v Test1.class &gt; Test1.txt</span><br><span class="line"></span><br><span class="line">javap用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类</span><br><span class="line">                           和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><p>查看Test1.txt文件，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Classfile /F:/code/bestqiang-jvm/bestqiang-jvm-test/target/classes/cn/bestqiang/jvm/Test1.class</span><br><span class="line">  Last modified <span class="number">2018</span>-<span class="number">9</span>-<span class="number">27</span>; size <span class="number">577</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">4214859</span>db3543c0c783ec8a216a4795f</span><br><span class="line">  Compiled from <span class="string">"Test1.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cn</span>.<span class="title">bestqiang</span>.<span class="title">jvm</span>.<span class="title">Test1</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #5.#23         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #24.#25        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = Methodref          #26.#27        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #4 = Class              #28            // cn/bestqiang/jvm/Test1</span><br><span class="line">   #5 = Class              #29            // java/lang/Object</span><br><span class="line">   #6 = Utf8               &lt;init&gt;</span><br><span class="line">   #7 = Utf8               ()V</span><br><span class="line">   #8 = Utf8               Code</span><br><span class="line">   #9 = Utf8               LineNumberTable</span><br><span class="line">  #10 = Utf8               LocalVariableTable</span><br><span class="line">  #11 = Utf8               this</span><br><span class="line">  #12 = Utf8               Lcn/bestqiang/jvm/Test1;</span><br><span class="line">  #13 = Utf8               main</span><br><span class="line">  #14 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #15 = Utf8               args</span><br><span class="line">  #16 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #17 = Utf8               a</span><br><span class="line">  #18 = Utf8               I</span><br><span class="line">  #19 = Utf8               b</span><br><span class="line">  #20 = Utf8               c</span><br><span class="line">  #21 = Utf8               SourceFile</span><br><span class="line">  #22 = Utf8               Test1.java</span><br><span class="line">  #23 = NameAndType        #6:#7          // "&lt;init&gt;":()V</span><br><span class="line">  #24 = Class              #30            // java/lang/System</span><br><span class="line">  #25 = NameAndType        #31:#32        // out:Ljava/io/PrintStream;</span><br><span class="line">  #26 = Class              #33            // java/io/PrintStream</span><br><span class="line">  #27 = NameAndType        #34:#35        // println:(I)V</span><br><span class="line">  #28 = Utf8               cn/bestqiang/jvm/Test1</span><br><span class="line">  #29 = Utf8               java/lang/Object</span><br><span class="line">  #30 = Utf8               java/lang/System</span><br><span class="line">  #31 = Utf8               out</span><br><span class="line">  #32 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #33 = Utf8               java/io/PrintStream</span><br><span class="line">  #34 = Utf8               println</span><br><span class="line">  #35 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> cn.bestqiang.jvm.Test1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/bestqiang/jvm/Test1;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_2</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: iconst_5</span><br><span class="line">         <span class="number">3</span>: istore_2</span><br><span class="line">         <span class="number">4</span>: iload_2</span><br><span class="line">         <span class="number">5</span>: iload_1</span><br><span class="line">         <span class="number">6</span>: isub</span><br><span class="line">         <span class="number">7</span>: istore_3</span><br><span class="line">         8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">11</span>: iload_3</span><br><span class="line">        12: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">15</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">16</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">2</span>      <span class="number">14</span>     <span class="number">1</span>     a   I</span><br><span class="line">            <span class="number">4</span>      <span class="number">12</span>     <span class="number">2</span>     b   I</span><br><span class="line">            <span class="number">8</span>       <span class="number">8</span>     <span class="number">3</span>     c   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"Test1.java"</span></span><br></pre></td></tr></table></figure><p>内容大致分为4个部分：</p><p>第一部分：显示了生成这个class的java源文件、版本信息、生成时间等。</p><p>第二部分：显示了该类中所涉及到常量池，共35个常量。</p><p>第三部分：显示该类的构造器，编译器自动插入的。</p><p>第四部分：显示了main方的信息。（这个是需要我们重点关注的）</p><h3 id="2-2、常量池"><a href="#2-2、常量池" class="headerlink" title="2.2、常量池"></a>2.2、常量池</h3><p>官网文档：</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4-140" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4-140</a></p><table><thead><tr><th>Constant Type</th><th>Value</th><th>说明</th></tr></thead><tbody><tr><td><code>CONSTANT_Class</code></td><td>7</td><td>类或接口的符号引用</td></tr><tr><td><code>CONSTANT_Fieldref</code></td><td>9</td><td>字段的符号引用</td></tr><tr><td><code>CONSTANT_Methodref</code></td><td>10</td><td>类中方法的符号引用</td></tr><tr><td><code>CONSTANT_InterfaceMethodref</code></td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td><code>CONSTANT_String</code></td><td>8</td><td>字符串类型常量</td></tr><tr><td><code>CONSTANT_Integer</code></td><td>3</td><td>整形常量</td></tr><tr><td><code>CONSTANT_Float</code></td><td>4</td><td>浮点型常量</td></tr><tr><td><code>CONSTANT_Long</code></td><td>5</td><td>长整型常量</td></tr><tr><td><code>CONSTANT_Double</code></td><td>6</td><td>双精度浮点型常量</td></tr><tr><td><code>CONSTANT_NameAndType</code></td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td><code>CONSTANT_Utf8</code></td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td><code>CONSTANT_MethodHandle</code></td><td>15</td><td>表示方法句柄</td></tr><tr><td><code>CONSTANT_MethodType</code></td><td>16</td><td>标志方法类型</td></tr><tr><td><code>CONSTANT_InvokeDynamic</code></td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><h3 id="2-3、描述符"><a href="#2-3、描述符" class="headerlink" title="2.3、描述符"></a>2.3、描述符</h3><h4 id="2-3-1、字段描述符"><a href="#2-3-1、字段描述符" class="headerlink" title="2.3.1、字段描述符"></a>2.3.1、字段描述符</h4><p>官网：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2</a></p><table><thead><tr><th><em>FieldType</em> term</th><th>Type</th><th>Interpretation</th></tr></thead><tbody><tr><td><code>B</code></td><td><code>byte</code></td><td>signed byte</td></tr><tr><td><code>C</code></td><td><code>char</code></td><td>Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16</td></tr><tr><td><code>D</code></td><td><code>double</code></td><td>double-precision floating-point value</td></tr><tr><td><code>F</code></td><td><code>float</code></td><td>single-precision floating-point value</td></tr><tr><td><code>I</code></td><td><code>int</code></td><td>integer</td></tr><tr><td><code>J</code></td><td><code>long</code></td><td>long integer</td></tr><tr><td><code>LClassName;</code></td><td><code>reference</code></td><td>an instance of class <em>ClassName</em></td></tr><tr><td><code>S</code></td><td><code>short</code></td><td>signed short</td></tr><tr><td><code>Z</code></td><td><code>boolean</code></td><td><code>true</code> or <code>false</code></td></tr><tr><td><code>[</code></td><td><code>reference</code></td><td>one array dimension</td></tr></tbody></table><h4 id="2-3-2、方法描述符"><a href="#2-3-2、方法描述符" class="headerlink" title="2.3.2、方法描述符"></a>2.3.2、方法描述符</h4><p>官网：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3</a></p><p>示例：</p><p>The method descriptor for the method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">m</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d, Thread t)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>is:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(IDLjava/lang/Thread;)Ljava/lang/Object;</span><br></pre></td></tr></table></figure><h3 id="2-4、解读方法字节码"><a href="#2-4、解读方法字节码" class="headerlink" title="2.4、解读方法字节码"></a>2.4、解读方法字节码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V  <span class="comment">//方法描述，V表示该方法的放回值为void</span></span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC  <span class="comment">// 方法修饰符，public、static的</span></span><br><span class="line">    Code:</span><br><span class="line">      <span class="comment">// stack=2,操作栈的大小为2、locals=4，本地变量表大小，args_size=1, 参数的个数</span></span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span> </span><br><span class="line">         <span class="number">0</span>: iconst_2  <span class="comment">//将数字2值压入操作栈，位于栈的最上面</span></span><br><span class="line">         <span class="number">1</span>: istore_1  <span class="comment">//从操作栈中弹出一个元素(数字2)，放入到本地变量表中，位于下标为1的位置（下标为0的是this）</span></span><br><span class="line">         <span class="number">2</span>: iconst_5  <span class="comment">//将数字5值压入操作栈，位于栈的最上面</span></span><br><span class="line">         <span class="number">3</span>: istore_2  <span class="comment">//从操作栈中弹出一个元素(5)，放入到本地变量表中，位于第下标为2个位置</span></span><br><span class="line">         <span class="number">4</span>: iload_2  <span class="comment">//将本地变量表中下标为2的位置元素压入操作栈（5）</span></span><br><span class="line">         <span class="number">5</span>: iload_1  <span class="comment">//将本地变量表中下标为1的位置元素压入操作栈（2）</span></span><br><span class="line">         <span class="number">6</span>: isub  <span class="comment">//操作栈中的2个数字相减</span></span><br><span class="line">         <span class="number">7</span>: istore_3 <span class="comment">// 将相减的结果压入到本地本地变量表中，位于下标为3的位置</span></span><br><span class="line">         <span class="comment">// 通过#2号找到对应的常量，即可找到对应的引用       </span></span><br><span class="line">         8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">11</span>: iload_3 <span class="comment">//将本地变量表中下标为3的位置元素压入操作栈（3）</span></span><br><span class="line">        <span class="comment">// 通过#3号找到对应的常量，即可找到对应的引用，进行方法调用</span></span><br><span class="line">        12: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">15</span>: <span class="keyword">return</span> <span class="comment">//返回</span></span><br><span class="line">      LineNumberTable:  <span class="comment">//行号的列表</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">15</span></span><br><span class="line">      LocalVariableTable: <span class="comment">// 本地变量表</span></span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">16</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">2</span>      <span class="number">14</span>     <span class="number">1</span>     a   I</span><br><span class="line">            <span class="number">4</span>      <span class="number">12</span>     <span class="number">2</span>     b   I</span><br><span class="line">            <span class="number">8</span>       <span class="number">8</span>     <span class="number">3</span>     c   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"Test1.java"</span></span><br></pre></td></tr></table></figure><h4 id="2-4-1、图解"><a href="#2-4-1、图解" class="headerlink" title="2.4.1、图解"></a>2.4.1、图解</h4><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1538065414765.png" alt="1538065414765"></p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1538065819308.png" alt="1538065819308"></p><p> <img src="/2019/05/30/JVM优化-Tomcat优化/1538066431935.png" alt="1538066431935"></p><h3 id="2-5、研究-i-与-i-的不同"><a href="#2-5、研究-i-与-i-的不同" class="headerlink" title="2.5、研究 i++ 与 ++i 的不同"></a>2.5、研究 i++ 与 ++i 的不同</h3><p>我们都知道，i++表示，先返回再+1，++i表示，先+1再返回。它的底层是怎么样的呢? 我们一起探究下。</p><p>编写测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test2().method1();</span><br><span class="line">        <span class="keyword">new</span> Test2().method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = i++;</span><br><span class="line">        System.out.println(a); <span class="comment">//打印1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = ++i;</span><br><span class="line">        System.out.println(a);<span class="comment">//打印2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-1、查看class字节码"><a href="#2-5-1、查看class字节码" class="headerlink" title="2.5.1、查看class字节码"></a>2.5.1、查看class字节码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">Classfile /F:/code/bestqiang-jvm/bestqiang-jvm-test/target/classes/cn/bestqiang/jvm/Test2.class</span><br><span class="line">  MD5 checksum <span class="number">901660f</span>c11c43b6daadd0942150960ed</span><br><span class="line">  Compiled from <span class="string">"Test2.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cn</span>.<span class="title">bestqiang</span>.<span class="title">jvm</span>.<span class="title">Test2</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #8.#27         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Class              #28            // cn/bestqiang/jvm/Test2</span><br><span class="line">   #3 = Methodref          #2.#27         // cn/bestqiang/jvm/Test2."&lt;init&gt;":()V</span><br><span class="line">   #4 = Methodref          #2.#29         // cn/bestqiang/jvm/Test2.method1:()V</span><br><span class="line">   #5 = Methodref          #2.#30         // cn/bestqiang/jvm/Test2.method2:()V</span><br><span class="line">   #6 = Fieldref           #31.#32        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #7 = Methodref          #33.#34        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #8 = Class              #35            // java/lang/Object</span><br><span class="line">   #9 = Utf8               &lt;init&gt;</span><br><span class="line">  #10 = Utf8               ()V</span><br><span class="line">  #11 = Utf8               Code</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               this</span><br><span class="line">  #15 = Utf8               Lcn/bestqiang/jvm/Test2;</span><br><span class="line">  #16 = Utf8               main</span><br><span class="line">  #17 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               args</span><br><span class="line">  #19 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #20 = Utf8               method1</span><br><span class="line">  #21 = Utf8               i</span><br><span class="line">  #22 = Utf8               I</span><br><span class="line">  #23 = Utf8               a</span><br><span class="line">  #24 = Utf8               method2</span><br><span class="line">  #25 = Utf8               SourceFile</span><br><span class="line">  #26 = Utf8               Test2.java</span><br><span class="line">  #27 = NameAndType        #9:#10         // "&lt;init&gt;":()V</span><br><span class="line">  #28 = Utf8               cn/bestqiang/jvm/Test2</span><br><span class="line">  #29 = NameAndType        #20:#10        // method1:()V</span><br><span class="line">  #30 = NameAndType        #24:#10        // method2:()V</span><br><span class="line">  #31 = Class              #36            // java/lang/System</span><br><span class="line">  #32 = NameAndType        #37:#38        // out:Ljava/io/PrintStream;</span><br><span class="line">  #33 = Class              #39            // java/io/PrintStream</span><br><span class="line">  #34 = NameAndType        #40:#41        // println:(I)V</span><br><span class="line">  #35 = Utf8               java/lang/Object</span><br><span class="line">  #36 = Utf8               java/lang/System</span><br><span class="line">  #37 = Utf8               out</span><br><span class="line">  #38 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #39 = Utf8               java/io/PrintStream</span><br><span class="line">  #40 = Utf8               println</span><br><span class="line">  #41 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> cn.bestqiang.jvm.Test2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/bestqiang/jvm/Test2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #2                  // class cn/bestqiang/jvm/Test2</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #3                  // Method "&lt;init&gt;":()V</span><br><span class="line">         7: invokevirtual #4                  // Method method1:()V</span><br><span class="line">        10: new           #2                  // class cn/bestqiang/jvm/Test2</span><br><span class="line">        <span class="number">13</span>: dup</span><br><span class="line">        14: invokespecial #3                  // Method "&lt;init&gt;":()V</span><br><span class="line">        17: invokevirtual #5                  // Method method2:()V</span><br><span class="line">        <span class="number">20</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">20</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">21</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_1</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: iload_1</span><br><span class="line">         <span class="number">3</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">         <span class="number">6</span>: istore_2</span><br><span class="line">         7: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">10</span>: iload_2</span><br><span class="line">        11: invokevirtual #7                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">7</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">14</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">15</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/bestqiang/jvm/Test2;</span><br><span class="line">            <span class="number">2</span>      <span class="number">13</span>     <span class="number">1</span>     i   I</span><br><span class="line">            <span class="number">7</span>       <span class="number">8</span>     <span class="number">2</span>     a   I</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_1</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">         <span class="number">5</span>: iload_1</span><br><span class="line">         <span class="number">6</span>: istore_2</span><br><span class="line">         7: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">10</span>: iload_2</span><br><span class="line">        11: invokevirtual #7                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">7</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">14</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">15</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/bestqiang/jvm/Test2;</span><br><span class="line">            <span class="number">2</span>      <span class="number">13</span>     <span class="number">1</span>     i   I</span><br><span class="line">            <span class="number">7</span>       <span class="number">8</span>     <span class="number">2</span>     a   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"Test2.java"</span></span><br></pre></td></tr></table></figure><h4 id="2-5-2、对比"><a href="#2-5-2、对比" class="headerlink" title="2.5.2、对比"></a>2.5.2、对比</h4><p>i++：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: iconst_1  <span class="comment">//将数字1压入到操作栈</span></span><br><span class="line"> <span class="number">1</span>: istore_1  <span class="comment">//将数字1从操作栈弹出，压入到本地变量表中，下标为1</span></span><br><span class="line"> <span class="number">2</span>: iload_1   <span class="comment">//从本地变量表中获取下标为1的数据，压入到操作栈中</span></span><br><span class="line"> <span class="number">3</span>: iinc          <span class="number">1</span>, <span class="number">1</span> <span class="comment">// 将本地变量中的1，再+1</span></span><br><span class="line"> <span class="number">6</span>: istore_2  <span class="comment">// 将数字1从操作栈弹出，压入到本地变量表中，下标为2</span></span><br><span class="line"> 7: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"><span class="number">10</span>: iload_2   <span class="comment">//从本地变量表中获取下标为2的数据，压入到操作栈中</span></span><br><span class="line">11: invokevirtual #7                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line"><span class="number">14</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>++i：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: iconst_1  <span class="comment">//将数字1压入到操作栈</span></span><br><span class="line"> <span class="number">1</span>: istore_1  <span class="comment">//将数字1从操作栈弹出，压入到本地变量表中，下标为1</span></span><br><span class="line"> <span class="number">2</span>: iinc          <span class="number">1</span>, <span class="number">1</span><span class="comment">// 将本地变量中的1，再+1</span></span><br><span class="line"> <span class="number">5</span>: iload_1  <span class="comment">//从本地变量表中获取下标为1的数据（2），压入到操作栈中</span></span><br><span class="line"> <span class="number">6</span>: istore_2 <span class="comment">//将数字2从操作栈弹出，压入到本地变量表中，下标为2</span></span><br><span class="line"> 7: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line"><span class="number">10</span>: iload_2 <span class="comment">//从本地变量表中获取下标为2的数据（2），压入到操作栈中</span></span><br><span class="line">11: invokevirtual #7                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line"><span class="number">14</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>区别：</p><ul><li>i++<ul><li>只是在本地变量中对数字做了相加，并没有将数据压入到操作栈</li><li>将前面拿到的数字1，再次从操作栈中拿到，压入到本地变量中</li></ul></li><li>++i<ul><li>将本地变量中的数字做了相加，并且将数据压入到操作栈</li><li>将操作栈中的数据，再次压入到本地变量中</li></ul></li></ul><p>小结：可以通过查看字节码的方式对代码的底层做研究，探究其原理。</p><h3 id="2-6、字符串拼接"><a href="#2-6、字符串拼接" class="headerlink" title="2.6、字符串拼接"></a>2.6、字符串拼接</h3><p>字符串的拼接在开发过程中使用是非常频繁的，常用的方式有三种：</p><ul><li>+号拼接： str+”456”</li><li>StringBuilder拼接</li><li>StringBuffer拼接</li></ul><p>StringBuffer是保证线程安全的，效率是比较低的，我们更多的是使用场景是不会涉及到线程安全的问题的，所以更多的时候会选择StringBuilder，效率会高一些。</p><p>那么，问题来了，StringBuilder和“+”号拼接，哪个效率高呢？接下来我们通过字节码的方式进行探究。</p><p>首先，编写个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bestqiang.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test3().m1();</span><br><span class="line">        <span class="keyword">new</span> Test3().m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">"123"</span>;</span><br><span class="line">        String s2 = <span class="string">"456"</span>;</span><br><span class="line">        String s3 = s1 + s2;</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">"123"</span>;</span><br><span class="line">        String s2 = <span class="string">"456"</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(s1);</span><br><span class="line">        sb.append(s2);</span><br><span class="line">        String s3 = sb.toString();</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看Test3.class的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">Classfile /F:/code/bestqiang-jvm/bestqiang-jvm-test/target/classes/cn/bestqiang/jvm/Test3.class</span><br><span class="line">  MD5 checksum b3f7629e7e37768b9b5581be01df40d6</span><br><span class="line">  Compiled from <span class="string">"Test3.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cn</span>.<span class="title">bestqiang</span>.<span class="title">jvm</span>.<span class="title">Test3</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #14.#36        // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Class              #37            // cn/bestqiang/jvm/Test3</span><br><span class="line">   #3 = Methodref          #2.#36         // cn/bestqiang/jvm/Test3."&lt;init&gt;":()V</span><br><span class="line">   #4 = Methodref          #2.#38         // cn/bestqiang/jvm/Test3.m1:()V</span><br><span class="line">   #5 = Methodref          #2.#39         // cn/bestqiang/jvm/Test3.m2:()V</span><br><span class="line">   #6 = String             #40            // 123</span><br><span class="line">   #7 = String             #41            // 456</span><br><span class="line">   #8 = Class              #42            // java/lang/StringBuilder</span><br><span class="line">   #9 = Methodref          #8.#36         // java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">  #10 = Methodref          #8.#43         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #11 = Methodref          #8.#44         // java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">  #12 = Fieldref           #45.#46        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">  #13 = Methodref          #47.#48        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #14 = Class              #49            // java/lang/Object</span><br><span class="line">  #15 = Utf8               &lt;init&gt;</span><br><span class="line">  #16 = Utf8               ()V</span><br><span class="line">  #17 = Utf8               Code</span><br><span class="line">  #18 = Utf8               LineNumberTable</span><br><span class="line">  #19 = Utf8               LocalVariableTable</span><br><span class="line">  #20 = Utf8               this</span><br><span class="line">  #21 = Utf8               Lcn/bestqiang/jvm/Test3;</span><br><span class="line">  #22 = Utf8               main</span><br><span class="line">  #23 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #24 = Utf8               args</span><br><span class="line">  #25 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #26 = Utf8               m1</span><br><span class="line">  #27 = Utf8               s1</span><br><span class="line">  #28 = Utf8               Ljava/lang/String;</span><br><span class="line">  #29 = Utf8               s2</span><br><span class="line">  #30 = Utf8               s3</span><br><span class="line">  #31 = Utf8               m2</span><br><span class="line">  #32 = Utf8               sb</span><br><span class="line">  #33 = Utf8               Ljava/lang/StringBuilder;</span><br><span class="line">  #34 = Utf8               SourceFile</span><br><span class="line">  #35 = Utf8               Test3.java</span><br><span class="line">  #36 = NameAndType        #15:#16        // "&lt;init&gt;":()V</span><br><span class="line">  #37 = Utf8               cn/bestqiang/jvm/Test3</span><br><span class="line">  #38 = NameAndType        #26:#16        // m1:()V</span><br><span class="line">  #39 = NameAndType        #31:#16        // m2:()V</span><br><span class="line">  #40 = Utf8               123</span><br><span class="line">  #41 = Utf8               456</span><br><span class="line">  #42 = Utf8               java/lang/StringBuilder</span><br><span class="line">  #43 = NameAndType        #50:#51        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #44 = NameAndType        #52:#53        // toString:()Ljava/lang/String;</span><br><span class="line">  #45 = Class              #54            // java/lang/System</span><br><span class="line">  #46 = NameAndType        #55:#56        // out:Ljava/io/PrintStream;</span><br><span class="line">  #47 = Class              #57            // java/io/PrintStream</span><br><span class="line">  #48 = NameAndType        #58:#59        // println:(Ljava/lang/String;)V</span><br><span class="line">  #49 = Utf8               java/lang/Object</span><br><span class="line">  #50 = Utf8               append</span><br><span class="line">  #51 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #52 = Utf8               toString</span><br><span class="line">  #53 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #54 = Utf8               java/lang/System</span><br><span class="line">  #55 = Utf8               out</span><br><span class="line">  #56 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #57 = Utf8               java/io/PrintStream</span><br><span class="line">  #58 = Utf8               println</span><br><span class="line">  #59 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> cn.bestqiang.jvm.Test3();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/bestqiang/jvm/Test3;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #2                  // class cn/bestqiang/jvm/Test3</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #3                  // Method "&lt;init&gt;":()V</span><br><span class="line">         7: invokevirtual #4                  // Method m1:()V</span><br><span class="line">        10: new           #2                  // class cn/bestqiang/jvm/Test3</span><br><span class="line">        <span class="number">13</span>: dup</span><br><span class="line">        14: invokespecial #3                  // Method "&lt;init&gt;":()V</span><br><span class="line">        17: invokevirtual #5                  // Method m2:()V</span><br><span class="line">        <span class="number">20</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">20</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">21</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #6                  // String 123</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         3: ldc           #7                  // String 456</span><br><span class="line">         <span class="number">5</span>: astore_2</span><br><span class="line">         6: new           #8                  // class java/lang/StringBuilder</span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        10: invokespecial #9                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">        <span class="number">13</span>: aload_1</span><br><span class="line">        14: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">17</span>: aload_2</span><br><span class="line">        18: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        21: invokevirtual #11                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        <span class="number">24</span>: astore_3</span><br><span class="line">        25: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">28</span>: aload_3</span><br><span class="line">        29: invokevirtual #13                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">32</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">25</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">32</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">33</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/bestqiang/jvm/Test3;</span><br><span class="line">            <span class="number">3</span>      <span class="number">30</span>     <span class="number">1</span>    s1   Ljava/lang/String;</span><br><span class="line">            <span class="number">6</span>      <span class="number">27</span>     <span class="number">2</span>    s2   Ljava/lang/String;</span><br><span class="line">           <span class="number">25</span>       <span class="number">8</span>     <span class="number">3</span>    s3   Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #6                  // String 123</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         3: ldc           #7                  // String 456</span><br><span class="line">         <span class="number">5</span>: astore_2</span><br><span class="line">         6: new           #8                  // class java/lang/StringBuilder</span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        10: invokespecial #9                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">        <span class="number">13</span>: astore_3</span><br><span class="line">        <span class="number">14</span>: aload_3</span><br><span class="line">        <span class="number">15</span>: aload_1</span><br><span class="line">        16: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">19</span>: pop</span><br><span class="line">        <span class="number">20</span>: aload_3</span><br><span class="line">        <span class="number">21</span>: aload_2</span><br><span class="line">        22: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">25</span>: pop</span><br><span class="line">        <span class="number">26</span>: aload_3</span><br><span class="line">        27: invokevirtual #11                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        <span class="number">30</span>: astore        <span class="number">4</span></span><br><span class="line">        32: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">35</span>: aload         <span class="number">4</span></span><br><span class="line">        37: invokevirtual #13                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">40</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">18</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">14</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">20</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">26</span></span><br><span class="line">        line <span class="number">24</span>: <span class="number">32</span></span><br><span class="line">        line <span class="number">25</span>: <span class="number">40</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">41</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/bestqiang/jvm/Test3;</span><br><span class="line">            <span class="number">3</span>      <span class="number">38</span>     <span class="number">1</span>    s1   Ljava/lang/String;</span><br><span class="line">            <span class="number">6</span>      <span class="number">35</span>     <span class="number">2</span>    s2   Ljava/lang/String;</span><br><span class="line">           <span class="number">14</span>      <span class="number">27</span>     <span class="number">3</span>    sb   Ljava/lang/StringBuilder;</span><br><span class="line">           <span class="number">32</span>       <span class="number">9</span>     <span class="number">4</span>    s3   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"Test3.java"</span></span><br></pre></td></tr></table></figure><p>从解字节码中可以看出，m1()方法源码中是使用+号拼接，但是在字节码中也被编译成了StringBuilder方式。</p><p>所以，可以得出结论，字符串拼接，+号和StringBuilder是相等的，效率一样。</p><p>接下来，我们再看一个案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.bestqiang.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test4().m1();</span><br><span class="line">        <span class="keyword">new</span> Test4().m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            str = str + i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            sb.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>m1() 与 m2() 哪个方法的效率高？</p><p>依然是通过字节码的方式进行探究。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">Classfile /F:/code/bestqiang-jvm/bestqiang-jvm-test/target/classes/cn/bestqiang/jvm/Test4.class</span><br><span class="line">  MD5 checksum f87a55446b8b6cd88b6e54bd5edcc9dc</span><br><span class="line">  Compiled from <span class="string">"Test4.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cn</span>.<span class="title">bestqiang</span>.<span class="title">jvm</span>.<span class="title">Test4</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #14.#39        // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Class              #40            // cn/bestqiang/jvm/Test4</span><br><span class="line">   #3 = Methodref          #2.#39         // cn/bestqiang/jvm/Test4."&lt;init&gt;":()V</span><br><span class="line">   #4 = Methodref          #2.#41         // cn/bestqiang/jvm/Test4.m1:()V</span><br><span class="line">   #5 = Methodref          #2.#42         // cn/bestqiang/jvm/Test4.m2:()V</span><br><span class="line">   #6 = String             #43            //</span><br><span class="line">   #7 = Class              #44            // java/lang/StringBuilder</span><br><span class="line">   #8 = Methodref          #7.#39         // java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">   #9 = Methodref          #7.#45         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #10 = Methodref          #7.#46         // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">  #11 = Methodref          #7.#47         // java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">  #12 = Fieldref           #48.#49        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">  #13 = Methodref          #50.#51        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #14 = Class              #52            // java/lang/Object</span><br><span class="line">  #15 = Utf8               &lt;init&gt;</span><br><span class="line">  #16 = Utf8               ()V</span><br><span class="line">  #17 = Utf8               Code</span><br><span class="line">  #18 = Utf8               LineNumberTable</span><br><span class="line">  #19 = Utf8               LocalVariableTable</span><br><span class="line">  #20 = Utf8               this</span><br><span class="line">  #21 = Utf8               Lcn/bestqiang/jvm/Test4;</span><br><span class="line">  #22 = Utf8               main</span><br><span class="line">  #23 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #24 = Utf8               args</span><br><span class="line">  #25 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #26 = Utf8               m1</span><br><span class="line">  #27 = Utf8               i</span><br><span class="line">  #28 = Utf8               I</span><br><span class="line">  #29 = Utf8               str</span><br><span class="line">  #30 = Utf8               Ljava/lang/String;</span><br><span class="line">  #31 = Utf8               StackMapTable</span><br><span class="line">  #32 = Class              #53            // java/lang/String</span><br><span class="line">  #33 = Utf8               m2</span><br><span class="line">  #34 = Utf8               sb</span><br><span class="line">  #35 = Utf8               Ljava/lang/StringBuilder;</span><br><span class="line">  #36 = Class              #44            // java/lang/StringBuilder</span><br><span class="line">  #37 = Utf8               SourceFile</span><br><span class="line">  #38 = Utf8               Test4.java</span><br><span class="line">  #39 = NameAndType        #15:#16        // "&lt;init&gt;":()V</span><br><span class="line">  #40 = Utf8               cn/bestqiang/jvm/Test4</span><br><span class="line">  #41 = NameAndType        #26:#16        // m1:()V</span><br><span class="line">  #42 = NameAndType        #33:#16        // m2:()V</span><br><span class="line">  #43 = Utf8</span><br><span class="line">  #44 = Utf8               java/lang/StringBuilder</span><br><span class="line">  #45 = NameAndType        #54:#55        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #46 = NameAndType        #54:#56        // append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">  #47 = NameAndType        #57:#58        // toString:()Ljava/lang/String;</span><br><span class="line">  #48 = Class              #59            // java/lang/System</span><br><span class="line">  #49 = NameAndType        #60:#61        // out:Ljava/io/PrintStream;</span><br><span class="line">  #50 = Class              #62            // java/io/PrintStream</span><br><span class="line">  #51 = NameAndType        #63:#64        // println:(Ljava/lang/String;)V</span><br><span class="line">  #52 = Utf8               java/lang/Object</span><br><span class="line">  #53 = Utf8               java/lang/String</span><br><span class="line">  #54 = Utf8               append</span><br><span class="line">  #55 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #56 = Utf8               (I)Ljava/lang/StringBuilder;</span><br><span class="line">  #57 = Utf8               toString</span><br><span class="line">  #58 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #59 = Utf8               java/lang/System</span><br><span class="line">  #60 = Utf8               out</span><br><span class="line">  #61 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #62 = Utf8               java/io/PrintStream</span><br><span class="line">  #63 = Utf8               println</span><br><span class="line">  #64 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> cn.bestqiang.jvm.Test4();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/bestqiang/jvm/Test4;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #2                  // class cn/bestqiang/jvm/Test4</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #3                  // Method "&lt;init&gt;":()V</span><br><span class="line">         7: invokevirtual #4                  // Method m1:()V</span><br><span class="line">        10: new           #2                  // class cn/bestqiang/jvm/Test4</span><br><span class="line">        <span class="number">13</span>: dup</span><br><span class="line">        14: invokespecial #3                  // Method "&lt;init&gt;":()V</span><br><span class="line">        17: invokevirtual #5                  // Method m2:()V</span><br><span class="line">        <span class="number">20</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">20</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">21</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #6                  // String</span><br><span class="line">         <span class="number">2</span>: astore_1  <span class="comment">// 将空字符串压入到本地变量表中的下标为1的位置</span></span><br><span class="line">         <span class="number">3</span>: iconst_0  <span class="comment">// 将数字0压入操作栈顶</span></span><br><span class="line">         <span class="number">4</span>: istore_2  <span class="comment">// 将栈顶数字0压入到本地变量表中的下标为2的位置</span></span><br><span class="line">         <span class="number">5</span>: iload_2  <span class="comment">// 将本地变量中下标为2的数字0压入操作栈顶</span></span><br><span class="line">         <span class="number">6</span>: iconst_5 <span class="comment">// 将数字5压入操作栈顶</span></span><br><span class="line">         <span class="number">7</span>: if_icmpge     <span class="number">35</span>  <span class="comment">//比较栈顶两int型数值大小，当结果大于等于0时跳转到35</span></span><br><span class="line">        10: new           #7                  // class java/lang/StringBuilder</span><br><span class="line">        <span class="number">13</span>: dup  <span class="comment">//复制栈顶数值并将复制值压入栈顶(数字5)</span></span><br><span class="line">        14: invokespecial #8                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">        <span class="number">17</span>: aload_1</span><br><span class="line">        18: invokevirtual #9                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">21</span>: iload_2 <span class="comment">//将本地变量中下标为2的数字0压入操作栈顶</span></span><br><span class="line">        22: invokevirtual #10                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        25: invokevirtual #11                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        <span class="number">28</span>: astore_1</span><br><span class="line">        <span class="number">29</span>: iinc          <span class="number">2</span>, <span class="number">1</span></span><br><span class="line">        <span class="number">32</span>: goto          <span class="number">5</span></span><br><span class="line">        35: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">38</span>: aload_1</span><br><span class="line">        39: invokevirtual #13                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">42</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">29</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">35</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">42</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">5</span>      <span class="number">30</span>     <span class="number">2</span>     i   I</span><br><span class="line">            <span class="number">0</span>      <span class="number">43</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/bestqiang/jvm/Test4;</span><br><span class="line">            <span class="number">3</span>      <span class="number">40</span>     <span class="number">1</span>   str   Ljava/lang/String;</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">253</span> <span class="comment">/* append */</span></span><br><span class="line">          offset_delta = <span class="number">5</span></span><br><span class="line">          locals = [ class java/lang/String, int ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">29</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #7                  // class java/lang/StringBuilder</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #8                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: iconst_0</span><br><span class="line">         <span class="number">9</span>: istore_2</span><br><span class="line">        <span class="number">10</span>: iload_2</span><br><span class="line">        <span class="number">11</span>: iconst_5</span><br><span class="line">        <span class="number">12</span>: if_icmpge     <span class="number">27</span></span><br><span class="line">        <span class="number">15</span>: aload_1</span><br><span class="line">        <span class="number">16</span>: iload_2</span><br><span class="line">        17: invokevirtual #10                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">20</span>: pop</span><br><span class="line">        <span class="number">21</span>: iinc          <span class="number">2</span>, <span class="number">1</span></span><br><span class="line">        <span class="number">24</span>: goto          <span class="number">10</span></span><br><span class="line">        27: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">30</span>: aload_1</span><br><span class="line">        31: invokevirtual #11                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        34: invokevirtual #13                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">37</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">19</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">15</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">21</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">27</span></span><br><span class="line">        line <span class="number">24</span>: <span class="number">37</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">10</span>      <span class="number">17</span>     <span class="number">2</span>     i   I</span><br><span class="line">            <span class="number">0</span>      <span class="number">38</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/bestqiang/jvm/Test4;</span><br><span class="line">            <span class="number">8</span>      <span class="number">30</span>     <span class="number">1</span>    sb   Ljava/lang/StringBuilder;</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">253</span> <span class="comment">/* append */</span></span><br><span class="line">          offset_delta = <span class="number">10</span></span><br><span class="line">          locals = [ class java/lang/StringBuilder, int ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"Test4.java"</span></span><br></pre></td></tr></table></figure><p>可以看到，m1()方法中的循环体内，每一次循环都会创建StringBuilder对象，效率低于m2()方法。</p><h3 id="2-7、小结"><a href="#2-7、小结" class="headerlink" title="2.7、小结"></a>2.7、小结</h3><p>使用字节码的方式可以很好查看代码底层的执行，从而可以看出哪些实现效率高，哪些实现效率低。可以更好的对我们的代码做优化。让程序执行效率更高。</p><h2 id="3、代码优化"><a href="#3、代码优化" class="headerlink" title="3、代码优化"></a>3、代码优化</h2><p>优化，不仅仅是在运行环境进行优化，还需要在代码本身做优化，如果代码本身存在性能问题，那么在其他方面再怎么优化也不可能达到效果最优的。</p><h3 id="3-1、尽可能使用局部变量"><a href="#3-1、尽可能使用局部变量" class="headerlink" title="3.1、尽可能使用局部变量"></a>3.1、尽可能使用局部变量</h3><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p><h3 id="3-2、尽量减少对变量的重复计算"><a href="#3-2、尽量减少对变量的重复计算" class="headerlink" title="3.2、尽量减少对变量的重复计算"></a>3.2、尽量减少对变量的重复计算</h3><p>明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的。所以例如下面的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><p>建议替换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> length = list.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>,  i &lt; length; i++)</span><br><span class="line"></span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><p>这样，在list.size()很大的时候，就减少了很多的消耗。</p><h3 id="3-3、尽量采用懒加载的策略，即在需要的时候才创建"><a href="#3-3、尽量采用懒加载的策略，即在需要的时候才创建" class="headerlink" title="3.3、尽量采用懒加载的策略，即在需要的时候才创建"></a>3.3、尽量采用懒加载的策略，即在需要的时候才创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"aaa"</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">　　list.add(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建议替换成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">　　String str = <span class="string">"aaa"</span>;</span><br><span class="line">　　list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4、异常不应该用来控制程序流程"><a href="#3-4、异常不应该用来控制程序流程" class="headerlink" title="3.4、异常不应该用来控制程序流程"></a>3.4、异常不应该用来控制程序流程</h3><p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方 法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建 了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p><h3 id="3-5、不要将数组声明为public-static-final"><a href="#3-5、不要将数组声明为public-static-final" class="headerlink" title="3.5、不要将数组声明为public static final"></a>3.5、不要将数组声明为public static final</h3><p>因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变。</p><h3 id="3-6、不要创建一些不使用的对象，不要导入一些不使用的类"><a href="#3-6、不要创建一些不使用的对象，不要导入一些不使用的类" class="headerlink" title="3.6、不要创建一些不使用的对象，不要导入一些不使用的类"></a>3.6、不要创建一些不使用的对象，不要导入一些不使用的类</h3><p>这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容</p><h3 id="3-7、程序运行过程中避免使用反射"><a href="#3-7、程序运行过程中避免使用反射" class="headerlink" title="3.7、程序运行过程中避免使用反射"></a>3.7、程序运行过程中避免使用反射</h3><p>反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是 Method的invoke方法。</p><p>如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存。</p><h3 id="3-8、使用数据库连接池和线程池"><a href="#3-8、使用数据库连接池和线程池" class="headerlink" title="3.8、使用数据库连接池和线程池"></a>3.8、使用数据库连接池和线程池</h3><p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程。</p><h3 id="3-9、容器初始化时尽可能指定长度"><a href="#3-9、容器初始化时尽可能指定长度" class="headerlink" title="3.9、容器初始化时尽可能指定长度"></a>3.9、容器初始化时尽可能指定长度</h3><p>容器初始化时尽可能指定长度，如：new ArrayList&lt;&gt;(10); new HashMap&lt;&gt;(32); 避免容器长度不足时，扩容带来的性能损耗。</p><h3 id="3-10、ArrayList随机遍历快，LinkedList添加删除快"><a href="#3-10、ArrayList随机遍历快，LinkedList添加删除快" class="headerlink" title="3.10、ArrayList随机遍历快，LinkedList添加删除快"></a>3.10、ArrayList随机遍历快，LinkedList添加删除快</h3><h3 id="3-11、使用Entry遍历Map"><a href="#3-11、使用Entry遍历Map" class="headerlink" title="3.11、使用Entry遍历Map"></a>3.11、使用Entry遍历Map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String,String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免使用这种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    String value = map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-12、不要手动调用System-gc"><a href="#3-12、不要手动调用System-gc" class="headerlink" title="3.12、不要手动调用System.gc();"></a>3.12、不要手动调用System.gc();</h3><h3 id="3-13、String尽量少用正则表达式"><a href="#3-13、String尽量少用正则表达式" class="headerlink" title="3.13、String尽量少用正则表达式"></a>3.13、String尽量少用正则表达式</h3><p>正则表达式虽然功能强大，但是其效率较低，除非是有需要，否则尽可能少用。</p><p>replace()  不支持正则<br>replaceAll() 支持正则</p><p>如果仅仅是字符的替换建议使用replace()。</p><h3 id="3-14、日志的输出要注意级别"><a href="#3-14、日志的输出要注意级别" class="headerlink" title="3.14、日志的输出要注意级别"></a>3.14、日志的输出要注意级别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前的日志级别是error</span></span><br><span class="line">LOGGER.info(<span class="string">"保存出错！"</span> + user);</span><br></pre></td></tr></table></figure><h3 id="3-15、对资源的close-建议分开操作"><a href="#3-15、对资源的close-建议分开操作" class="headerlink" title="3.15、对资源的close()建议分开操作"></a>3.15、对资源的close()建议分开操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    XXX.close();</span><br><span class="line">    YYY.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议改为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    XXX.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">    YYY.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JVM优化-Tomcat优化&quot;&gt;&lt;a href=&quot;#JVM优化-Tomcat优化&quot; class=&quot;headerlink&quot; title=&quot;JVM优化+Tomcat优化&quot;&gt;&lt;/a&gt;JVM优化+Tomcat优化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Tomcat8的优化&lt;/li&gt;
&lt;li&gt;看懂Java底层字节码&lt;/li&gt;
&lt;li&gt;编码的优化建议&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>GC之垃圾回收算法和垃圾处理器</title>
    <link href="http://yoursite.com/2019/05/30/GC%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%92%8C%E5%9E%83%E5%9C%BE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://yoursite.com/2019/05/30/GC之垃圾回收算法和垃圾处理器/</id>
    <published>2019-05-30T05:29:10.000Z</published>
    <updated>2020-07-27T09:25:36.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GC之常见的垃圾回收算法和垃圾处理器"><a href="#GC之常见的垃圾回收算法和垃圾处理器" class="headerlink" title="GC之常见的垃圾回收算法和垃圾处理器"></a>GC之常见的垃圾回收算法和垃圾处理器</h1><ul><li>了解什么是垃圾回收</li><li>掌握垃圾会回收的常见算法</li><li>学习串行、并行、并发、G1垃圾收集器</li><li>学习GC日志的可视化查看</li></ul><a id="more"></a><h2 id="1、什么是垃圾回收？"><a href="#1、什么是垃圾回收？" class="headerlink" title="1、什么是垃圾回收？"></a>1、什么是垃圾回收？</h2><p>程序的运行必然需要申请内存资源，无效的对象资源如果不及时处理就会一直占有内存资源，最终将导致内存溢出，所以对内存资源的管理是非常重要了。</p><h3 id="1-1、C-C-语言的垃圾回收"><a href="#1-1、C-C-语言的垃圾回收" class="headerlink" title="1.1、C/C++语言的垃圾回收"></a>1.1、C/C++语言的垃圾回收</h3><p>在C/C++语言中，没有自动垃圾回收机制，是通过new关键字申请内存资源，通过delete关键字释放内存资源。</p><p>如果，程序员在某些位置没有写delete进行释放，那么申请的对象将一直占用内存资源，最终可能会导致内存溢出。</p><h3 id="1-2、Java语言的垃圾回收"><a href="#1-2、Java语言的垃圾回收" class="headerlink" title="1.2、Java语言的垃圾回收"></a>1.2、Java语言的垃圾回收</h3><p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC。</p><p>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。</p><p>换句话说，自动的垃圾回收的算法就会变得非常重要了，如果因为算法的不合理，导致内存资源一直没有释放，同样也可能会导致内存溢出的。</p><p>当然，除了Java语言，C#、Python等语言也都有自动的垃圾回收机制。</p><h2 id="2、垃圾回收的常见算法"><a href="#2、垃圾回收的常见算法" class="headerlink" title="2、垃圾回收的常见算法"></a>2、垃圾回收的常见算法</h2><p>自动化的管理内存资源，垃圾回收机制必须要有一套算法来进行计算，哪些是有效的对象，哪些是无效的对象，对于无效的对象就要进行回收处理。</p><p>常见的垃圾回收算法有：引用计数法、标记清除法、标记压缩法、复制算法、分代算法等。</p><h3 id="2-1、引用计数法"><a href="#2-1、引用计数法" class="headerlink" title="2.1、引用计数法"></a>2.1、引用计数法</h3><p>引用计数是历史最悠久的一种算法，最早George E. Collins在1960的时候首次提出，50年后的今天，该算法依然被很多编程语言使用。</p><h4 id="2-1-1、原理"><a href="#2-1-1、原理" class="headerlink" title="2.1.1、原理"></a>2.1.1、原理</h4><p>假设有一个对象A，任何一个对象对A的引用，那么对象A的引用计数器+1，当引用失败时，对象A的引用计数器就-1，如果对象A的计数器的值为0，就说明对象A没有引用了，可以被回收。</p><h4 id="2-1-2、优缺点"><a href="#2-1-2、优缺点" class="headerlink" title="2.1.2、优缺点"></a>2.1.2、优缺点</h4><p>优点：</p><ul><li>实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。</li><li>在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报outofmember 错误。</li><li>区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。</li></ul><p>缺点：</p><ul><li>每次对象被引用时，都需要去更新计数器，有一点时间开销。</li><li>浪费CPU资源，即使内存够用，仍然在运行时进行计数器的统计。</li><li>无法解决循环引用问题。（最大的缺点）</li></ul><p>什么是循环引用？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> TestB b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> TestA a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        a.b=b;</span><br><span class="line">        b.a=a;</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然a和b都为null，但是由于a和b存在循环引用，这样a和b永远都不会被回收。</p><h3 id="2-2、标记清除法"><a href="#2-2、标记清除法" class="headerlink" title="2.2、标记清除法"></a>2.2、标记清除法</h3><p>标记清除算法，是将垃圾回收分为2个阶段，分别是标记和清除。</p><ul><li>标记：从根节点开始标记引用的对象。</li><li>清除：未被标记引用的对象就是垃圾对象，可以被清理。</li></ul><h4 id="2-2-1、原理"><a href="#2-2-1、原理" class="headerlink" title="2.2.1、原理"></a>2.2.1、原理</h4><p> <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/19222114-6435e25e050f4a2ea3230879392bdfb3.jpg" alt="img"></p><p>这张图代表的是程序运行期间所有对象的状态，它们的标志位全部是0（也就是未标记，以下默认0就是未标记，1为已标记），假设这会儿有效内存空间耗尽了，JVM将会停止应用程序的运行并开启GC线程，然后开始进行标记工作，按照根搜索算法，标记完以后，对象的状态如下图。</p><p> <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/19222543-1da7fb7bc5d24fd18872a267b65e939e.jpg" alt="img"></p><p>可以看到，按照根搜索算法，所有从root对象可达的对象就被标记为了存活的对象，此时已经完成了第一阶段标记。接下来，就要执行第二阶段清除了，那么清除完以后，剩下的对象以及对象的状态如下图所示。</p><p> <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/19222820-8eca1c1518754d8fac6da532b13f746b.jpg" alt="img"></p><p>可以看到，没有被标记的对象将会回收清除掉，而被标记的对象将会留下，并且会将标记位重新归0。接下来就不用说了，唤醒停止的程序线程，让程序继续运行即可。</p><h4 id="2-2-2、优缺点"><a href="#2-2-2、优缺点" class="headerlink" title="2.2.2、优缺点"></a>2.2.2、优缺点</h4><p>可以看到，标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收。</p><p>同样，标记清除算法也是有缺点的：</p><ul><li>效率较低，标记和清除两个动作都需要遍历所有的对象，并且在GC时，需要停止应用程序，对于交互性要求比较高的应用而言这个体验是非常差的。</li><li>通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。</li></ul><h3 id="2-3、标记压缩算法"><a href="#2-3、标记压缩算法" class="headerlink" title="2.3、标记压缩算法"></a>2.3、标记压缩算法</h3><p>标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的清理未标记的对象，而是将存活的对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决了碎片化的问题。</p><h4 id="2-3-1、原理"><a href="#2-3-1、原理" class="headerlink" title="2.3.1、原理"></a>2.3.1、原理</h4><p> <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/5b82c8100001b6ec07200388.jpg" alt="img"></p><h4 id="2-3-2、优缺点"><a href="#2-3-2、优缺点" class="headerlink" title="2.3.2、优缺点"></a>2.3.2、优缺点</h4><p>优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有有一定的影响。</p><h3 id="2-4、复制算法"><a href="#2-4、复制算法" class="headerlink" title="2.4、复制算法"></a>2.4、复制算法</h3><p>复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。</p><p>如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之，则不适合。 </p><p> <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/5b82c80f000133c207200396.jpg" alt="img"></p><h4 id="2-4-1、JVM中年轻代内存空间"><a href="#2-4-1、JVM中年轻代内存空间" class="headerlink" title="2.4.1、JVM中年轻代内存空间"></a>2.4.1、JVM中年轻代内存空间</h4><p><img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/young_gc.png" alt="young_gc"></p><ol><li>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。</li><li>紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。</li><li>经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。</li><li>GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</li></ol><h4 id="2-4-2、优缺点"><a href="#2-4-2、优缺点" class="headerlink" title="2.4.2、优缺点"></a>2.4.2、优缺点</h4><p>优点：</p><ul><li>在垃圾对象多的情况下，效率较高</li><li>清理后，内存无碎片</li></ul><p>缺点：</p><ul><li>在垃圾对象少的情况下，不适用，如：老年代内存</li><li>分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低</li></ul><h3 id="2-5、分代算法"><a href="#2-5、分代算法" class="headerlink" title="2.5、分代算法"></a>2.5、分代算法</h3><p>前面介绍了多种回收算法，每一种算法都有自己的优点也有缺点，谁都不能替代谁，所以根据垃圾回收对象的特点进行选择，才是明智的选择。</p><p>分代算法其实就是这样的，根据回收对象的特点进行选择，在jvm中，年轻代适合使用复制算法，老年代适合使用标记清除或标记压缩算法。</p><h1 id="接下来就是垃圾回收器了！"><a href="#接下来就是垃圾回收器了！" class="headerlink" title="接下来就是垃圾回收器了！"></a>接下来就是垃圾回收器了！</h1><hr><h2 id="3、垃圾收集器以及内存分配"><a href="#3、垃圾收集器以及内存分配" class="headerlink" title="3、垃圾收集器以及内存分配"></a>3、垃圾收集器以及内存分配</h2><p>前面我们讲了垃圾回收的算法，还需要有具体的实现，在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器、CMS（并发）垃圾收集器、G1垃圾收集器，接下来，我们一个个的了解学习。</p><p><img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/1559196496204.png" alt="1559196496204"></p><h3 id="3-1、串行垃圾收集器"><a href="#3-1、串行垃圾收集器" class="headerlink" title="3.1、串行垃圾收集器"></a>3.1、串行垃圾收集器</h3><p>串行垃圾收集器，是指使用单线程进行垃圾回收，垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停，等待垃圾回收的完成。这种现象称之为STW（Stop-The-World）。</p><p>对于交互性较强的应用而言，这种垃圾收集器是不能够接受的。</p><p>一般在Javaweb应用中是不会采用该收集器的。</p><p><img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/1559196000373.png" alt="1559196000373"></p><p><img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/1559196264218.png" alt="1559196264218"></p><h4 id="3-1-1、编写测试代码"><a href="#3-1-1、编写测试代码" class="headerlink" title="3.1.1、编写测试代码"></a>3.1.1、编写测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bestqiang.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sleep = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">if</span>(System.currentTimeMillis() % <span class="number">2</span> ==<span class="number">0</span>)&#123;</span><br><span class="line">                list.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">                    properties.put(<span class="string">"key_"</span>+i, <span class="string">"value_"</span> + System.currentTimeMillis() + i);</span><br><span class="line">                    list.add(properties);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// System.out.println("list大小为：" + list.size());</span></span><br><span class="line"></span><br><span class="line">            Thread.sleep(sleep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2、设置垃圾回收为串行收集器"><a href="#3-1-2、设置垃圾回收为串行收集器" class="headerlink" title="3.1.2、设置垃圾回收为串行收集器"></a>3.1.2、设置垃圾回收为串行收集器</h4><p>在程序运行参数中添加2个参数，如下：</p><ul><li>-XX:+UseSerialGC<ul><li>指定年轻代和老年代都使用串行垃圾收集器</li></ul></li><li>-XX:+PrintGCDetails<ul><li>打印垃圾回收的详细信息</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 为了测试GC，将堆的初始和最大内存都设置为16M</span><br><span class="line">-XX:+UseSerialGC -XX:+PrintGCDetails -Xms16m -Xmx16m</span><br></pre></td></tr></table></figure><p> <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/1537636794330.png" alt="1537636794330"></p><p>启动程序，可以看到下面信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 4416K-&gt;512K(4928K), 0.0046102 secs] 4416K-&gt;1973K(15872K), 0.0046533 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line"></span><br><span class="line">[Full GC (Allocation Failure) [Tenured: 10944K-&gt;3107K(10944K), 0.0085637 secs] 15871K-&gt;3107K(15872K), [Metaspace: 3496K-&gt;3496K(1056768K)], 0.0085974 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure><p>GC日志信息解读：</p><p>年轻代的内存GC前后的大小：</p><ul><li>DefNew<ul><li>表示使用的是串行垃圾收集器。</li></ul></li><li>4416K-&gt;512K(4928K)<ul><li>表示，年轻代GC前，占有4416K内存，GC后，占有512K内存，总大小4928K</li></ul></li><li>0.0046102 secs<ul><li>表示，GC所用的时间，单位为毫秒。</li></ul></li><li>4416K-&gt;1973K(15872K)<ul><li>表示，GC前，堆内存占有4416K，GC后，占有1973K，总大小为15872K</li></ul></li><li>Full GC<ul><li>表示，内存空间全部进行GC</li></ul></li></ul><h3 id="3-2、并行垃圾收集器"><a href="#3-2、并行垃圾收集器" class="headerlink" title="3.2、并行垃圾收集器"></a>3.2、并行垃圾收集器</h3><p>并行垃圾收集器在串行垃圾收集器的基础之上做了改进，将单线程改为了多线程进行垃圾回收，这样可以缩短垃圾回收的时间。（这里是指，并行能力较强的机器）</p><p>当然了，并行垃圾收集器在收集的过程中也会暂停应用程序，这个和串行垃圾回收器是一样的，只是并行执行，速度更快些，暂停的时间更短一些。</p><h4 id="3-2-1、ParNew垃圾收集器"><a href="#3-2-1、ParNew垃圾收集器" class="headerlink" title="3.2.1、ParNew垃圾收集器"></a>3.2.1、ParNew垃圾收集器</h4><p>ParNew垃圾收集器是工作在年轻代上的，只是将串行的垃圾收集器改为了<strong>并行</strong>。</p><p>通过-XX:+UseParNewGC参数设置年轻代使用ParNew回收器，老年代使用的依然是串行收集器。</p><p>测试：</p><p> <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/1537636907367.png" alt="1537636907367"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>参数</span><br><span class="line">-XX:+UseParNewGC -XX:+PrintGCDetails -Xms16m -Xmx16m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>打印出的信息</span><br><span class="line">[GC (Allocation Failure) [ParNew: 4416K-&gt;512K(4928K), 0.0032106 secs] 4416K-&gt;1988K(15872K), 0.0032697 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure><p>由以上信息可以看出，<code>ParNew:</code> 使用的是ParNew收集器。其他信息和串行收集器一致。</p><h4 id="3-2-2、ParallelGC垃圾收集器"><a href="#3-2-2、ParallelGC垃圾收集器" class="headerlink" title="3.2.2、ParallelGC垃圾收集器"></a>3.2.2、ParallelGC垃圾收集器</h4><p>ParallelGC收集器工作机制和ParNewGC收集器一样，只是在此基础之上，新增了两个和系统吞吐量相关的参数，使得其使用起来更加的灵活和高效。</p><p>相关参数如下：</p><ul><li>-XX:+UseParallelGC<ul><li>年轻代使用ParallelGC垃圾回收器，老年代使用串行回收器。</li></ul></li><li>-XX:+UseParallelOldGC<ul><li>年轻代使用ParallelGC垃圾回收器，老年代使用ParallelOldGC垃圾回收器。</li></ul></li><li>-XX:MaxGCPauseMillis<ul><li>设置最大的垃圾收集时的停顿时间，单位为毫秒</li><li>需要注意的时，ParallelGC为了达到设置的停顿时间，可能会调整堆大小或其他的参数，如果堆的大小设置的较小，就会导致GC工作变得很频繁，反而可能会影响到性能。</li><li>该参数使用需谨慎。</li></ul></li><li>-XX:GCTimeRatio<ul><li>设置垃圾回收时间占程序运行时间的百分比，公式为1/(1+n)。</li><li>它的值为0~100之间的数字，默认值为99，也就是垃圾回收时间不能超过1%</li></ul></li><li>-XX:UseAdaptiveSizePolicy<ul><li>自适应GC模式，垃圾回收器将自动调整年轻代、老年代等参数，达到吞吐量、堆大小、停顿时间之间的平衡。</li><li>一般用于，手动调整参数比较困难的场景，让收集器自动进行调整。</li></ul></li></ul><p>测试： <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/1537637452047.png" alt="1537637452047"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>参数</span><br><span class="line">-XX:+UseParallelGC -XX:+UseParallelOldGC -XX:MaxGCPauseMillis=100 -XX:+PrintGCDetails -Xms16m -Xmx16m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>打印的信息</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4096K-&gt;480K(4608K)] 4096K-&gt;1840K(15872K), 0.0034307 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line"></span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 505K-&gt;0K(4608K)] [ParOldGen: 10332K-&gt;10751K(11264K)] 10837K-&gt;10751K(15872K), [Metaspace: 3491K-&gt;3491K(1056768K)], 0.0793622 secs] [Times: user=0.13 sys=0.00, real=0.08 secs]</span><br></pre></td></tr></table></figure><p>有以上信息可以看出，年轻代和老年代都使用了ParallelGC垃圾回收器。</p><h3 id="3-3、CMS垃圾收集器"><a href="#3-3、CMS垃圾收集器" class="headerlink" title="3.3、CMS垃圾收集器"></a>3.3、CMS垃圾收集器</h3><p>CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，通过参数-XX:+UseConcMarkSweepGC进行设置。</p><p>CMS垃圾回收器的执行过程如下：</p><p> <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/2184951-cd90513432053c9a.png" alt="img"></p><ul><li>初始化标记(CMS-initial-mark) ,标记root，会导致stw； </li><li>并发标记(CMS-concurrent-mark)，与用户线程同时运行； </li><li>预清理（CMS-concurrent-preclean），与用户线程同时运行； </li><li>重新标记(CMS-remark) ，会导致stw； </li><li>并发清除(CMS-concurrent-sweep)，与用户线程同时运行； </li><li>调整堆大小，设置CMS在清理之后进行内存压缩，目的是清理内存中的碎片；</li><li>并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行； </li></ul><h4 id="3-3-1、测试"><a href="#3-3-1、测试" class="headerlink" title="3.3.1、测试"></a>3.3.1、测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>设置启动参数</span><br><span class="line">-XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -Xms16m -Xmx16m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>运行日志</span><br><span class="line">[GC (Allocation Failure) [ParNew: 4926K-&gt;512K(4928K), 0.0041843 secs] 9424K-&gt;6736K(15872K), 0.0042168 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>第一步，初始标记</span><br><span class="line">[GC (CMS Initial Mark) [1 CMS-initial-mark: 6224K(10944K)] 6824K(15872K), 0.0004209 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line"><span class="meta">#</span>第二步，并发标记</span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: 0.002/0.002 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line"><span class="meta">#</span>第三步，预处理</span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line"><span class="meta">#</span>第四步，重新标记</span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: 1657 K (4928 K)][Rescan (parallel) , 0.0005811 secs][weak refs processing, 0.0000136 secs][class unloading, 0.0003671 secs][scrub symbol table, 0.0006813 secs][scrub string table, 0.0001216 secs][1 CMS-remark: 6224K(10944K)] 7881K(15872K), 0.0018324 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line"><span class="meta">#</span>第五步，并发清理</span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">[CMS-concurrent-sweep: 0.004/0.004 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line"><span class="meta">#</span>第六步，重置</span><br><span class="line">[CMS-concurrent-reset-start]</span><br><span class="line">[CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure><p>由以上日志信息，可以看出CMS执行的过程。</p><h3 id="3-4、G1垃圾收集器（重点）"><a href="#3-4、G1垃圾收集器（重点）" class="headerlink" title="3.4、G1垃圾收集器（重点）"></a>3.4、G1垃圾收集器（重点）</h3><p>G1垃圾收集器是在jdk1.7中正式使用的全新的垃圾收集器，oracle官方计划在jdk9中将G1变成默认的垃圾收集器，以替代CMS。</p><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ol><li>第一步，开启G1垃圾收集器</li><li>第二步，设置堆的最大内存</li><li>第三步，设置最大的停顿时间</li></ol><p>G1中提供了三种模式垃圾回收模式，Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</p><h4 id="3-4-1、原理"><a href="#3-4-1、原理" class="headerlink" title="3.4.1、原理"></a>3.4.1、原理</h4><p>G1垃圾收集器相对比其他收集器而言，最大的区别在于它取消了年轻代、老年代的物理划分，取而代之的是将堆划分为若干个区域（Region），这些区域中包含了有逻辑上的年轻代、老年代区域。</p><p>这样做的好处就是，我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。</p><p> <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/20161222153407_691.png" alt="img"></p><p> <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/20161222153407_471.png" alt="img"></p><p>在G1划分的区域中，年轻代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。</p><p>这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。</p><p>在G1中，有一种特殊的区域，叫Humongous区域。 </p><ul><li>如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。</li><li>这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。</li><li>为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。</li></ul><h4 id="3-4-2、Young-GC"><a href="#3-4-2、Young-GC" class="headerlink" title="3.4.2、Young GC"></a>3.4.2、Young GC</h4><p>Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。</p><ul><li>Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。</li><li>Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。</li><li><p>最终Eden空间的数据为空，GC停止工作，应用线程继续执行。</p><p><img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/20161222153407_47.png" alt="img"></p><p><img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/20161222153408_747.png" alt="img"></p></li></ul><h5 id="3-4-2-1、Remembered-Set（已记忆集合）"><a href="#3-4-2-1、Remembered-Set（已记忆集合）" class="headerlink" title="3.4.2.1、Remembered Set（已记忆集合）"></a>3.4.2.1、Remembered Set（已记忆集合）</h5><p>在GC年轻代的对象时，我们如何找到年轻代中对象的根对象呢？ </p><p>根对象可能是在年轻代中，也可以在老年代中，那么老年代中的所有对象都是根么？</p><p>如果全量扫描老年代，那么这样扫描下来会耗费大量的时间。</p><p>于是，G1引进了RSet的概念。它的全称是Remembered Set，其作用是跟踪指向某个堆内的对象引用。</p><p> <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/2184951-bd04a968d1c8c895.png" alt="img"></p><p>每个Region初始化时，会初始化一个RSet，该集合用来记录并跟踪其它Region指向该Region中对象的引用，每个Region默认按照512Kb划分成多个Card，所以RSet需要记录的东西应该是 xx Region的 xx Card。</p><h4 id="3-4-3、Mixed-GC"><a href="#3-4-3、Mixed-GC" class="headerlink" title="3.4.3、Mixed GC"></a>3.4.3、Mixed GC</h4><p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region，这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC 并不是 Full GC。</p><p>MixedGC什么时候触发？  由参数 -XX:InitiatingHeapOccupancyPercent=n 决定。默认：45%，该参数的意思是：当老年代大小占整个堆大小百分比达到该阀值时触发。</p><p>它的GC步骤分2步：</p><ol><li>全局并发标记（global concurrent marking）</li><li>拷贝存活对象（evacuation）</li></ol><h5 id="3-4-3-1、全局并发标记"><a href="#3-4-3-1、全局并发标记" class="headerlink" title="3.4.3.1、全局并发标记"></a>3.4.3.1、全局并发标记</h5><p>全局并发标记，执行过程分为五个步骤：</p><ul><li>初始标记（initial mark，STW）<ul><li>标记从根节点直接可达的对象，这个阶段会执行一次年轻代GC，会产生全局停顿。</li></ul></li><li>根区域扫描（root region scan）<ul><li>G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。</li><li>该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收。</li></ul></li><li>并发标记（Concurrent Marking）<ul><li>G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断。</li></ul></li><li>重新标记（Remark，STW）<ul><li>该阶段是 STW 回收，因为程序在运行，针对上一次的标记进行修正。</li></ul></li><li>清除垃圾（Cleanup，STW）<ul><li>清点和重置标记状态，该阶段会STW，这个阶段并不会实际上去做垃圾的收集，等待evacuation阶段来回收。</li></ul></li></ul><h5 id="3-4-3-2、拷贝存活对象"><a href="#3-4-3-2、拷贝存活对象" class="headerlink" title="3.4.3.2、拷贝存活对象"></a>3.4.3.2、拷贝存活对象</h5><p>Evacuation阶段是全暂停的。该阶段把一部分Region里的活对象拷贝到另一部分Region中，从而实现垃圾的回收清理。</p><h4 id="3-4-4、G1收集器相关参数"><a href="#3-4-4、G1收集器相关参数" class="headerlink" title="3.4.4、G1收集器相关参数"></a>3.4.4、G1收集器相关参数</h4><ul><li>-XX:+UseG1GC<ul><li>使用 G1 垃圾收集器</li></ul></li><li>-XX:MaxGCPauseMillis<ul><li>设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到），默认值是 200 毫秒。</li></ul></li><li>-XX:G1HeapRegionSize=n<ul><li>设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。</li><li>默认是堆内存的1/2000。</li></ul></li><li>-XX:ParallelGCThreads=n<ul><li>设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。</li></ul></li><li>-XX:ConcGCThreads=n<ul><li>设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右。</li></ul></li><li>-XX:InitiatingHeapOccupancyPercent=n<ul><li>设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。</li></ul></li></ul><h4 id="3-4-5、测试"><a href="#3-4-5、测试" class="headerlink" title="3.4.5、测试"></a>3.4.5、测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC -XX:MaxGCPauseMillis=100 -XX:+PrintGCDetails -Xmx256m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>日志</span><br><span class="line">[GC pause (G1 Evacuation Pause) (young), 0.0044882 secs]</span><br><span class="line">   [Parallel Time: 3.7 ms, GC Workers: 3]</span><br><span class="line">      [GC Worker Start (ms): Min: 14763.7, Avg: 14763.8, Max: 14763.8, Diff: 0.1]</span><br><span class="line">      #扫描根节点</span><br><span class="line">      [Ext Root Scanning (ms): Min: 0.2, Avg: 0.3, Max: 0.3, Diff: 0.1, Sum: 0.8]</span><br><span class="line">      #更新RS区域所消耗的时间</span><br><span class="line">      [Update RS (ms): Min: 1.8, Avg: 1.9, Max: 1.9, Diff: 0.2, Sum: 5.6]</span><br><span class="line">         [Processed Buffers: Min: 1, Avg: 1.7, Max: 3, Diff: 2, Sum: 5]</span><br><span class="line">      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      #对象拷贝</span><br><span class="line">      [Object Copy (ms): Min: 1.1, Avg: 1.2, Max: 1.3, Diff: 0.2, Sum: 3.6]</span><br><span class="line">      [Termination (ms): Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 0.2]</span><br><span class="line">         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 3]</span><br><span class="line">      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      [GC Worker Total (ms): Min: 3.4, Avg: 3.4, Max: 3.5, Diff: 0.1, Sum: 10.3]</span><br><span class="line">      [GC Worker End (ms): Min: 14767.2, Avg: 14767.2, Max: 14767.3, Diff: 0.1]</span><br><span class="line">   [Code Root Fixup: 0.0 ms]</span><br><span class="line">   [Code Root Purge: 0.0 ms]</span><br><span class="line">   [Clear CT: 0.0 ms] #清空CardTable</span><br><span class="line">   [Other: 0.7 ms]</span><br><span class="line">      [Choose CSet: 0.0 ms] #选取CSet</span><br><span class="line">      [Ref Proc: 0.5 ms] #弱引用、软引用的处理耗时</span><br><span class="line">      [Ref Enq: 0.0 ms] #弱引用、软引用的入队耗时</span><br><span class="line">      [Redirty Cards: 0.0 ms]</span><br><span class="line">      [Humongous Register: 0.0 ms] #大对象区域注册耗时</span><br><span class="line">      [Humongous Reclaim: 0.0 ms] #大对象区域回收耗时</span><br><span class="line">      [Free CSet: 0.0 ms]</span><br><span class="line">   [Eden: 7168.0K(7168.0K)-&gt;0.0B(13.0M) Survivors: 2048.0K-&gt;2048.0K Heap: 55.5M(192.0M)-&gt;48.5M(192.0M)] #年轻代的大小统计</span><br><span class="line"> [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure><h4 id="3-4-6、对于G1垃圾收集器优化建议"><a href="#3-4-6、对于G1垃圾收集器优化建议" class="headerlink" title="3.4.6、对于G1垃圾收集器优化建议"></a>3.4.6、对于G1垃圾收集器优化建议</h4><ul><li>年轻代大小<ul><li>避免使用 -Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小。</li><li>固定年轻代的大小会覆盖暂停时间目标。</li></ul></li><li>暂停时间目标不要太过严苛<ul><li>G1 GC 的吞吐量目标是 90% 的应用程序时间和 10%的垃圾回收时间。</li><li>评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示您愿意承受更多的垃圾回收开销，而这会直接影响到吞吐量。</li></ul></li></ul><h2 id="4、可视化GC日志分析工具"><a href="#4、可视化GC日志分析工具" class="headerlink" title="4、可视化GC日志分析工具"></a>4、可视化GC日志分析工具</h2><h3 id="4-1、GC日志输出参数"><a href="#4-1、GC日志输出参数" class="headerlink" title="4.1、GC日志输出参数"></a>4.1、GC日志输出参数</h3><p>前面通过-XX:+PrintGCDetails可以对GC日志进行打印，我们就可以在控制台查看，这样虽然可以查看GC的信息，但是并不直观，可以借助于第三方的GC日志分析工具进行查看。</p><p>在日志打印输出涉及到的参数如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC 输出GC日志</span><br><span class="line">-XX:+PrintGCDetails 输出GC的详细日志</span><br><span class="line">-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）</span><br><span class="line">-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</span><br><span class="line">-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息</span><br><span class="line">-Xloggc:../logs/gc.log 日志文件的输出路径</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC -XX:MaxGCPauseMillis=100 -Xmx256m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:F://test//gc.log</span><br></pre></td></tr></table></figure><p>运行后就可以在E盘下生成gc.log文件。</p><p>如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Java HotSpot(TM) 64-Bit Server VM (25.144-b01) for windows-amd64 JRE (1.8.0_144-b01), built on Jul 21 2017 21:57:33 by "java_re" with MS VC++ 10.0 (VS2010)</span><br><span class="line">Memory: 4k page, physical 12582392k(1939600k free), swap 17300984k(5567740k free)</span><br><span class="line">CommandLine flags: -XX:InitialHeapSize=201318272 -XX:MaxGCPauseMillis=100 -XX:MaxHeapSize=268435456 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC -XX:-UseLargePagesIndividualAllocation </span><br><span class="line">&#123;Heap before GC invocations=0 (full 0):</span><br><span class="line"> garbage-first heap   total 196608K, used 9216K [0x00000000f0000000, 0x00000000f0100600, 0x0000000100000000)</span><br><span class="line">  region size 1024K, 9 young (9216K), 0 survivors (0K)</span><br><span class="line"> Metaspace       used 3491K, capacity 4500K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 381K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">2018-09-24T23:06:02.230+0800: 0.379: [GC pause (G1 Evacuation Pause) (young), 0.0031038 secs]</span><br><span class="line">   [Parallel Time: 2.8 ms, GC Workers: 3]</span><br><span class="line">      [GC Worker Start (ms): Min: 378.6, Avg: 378.8, Max: 379.0, Diff: 0.3]</span><br><span class="line">      [Ext Root Scanning (ms): Min: 0.0, Avg: 0.4, Max: 0.8, Diff: 0.8, Sum: 1.3]</span><br><span class="line">      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]</span><br><span class="line">      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.1]</span><br><span class="line">      [Object Copy (ms): Min: 1.8, Avg: 1.9, Max: 1.9, Diff: 0.1, Sum: 5.6]</span><br><span class="line">      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 3]</span><br><span class="line">      [GC Worker Other (ms): Min: 0.0, Avg: 0.2, Max: 0.6, Diff: 0.6, Sum: 0.6]</span><br><span class="line">      [GC Worker Total (ms): Min: 2.4, Avg: 2.5, Max: 2.7, Diff: 0.3, Sum: 7.6]</span><br><span class="line">      [GC Worker End (ms): Min: 381.4, Avg: 381.4, Max: 381.4, Diff: 0.0]</span><br><span class="line">   [Code Root Fixup: 0.0 ms]</span><br><span class="line">   [Code Root Purge: 0.0 ms]</span><br><span class="line">   [Clear CT: 0.0 ms]</span><br><span class="line">   [Other: 0.2 ms]</span><br><span class="line">      [Choose CSet: 0.0 ms]</span><br><span class="line">      [Ref Proc: 0.1 ms]</span><br><span class="line">      [Ref Enq: 0.0 ms]</span><br><span class="line">      [Redirty Cards: 0.0 ms]</span><br><span class="line">      [Humongous Register: 0.0 ms]</span><br><span class="line">      [Humongous Reclaim: 0.0 ms]</span><br><span class="line">      [Free CSet: 0.0 ms]</span><br><span class="line">   [Eden: 9216.0K(9216.0K)-&gt;0.0B(7168.0K) Survivors: 0.0B-&gt;2048.0K Heap: 9216.0K(192.0M)-&gt;1888.0K(192.0M)]</span><br><span class="line">Heap after GC invocations=1 (full 0):</span><br><span class="line"> garbage-first heap   total 196608K, used 1888K [0x00000000f0000000, 0x00000000f0100600, 0x0000000100000000)</span><br><span class="line">  region size 1024K, 2 young (2048K), 2 survivors (2048K)</span><br><span class="line"> Metaspace       used 3491K, capacity 4500K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 381K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">&#125;</span><br><span class="line"> [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">&#123;Heap before GC invocations=1 (full 0):</span><br><span class="line"> garbage-first heap   total 196608K, used 9056K [0x00000000f0000000, 0x00000000f0100600, 0x0000000100000000)</span><br><span class="line">  region size 1024K, 9 young (9216K), 2 survivors (2048K)</span><br><span class="line"> Metaspace       used 3492K, capacity 4500K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 381K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">2018-09-24T23:06:02.310+0800: 0.458: [GC pause (G1 Evacuation Pause) (young), 0.0070126 secs]</span><br><span class="line">。。。。。。。。。。。。。。。。。。。</span><br></pre></td></tr></table></figure><h3 id="4-2、GC-Easy-可视化工具"><a href="#4-2、GC-Easy-可视化工具" class="headerlink" title="4.2、GC Easy 可视化工具"></a>4.2、GC Easy 可视化工具</h3><p>GC Easy是一款在线的可视化工具，易用、功能强大，网站：</p><p><a href="http://gceasy.io/" target="_blank" rel="noopener">http://gceasy.io/</a></p><p> <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/1537803536253.png" alt="1537803536253"></p><p>上传后，点击“Analyze”按钮，即可查看报告。</p><p> <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/1537804265054.png" alt="1537804265054"></p><p> <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/1537804287484.png" alt="1537804287484"></p><p> <img src="/2019/05/30/GC之垃圾回收算法和垃圾处理器/1537804311560.png" alt="1537804311560"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;GC之常见的垃圾回收算法和垃圾处理器&quot;&gt;&lt;a href=&quot;#GC之常见的垃圾回收算法和垃圾处理器&quot; class=&quot;headerlink&quot; title=&quot;GC之常见的垃圾回收算法和垃圾处理器&quot;&gt;&lt;/a&gt;GC之常见的垃圾回收算法和垃圾处理器&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;了解什么是垃圾回收&lt;/li&gt;
&lt;li&gt;掌握垃圾会回收的常见算法&lt;/li&gt;
&lt;li&gt;学习串行、并行、并发、G1垃圾收集器&lt;/li&gt;
&lt;li&gt;学习GC日志的可视化查看&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="GC" scheme="http://yoursite.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>github骚操作</title>
    <link href="http://yoursite.com/2019/05/29/github%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/05/29/github骚操作/</id>
    <published>2019-05-29T12:27:19.000Z</published>
    <updated>2020-07-27T09:25:36.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="github的骚操作集锦"><a href="#github的骚操作集锦" class="headerlink" title="github的骚操作集锦"></a>github的骚操作集锦</h1><p>你值得拥有！</p><a id="more"></a><h2 id="常用词的含义："><a href="#常用词的含义：" class="headerlink" title="常用词的含义："></a>常用词的含义：</h2><ul><li><strong>watch</strong>：会持续收到该项目的动态</li><li><strong>fork</strong>，复制某个项目到自己的Github仓库中</li><li><strong>star</strong>，可以理解为点赞</li><li><strong>clone</strong>，将项目下载至本地</li><li><strong>follow</strong>，关注你感兴趣的作者，会收到他们的动态</li></ul><h2 id="通过in关键词限制搜索范围"><a href="#通过in关键词限制搜索范围" class="headerlink" title="通过in关键词限制搜索范围"></a>通过in关键词限制搜索范围</h2><ul><li><p><strong>xxx in:name</strong>  项目名包含xxx的</p></li><li><p><strong>xxx in:description</strong> 项目描述包含xxx的</p></li><li><p><strong>xxx in:readme</strong> 项目的readme文件中包含xxx的</p></li></ul><p>当然也可以通过<strong>xxx in:name,desciption</strong>来组合使用</p><p><strong>例如：</strong>ICU in:name,description 表示搜索在项目名和项目描述中包含ICU的项目</p><p><img src="/2019/05/29/github骚操作/1559133241314.png" alt="1559133241314"></p><h2 id="通过-Star-或者Fork数-去查找项目"><a href="#通过-Star-或者Fork数-去查找项目" class="headerlink" title="通过 Star 或者Fork数 去查找项目"></a>通过 Star 或者Fork数 去查找项目</h2><p>通过通配符 &gt; &lt; = 即可，区间范围内可通过 num1..num2</p><ul><li><p>如，要查找stars数不小于666的springboot项目</p><p>springboot  stars:&gt;=666</p></li><li><p>forks 大于等于500</p><p>springboot forks:&gt;500</p></li><li><p>查找fork在100到200之间 且stars数在80到100之间的springboot项目</p><p>springboot forks:100..200 stars:80..1000</p></li></ul><p><img src="/2019/05/29/github骚操作/1559133636440.png" alt="1559133636440"></p><h2 id="awesome-关键字"><a href="#awesome-关键字" class="headerlink" title="awesome + 关键字"></a>awesome + 关键字</h2><p>搜索和关键字匹配的优秀项目！注意，是优秀哦！和 springboot in:name这样搜索出的结果是不同的！</p><p>awesome springboot 搜索优秀的springboot相关的项目，包括框架、教程等来进行学习。</p><p><img src="/2019/05/29/github骚操作/1559133842102.png" alt="1559133842102"></p><p><img src="/2019/05/29/github骚操作/1559133952334.png" alt="1559133952334"></p><p>注意到那个粉色眼镜了吗，那就是Awesome Lists的标识。（我做了一个实验，把awesome放在关键词的后面搜索其实结果是一样的，只是少了这个粉红眼镜）</p><h2 id="分享项目中某一行的代码"><a href="#分享项目中某一行的代码" class="headerlink" title="分享项目中某一行的代码"></a>分享项目中某一行的代码</h2><p>只需要在具体的网址后面拼接#Lxx(xx为行数)，如果是段落的话，就为#Lxx-Lxx，选中的行就会高亮显示</p><p><img src="/2019/05/29/github骚操作/1559134363920.png" alt="1559134363920"></p><p>当然，这个操作直接用鼠标选中也是可以的，效果相同。</p><h2 id="项目内搜索"><a href="#项目内搜索" class="headerlink" title="项目内搜索"></a>项目内搜索</h2><p>打开你想要搜索的项目，然后按一下‘T’键。会跳转至一个新的网页</p><p><img src="/2019/05/29/github骚操作/1559134611540.png" alt="1559134611540"></p><p><img src="/2019/05/29/github骚操作/1559134632942.png" alt="1559134632942"></p><p>类似的页面内快捷键还有很多，常用的还有’L‘, 在文件内跳转到多少行。</p><p>更多快捷键可以查看官方文档</p><p><a href="https://help.github.com/en/articles/using-keyboard-shortcuts" target="_blank" rel="noopener">https://help.github.com/en/articles/using-keyboard-shortcuts</a></p><h2 id="搜索某个地区内的大佬"><a href="#搜索某个地区内的大佬" class="headerlink" title="搜索某个地区内的大佬"></a>搜索某个地区内的大佬</h2><p>可以通过location:地区 进行检索，在具体可以通过language:语言  缩小检索范围</p><p>如搜索地区在北京的Java方向的用户</p><p>location:beijing language:java</p><p><img src="/2019/05/29/github骚操作/1559134739491.png" alt="1559134739491"></p><p>北京的大佬出现了！</p><h2 id="推荐一些Github插件"><a href="#推荐一些Github插件" class="headerlink" title="推荐一些Github插件"></a>推荐一些Github插件</h2><ol><li><p><strong>Octotree</strong>（推荐安装）</p><p>平时浏览github代码时，每个文件都需要点击才能查看，用了这个插件可以将项目的目录结构以树形结构显示，点击之后会自动跳转到相应的目录。墙裂推荐！</p><p><img src="/2019/05/29/github骚操作/1559135254766.png" alt="1559135254766"></p><p>下面晒出图，左侧就是啦！体验极好！</p><p><img src="/2019/05/29/github骚操作/1559135151316.png" alt="1559135151316"></p></li><li><p><strong>OctoLinker</strong>（推荐）</p><p>浏览代码如果可以像ide那样可以链接跳转岂不是美滋滋，这个插件就可以帮助我们完成这些。只需要ctrl+点击变量名即可。</p><p><img src="/2019/05/29/github骚操作/1559135233992.png" alt="1559135233992"></p></li></ol><ol start="3"><li><p><strong><em>Sourcegraph</em></strong>（推荐安装）</p><p>一个可以在github上浏览和搜索代码的工具，安装好插件之后会出现一个view Repository的按钮</p></li></ol><p><img src="/2019/05/29/github骚操作/1559135342901.png" alt="1559135342901"></p><p>下图中标红处就是啦！</p><p><img src="/2019/05/29/github骚操作/1559135541744.png" alt="1559135541744"></p><p>感觉非常好</p><p><img src="/2019/05/29/github骚操作/1559135472336.png" alt="1559135472336"></p><p><img src="/2019/05/29/github骚操作/1559135674798.png" alt="1559135674798"></p><p>这个插件同时带有以上两个插件的功能哦！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;github的骚操作集锦&quot;&gt;&lt;a href=&quot;#github的骚操作集锦&quot; class=&quot;headerlink&quot; title=&quot;github的骚操作集锦&quot;&gt;&lt;/a&gt;github的骚操作集锦&lt;/h1&gt;&lt;p&gt;你值得拥有！&lt;/p&gt;
    
    </summary>
    
      <category term="github" scheme="http://yoursite.com/categories/github/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>GC Roots的对象，以及对java类中的成员变量，局部变量，静态变量和常量的不同回收时机的解析</title>
    <link href="http://yoursite.com/2019/05/06/GC-Roots%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AF%B9java%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%94%B6%E6%97%B6%E6%9C%BA%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/06/GC-Roots的对象，以及对java类中的成员变量，局部变量，静态变量和常量的不同回收时机的解析/</id>
    <published>2019-05-06T03:42:48.000Z</published>
    <updated>2020-07-27T09:25:36.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-作为GC-Roots的对象有以下几种"><a href="#1-作为GC-Roots的对象有以下几种" class="headerlink" title="1.作为GC Roots的对象有以下几种"></a>1.作为GC Roots的对象有以下几种</h2><ol><li>虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中引用的对象。</li><li>方法区中的类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（Native）方法引用的对象。</li></ol><a id="more"></a><h2 id="2-成员变量（实例变量）-amp-局部变量-amp-静态变量（类变量）的区别"><a href="#2-成员变量（实例变量）-amp-局部变量-amp-静态变量（类变量）的区别" class="headerlink" title="2.成员变量（实例变量）&amp;局部变量&amp;静态变量（类变量）的区别"></a>2.成员变量（实例变量）&amp;局部变量&amp;静态变量（类变量）的区别</h2><h3 id="成员变量（实例变量）-amp-局部变量区别："><a href="#成员变量（实例变量）-amp-局部变量区别：" class="headerlink" title="成员变量（实例变量）&amp;局部变量区别："></a>成员变量（实例变量）&amp;局部变量区别：</h3><ol><li>作用域</li></ol><ul><li>成员变量：针对整个类有效。</li><li>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</li></ul><ol start="2"><li>存储位置</li></ol><ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。</li><li>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中（栈帧中的局部变量表）。<br>当方法调用完，或者语句结束后，就自动释放。</li></ul><ol start="3"><li>初始值</li></ol><ul><li>成员变量：有默认初始值。<br>注意：赋值的时候不能把声明和赋值分开<br>举例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x ;</span><br><span class="line">    x = <span class="number">1</span>;  <span class="comment">//这样不行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;  <span class="comment">//这样就可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是 ：成员变量在类的范围内，存在于堆内存中，会有默认的初始值，在声明的同时已经给变量赋值了。再次”赋值“实际是使用了语句，而类体里面只能出现变量和方法,不能出现语句。</p><ul><li>局部变量：没有默认初始值，使用前必须赋值。</li></ul><h3 id="成员变量（实例变量）-amp-静态变量（类变量）区别："><a href="#成员变量（实例变量）-amp-静态变量（类变量）区别：" class="headerlink" title="成员变量（实例变量）&amp;静态变量（类变量）区别："></a>成员变量（实例变量）&amp;静态变量（类变量）区别：</h3><ol><li>调用方式<br>静态变量也称为类变量，可以直接通过类名调用。也可以通过对象名调用。<br>这个变量属于类。<br>成员变量也称为实例变量，只能通过对象名调用。这个变量属于对象。</li><li>存储位置<br>静态变量存储在方法区中。<br>成员变量存储在堆内存。</li><li>生命周期<br>静态变量随着类的加载而存在，随着类的消失而消失。生命周期长。<br>成员变量随着对象的创建而存在，随着对象的消失而消失。</li><li>与对象的相关性<br>静态变量是所有对象共享的数据。<br>成员变量是每个对象所特有的数据。</li></ol><h3 id="关于静态变量和常量的详细解析："><a href="#关于静态变量和常量的详细解析：" class="headerlink" title="关于静态变量和常量的详细解析："></a>关于静态变量和常量的详细解析：</h3><p>参照：<a href="https://blog.csdn.net/qq_29951485/article/details/89789174" target="_blank" rel="noopener">从class文件与JVM加载机制理解final、static、static final</a></p><h2 id="不同的回收机制总结"><a href="#不同的回收机制总结" class="headerlink" title="不同的回收机制总结"></a>不同的回收机制总结</h2><ol><li>变量属于类变量（静态变量），那么永远不会被回收，原因是方法区中的类静态属性引用的对象是GC Roots，不会被回收。</li><li>变量属于实例（成员变量，包括final），则实例被回收才会被顺便回收（和实例一起存在堆中，栈帧中的局部变量区（GC Root）中不再引用，就回收）</li><li>变量属于实例的方法（局部变量），那么他是在栈中临时的（栈帧中的局部变量区（GC Root），GC的区域在堆和方法区，而不在栈），随着方法结束了，栈自动释放了，无需回收。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-作为GC-Roots的对象有以下几种&quot;&gt;&lt;a href=&quot;#1-作为GC-Roots的对象有以下几种&quot; class=&quot;headerlink&quot; title=&quot;1.作为GC Roots的对象有以下几种&quot;&gt;&lt;/a&gt;1.作为GC Roots的对象有以下几种&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中引用的对象。&lt;/li&gt;
&lt;li&gt;方法区中的类静态属性引用的对象。&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象。&lt;/li&gt;
&lt;li&gt;本地方法栈中JNI（Native）方法引用的对象。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>从class文件与JVM加载机制理解final、static、static final</title>
    <link href="http://yoursite.com/2019/05/06/%E4%BB%8Eclass%E6%96%87%E4%BB%B6%E4%B8%8EJVM%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3final%E3%80%81static%E3%80%81static-final/"/>
    <id>http://yoursite.com/2019/05/06/从class文件与JVM加载机制理解final、static、static-final/</id>
    <published>2019-05-06T03:40:31.000Z</published>
    <updated>2020-07-27T09:25:36.686Z</updated>
    
    <content type="html"><![CDATA[<p>编程过程中经常用的static，final关键字，JVM中class类文件结构可以找到答案。</p><p>﻿<a id="more"></a></p><h1 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h1><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值，只有被static修饰的变量才可以使用这项属性。非static类型的变量的赋值是在实例构造器方法中进行的；static类型变量赋值分两种，在类构造器中赋值，或使用ConstantValue属性赋值。</p><p>在实际的程序中，只有同时被final和static修饰的字段才有ConstantValue属性，且限于基本类型和String。编译时Javac将会为该常量生成ConstantValue属性，在类加载的准备阶段虚拟机便会根据ConstantValue为常量设置相应的值，如果该变量没有被final修饰，或者并非基本类型及字符串，则选择在类构造器中进行初始化。</p><h1 id="1-为什么ConstantValue的属性值只限于基本类型和String？"><a href="#1-为什么ConstantValue的属性值只限于基本类型和String？" class="headerlink" title="1.为什么ConstantValue的属性值只限于基本类型和String？"></a>1.为什么ConstantValue的属性值只限于基本类型和String？</h1><p>因为从常量池中只能引用到基本类型和String类型的字面量</p><h1 id="2-final、static、static-final修饰的字段赋值的区别？"><a href="#2-final、static、static-final修饰的字段赋值的区别？" class="headerlink" title="2.final、static、static final修饰的字段赋值的区别？"></a>2.final、static、static final修饰的字段赋值的区别？</h1><ul><li>static修饰的字段在加载过程中准备阶段被初始化，但是这个阶段只会赋值一个默认的值（0或者null而并非定义变量设置的值）初始化阶段在类构造器中才会赋值为变量定义的值。（关于static的初始化请看<a href="https://blog.csdn.net/qq_29951485/article/details/89789436" target="_blank" rel="noopener">“init”与”clinit”的区别</a>）</li><li>final修饰的字段在运行时被初始化，可以直接赋值，也可以在实例构造器中赋值，赋值后不可修改。<br>final关键字对于变量的存储区域是没有任何影响的。jvm规范中，类的静态变量存储在方法区，实例变量存储在堆区。也就是说static关键字才对变量的存储区域造成影响。<br>final关键字来修饰变量表明了该变量一旦赋值就无法更改。同时编译器必须保证该变量在使用前被初始化赋值。<br>例如你的static final int c1这个变量，是一个静态变量，静态变量的初始化可以在静态块中进行。而非static变量，可以初始化块中和构造方法中进行。<br>如果你在这几个地方没有对final变量进行赋值，编译器便会报错。</li><li>static final修饰的字段在javac编译时生成comstantValue属性，在类加载的准备阶段直接把constantValue的值赋给该字段。<br>可以理解为在编译期即把结果放入了常量池中。</li></ul><p>在一个类中定义字段时，可以声明为成员变量（如final），也可以声明为类变量（静态变量），静态变量在装载类时被初始化，而成员变量每次创建实例时都会被初始化一次。一个字段被声明为static final，表示这个字段在初始化完成后就不可再改变了，final，类的初始化完成后，在类的实例化进行赋值，每次实例化的值不一定相同。加上了static 的 final，在类只装载一次的情况下，可以是真正意义的“常量”<br>例如： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> random = <span class="keyword">new</span> Random().nestInt();<span class="comment">//每次发生类装载时都会赋值一次，且赋的值都不一样 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> random = <span class="keyword">new</span> Random().nestInt();<span class="comment">//每次生成这个类的实例时都会赋值一次，且赋的值都不一样</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编程过程中经常用的static，final关键字，JVM中class类文件结构可以找到答案。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>“init”与“clinit”的区别</title>
    <link href="http://yoursite.com/2019/05/06/init-%E4%B8%8E-clinit-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/05/06/init-与-clinit-的区别/</id>
    <published>2019-05-06T03:38:13.000Z</published>
    <updated>2020-07-27T09:25:36.685Z</updated>
    
    <content type="html"><![CDATA[<p>关于类加载时的&lt;clinit>与类实例化时的&lt;init></p><a id="more"></a><p>﻿<strong>在编译生成class文件时，会自动产生两个方法，一个是类的初始化方法&lt;clinit>, 另一个是实例的初始化方法&lt;init></strong><br><strong>注意:</strong></p><p>&lt;clinit>:如果没有静态块，静态变量则没有&lt;clinit></p><p>&lt;init>:类的实例构造器。</p><p><strong>关于二者的详细对照：</strong></p><p>&lt;clinit>：在JVM第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行</p><p>&lt;init>:在实例创建出来的时候调用，包括调用new操作符；调用Class或Java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。</p><p><strong>初始化过程：</strong><br>   初始化就是执行&lt;clinit>()方法的过程。<br>   &lt;clinit>如果没有静态块，静态变量则没有&lt;clinit><br>   &lt;init>类的实例构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(“”);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> n;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&lt;clinit>静态变量，静态块的初始化</p><p>&lt;init>类的初始化</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于类加载时的&amp;lt;clinit&gt;与类实例化时的&amp;lt;init&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之Class文件分析详解</title>
    <link href="http://yoursite.com/2019/05/03/JVM%E4%B9%8BClass%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/05/03/JVM之Class文件分析详解/</id>
    <published>2019-05-03T02:23:05.000Z</published>
    <updated>2020-07-27T09:25:36.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM之Class文件分析详解"><a href="#JVM之Class文件分析详解" class="headerlink" title="JVM之Class文件分析详解"></a>JVM之Class文件分析详解</h1><p>逐个字节分析Class文件。了解Class文件内部结构。</p><a id="more"></a><h2 id="原始类文件："><a href="#原始类文件：" class="headerlink" title="原始类文件："></a>原始类文件：</h2><p>这个类直接拿了知乎的一个类，分析是很简单，只是因为重新画图比较麻烦，不想再做重复的苦力工作（地址（<a href="https://zhuanlan.zhihu.com/p/23068093" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23068093</a>）ps:作者仅仅提供了类和图，并无解析。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vonzhou.learn.jvm.klass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Class结构体"><a href="#Class结构体" class="headerlink" title="Class结构体"></a>Class结构体</h2><p>一个Class文件可以用如下的结构体抽象：</p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556850581334.png" alt="1556850581334"></p><h2 id="Step-by-Step"><a href="#Step-by-Step" class="headerlink" title="Step by Step"></a>Step by Step</h2><p>接下来就是对照着字节码和JVM规范阅读的过程，对自己多点耐心。</p><h2 id="Class魔数和版本"><a href="#Class魔数和版本" class="headerlink" title="Class魔数和版本"></a>Class魔数和版本</h2><p><img src="/2019/05/03/JVM之Class文件分析详解/1556854654580.png" alt="1556854654580"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556850710537.png" alt="1556850710537"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-7004f635a3dfe58e09c34255e1301a8c_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-c0fca38bb091cf31584e2dbc566af91c_hd.png" alt="img"></p><h2 id="常量池计数器和常量池"><a href="#常量池计数器和常量池" class="headerlink" title="常量池计数器和常量池"></a>常量池计数器和常量池</h2><p><img src="/2019/05/03/JVM之Class文件分析详解/1556854680622.png" alt="1556854680622"></p><p>注意：常量池内常量的真实数量是 <strong>常量池计数器-1</strong></p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556850772017.png" alt="1556850772017"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556850796593.png" alt="1556850796593"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556850817023.png" alt="1556850817023"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556850841470.png" alt="1556850841470"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-3f6de6a32f549ce140e2dd8e2f0c1d4f_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-7023a1a49700fb01fc9170c212f096a5_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-273aefe0b471699d507dfc78f461a760_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-3eafa2c1b9a17fdbeac12e6e5306b76b_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-0e4461d293618d72314b3192f92af43b_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-f33f7047cb45ad27b819a69da1987f6c_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-402cfe29a8a8789b0d9cc97a64f99456_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-8833dbb80c6284862639bf0206fa8520_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-3fda893e00ce14542dd423d9e56ec806_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-158301240030a621dfb7a3402aa923b5_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-76a1f0964274782e463af12e4e19e836_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-23bfc052689d08f96b99097728d80edc_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-432e7e84c496d198d89ff0feb303774d_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-7214aea5388018ecbfc7f30429a8a8d3_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-f1dd91912fa2db4556b84dbf3c08c3b4_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-9ee7848742359816c7db32bfddf7cc1b_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-479810c38acbcacdbd41aafe76e95dd6_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-71fb60cc16b11aa56b8f8a2812e2a306_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-7f932293687c4a35b3bb3eec96b8aea6_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-bde457c59a68325ee6481907cf1ab691_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-cc589a78f50b5be81968c0ae679a38e7_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-2575d66217e2151a81ab0e9e9aa5f6bc_hd.png" alt="img"></p><p>那么接下来就是这三个了：</p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556854982133.png" alt="1556854982133"></p><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p><img src="/2019/05/03/JVM之Class文件分析详解/1556855229233.png" alt="1556855229233"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556851149393.png" alt="1556851149393"></p><p>这里</p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-7250cc900eb3f99ae50f90bf1619323d_hd.png" alt="img"></p><p>为什么是0021呢？因为 0X0001|0X0020 = 0X0021。</p><h2 id="类索引，父类索引"><a href="#类索引，父类索引" class="headerlink" title="类索引，父类索引"></a>类索引，父类索引</h2><p><img src="/2019/05/03/JVM之Class文件分析详解/1556855257629.png" alt="1556855257629"></p><p>接下来的2B是this_class指向我们的类名, super_class指示父类。</p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-3d90c3459cbaa9a5feff3bb11dcac978_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-1c8aa41897b6b1cd7733b559c77f32df_hd.png" alt="img"></p><p>这里没有实现接口：</p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-b8f10379d2128f8a69d711d2bfafd657_hd.png" alt="img"></p><h2 id="字段计数器和字段表集合"><a href="#字段计数器和字段表集合" class="headerlink" title="字段计数器和字段表集合"></a>字段计数器和字段表集合</h2><p>fields_count以后进入字段表集合</p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556851584435.png" alt="1556851584435"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556851428143.png" alt="1556851428143"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556851512040.png" alt="1556851512040"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-afea0165862f6a4c51aed9fa016bae1f_hd.png" alt="img"></p><h2 id="方法计数器和方发表集合"><a href="#方法计数器和方发表集合" class="headerlink" title="方法计数器和方发表集合"></a>方法计数器和方发表集合</h2><p>首先进入方法计数器。</p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556852236787.png" alt="1556852236787"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-b85e30d920d004ab98913cd6c4dd54d9_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556852171723.png" alt="1556852171723"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556851428143.png" alt="1556851428143"></p><p>从上可以看出，关键的不同点在于attribute_info字段。这是属性表集合，下面附上属性表集合的一般结构。</p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556852397696.png" alt="1556852397696"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556852498092.png" alt="1556852498092"></p><p>从上面两个图可以看出属性表前两个字段时固定的，关键在于第三个字段各有不同，比如方法表的属性表Code的完整格式为下图</p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556853118948.png" alt="1556853118948"></p><p>接下来就对Code属性表进行梳理：</p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-8d1ce8a3d1440bcb3c912f1b3038a093_hd.png" alt="img"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/v2-52ef25448b901a93df2ed422e72213e3_hd.png" alt="img"></p><h2 id="属性计数器和属性表集合"><a href="#属性计数器和属性表集合" class="headerlink" title="属性计数器和属性表集合"></a>属性计数器和属性表集合</h2><p><img src="/2019/05/03/JVM之Class文件分析详解/1556856126125.png" alt="1556856126125"></p><p> 属性表集合中的SourceFile：<img src="/2019/05/03/JVM之Class文件分析详解/1556854138367.png" alt="1556854138367"></p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556854215807.png" alt="1556854215807"></p><p>由属性计数器后的0010计算十进制数为</p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556855978446.png" alt="1556855978446"></p><p>下面的DEC为16，所以找到第16个常量为<img src="/2019/05/03/JVM之Class文件分析详解/1556856030704.png" alt="1556856030704"></p><p>没错了，是SourceFile</p><p>​    <img src="/2019/05/03/JVM之Class文件分析详解/v2-0a7393e15bb2feb49ac78b8ea27cd4d7_hd.png" alt="img"></p><h2 id="附上javap-version-验证解析结果"><a href="#附上javap-version-验证解析结果" class="headerlink" title="附上javap -version 验证解析结果"></a>附上javap -version 验证解析结果</h2><p>使用javap解析出来的结果中没有包含LocalVariableTable字段，需要在使用javac编译java中时，加上-g的参数，生成的class文件中才带有LocalVariableTable的信息。<strong>LocalVariableTable属性</strong>：用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系，非运行时必需属性，默认不会生成至Class文件中，可以使用Javac的-g:none或-g:vars关闭或要求生成该项属性信息。</p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556860378700.png" alt="1556860378700"></p><p>另外：<strong>LineNumberTale属性</strong>：用于描述Java源码的行号与字节码行号之间的对应关系，非运行时必需属性，会默认生成至Class文件中，可以使用Javac的-g:none或-g:lines关闭或要求生成该项属性信息。</p><p><img src="/2019/05/03/JVM之Class文件分析详解/1556860512094.png" alt="1556860512094"></p><p>具体编译过程：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -g -d . Foo.java</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v com.vonzhou.learn.jvm.klass.Foo</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca fe ba be <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">34</span> <span class="number">20</span> <span class="number">16</span> <span class="number">0</span>a <span class="number">20</span> <span class="number">04</span> <span class="number">20</span> <span class="number">12</span> <span class="number">09</span> <span class="number">20</span> <span class="number">03</span> <span class="number">20</span> <span class="number">13</span> <span class="number">07</span> <span class="number">20</span> <span class="number">14</span> <span class="number">07</span> <span class="number">20</span> <span class="number">15</span> <span class="number">01</span> <span class="number">20</span> <span class="number">01</span> <span class="number">6</span>d <span class="number">01</span> <span class="number">20</span> <span class="number">01</span> <span class="number">49</span> <span class="number">01</span> <span class="number">20</span> <span class="number">06</span> <span class="number">3</span>c <span class="number">69</span> <span class="number">6</span>e <span class="number">69</span> <span class="number">74</span> <span class="number">3</span>e <span class="number">01</span> <span class="number">20</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> <span class="number">56</span> <span class="number">01</span> <span class="number">20</span> <span class="number">04</span> <span class="number">43</span> <span class="number">6f</span> <span class="number">64</span> <span class="number">65</span> <span class="number">01</span> <span class="number">20</span> <span class="number">0f</span> <span class="number">4</span>c <span class="number">69</span> <span class="number">6</span>e <span class="number">65</span> <span class="number">4</span>e <span class="number">75</span> <span class="number">6</span>d <span class="number">62</span> <span class="number">65</span> <span class="number">72</span> <span class="number">54</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">01</span> <span class="number">20</span> <span class="number">12</span> <span class="number">4</span>c <span class="number">6f</span> <span class="number">63</span> <span class="number">61</span> <span class="number">6</span>c <span class="number">56</span> <span class="number">61</span> <span class="number">72</span> <span class="number">69</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">54</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">01</span> <span class="number">20</span> <span class="number">04</span> <span class="number">74</span> <span class="number">68</span> <span class="number">69</span> <span class="number">73</span> <span class="number">01</span> <span class="number">20</span> <span class="number">21</span> <span class="number">4</span>c <span class="number">63</span> <span class="number">6f</span> <span class="number">6</span>d <span class="number">2f</span> <span class="number">76</span> <span class="number">6f</span> <span class="number">6</span>e <span class="number">7</span>a <span class="number">68</span> <span class="number">6f</span> <span class="number">75</span> <span class="number">2f</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">61</span> <span class="number">72</span> <span class="number">6</span>e <span class="number">2f</span> <span class="number">6</span>a <span class="number">76</span> <span class="number">6</span>d <span class="number">2f</span> <span class="number">6</span>b <span class="number">6</span>c <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> <span class="number">2f</span> <span class="number">46</span> <span class="number">6f</span> <span class="number">6f</span> <span class="number">3</span>b <span class="number">01</span> <span class="number">20</span> <span class="number">03</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">63</span> <span class="number">01</span> <span class="number">20</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> <span class="number">49</span> <span class="number">01</span> <span class="number">20</span> <span class="number">0</span>a <span class="number">53</span> <span class="number">6f</span> <span class="number">75</span> <span class="number">72</span> <span class="number">63</span> <span class="number">65</span> <span class="number">46</span> <span class="number">69</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">01</span> <span class="number">20</span> <span class="number">08</span> <span class="number">46</span> <span class="number">6f</span> <span class="number">6f</span> <span class="number">2</span>e <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">0</span>c <span class="number">20</span> <span class="number">07</span> <span class="number">20</span> <span class="number">08</span> <span class="number">0</span>c <span class="number">20</span> <span class="number">05</span> <span class="number">20</span> <span class="number">06</span> <span class="number">01</span> <span class="number">20</span> <span class="number">1f</span> <span class="number">63</span> <span class="number">6f</span> <span class="number">6</span>d <span class="number">2f</span> <span class="number">76</span> <span class="number">6f</span> <span class="number">6</span>e <span class="number">7</span>a <span class="number">68</span> <span class="number">6f</span> <span class="number">75</span> <span class="number">2f</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">61</span> <span class="number">72</span> <span class="number">6</span>e <span class="number">2f</span> <span class="number">6</span>a <span class="number">76</span> <span class="number">6</span>d <span class="number">2f</span> <span class="number">6</span>b <span class="number">6</span>c <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> <span class="number">2f</span> <span class="number">46</span> <span class="number">6f</span> <span class="number">6f</span> <span class="number">01</span> <span class="number">20</span> <span class="number">10</span> <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">2f</span> <span class="number">6</span>c <span class="number">61</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">2f</span> <span class="number">4f</span> <span class="number">62</span> <span class="number">6</span>a <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> <span class="number">20</span> <span class="number">21</span> <span class="number">20</span> <span class="number">03</span> <span class="number">20</span> <span class="number">04</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">02</span> <span class="number">20</span> <span class="number">05</span> <span class="number">20</span> <span class="number">06</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">02</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">07</span> <span class="number">20</span> <span class="number">08</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">09</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">2f</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">05</span> <span class="number">2</span>a b7 <span class="number">20</span> <span class="number">01</span> b1 <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">02</span> <span class="number">20</span> <span class="number">0</span>a <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">06</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">03</span> <span class="number">20</span> <span class="number">0</span>b <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">0</span>c <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">05</span> <span class="number">20</span> <span class="number">0</span>c <span class="number">20</span> <span class="number">0</span>d <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">0</span>e <span class="number">20</span> <span class="number">0f</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">09</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">31</span> <span class="number">20</span> <span class="number">02</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">07</span> <span class="number">2</span>a b4 <span class="number">20</span> <span class="number">02</span> <span class="number">04</span> <span class="number">60</span> ac <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">02</span> <span class="number">20</span> <span class="number">0</span>a <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">06</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">07</span> <span class="number">20</span> <span class="number">0</span>b <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">0</span>c <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">07</span> <span class="number">20</span> <span class="number">0</span>c <span class="number">20</span> <span class="number">0</span>d <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">10</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">02</span> <span class="number">20</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">JVM</span>&gt;<span class="title">javap</span> -<span class="title">v</span> <span class="title">com.vonzhou.learn.jvm.klass.Foo</span></span></span><br><span class="line"><span class="function"><span class="title">Classfile</span> /<span class="title">E</span>:/<span class="title">JVM</span>/<span class="title">com</span>/<span class="title">vonzhou</span>/<span class="title">learn</span>/<span class="title">jvm</span>/<span class="title">klass</span>/<span class="title">Foo.class</span></span></span><br><span class="line"><span class="function">  <span class="title">Last</span> <span class="title">modified</span> 2019-5-3; <span class="title">size</span> 391 <span class="title">bytes</span></span></span><br><span class="line"><span class="function">  <span class="title">MD5</span> <span class="title">checksum</span> 4<span class="title">d9e593620f49a9114d834ec5d923986</span></span></span><br><span class="line"><span class="function">  <span class="title">Compiled</span> <span class="title">from</span> "<span class="title">Foo.java</span>"</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">class</span> <span class="title">com.vonzhou.learn.jvm.klass.Foo</span></span></span><br><span class="line"><span class="function">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="function">  <span class="title">major</span> <span class="title">version</span>: 52</span></span><br><span class="line"><span class="function">  <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="function"><span class="title">Constant</span> <span class="title">pool</span>:</span></span><br><span class="line"><span class="function">   #1 = <span class="title">Methodref</span>          #4.#18         // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span>."&lt;<span class="title">init</span>&gt;":()<span class="title">V</span></span></span><br><span class="line"><span class="function">   #2 = <span class="title">Fieldref</span>           #3.#19         // <span class="title">com</span>/<span class="title">vonzhou</span>/<span class="title">learn</span>/<span class="title">jvm</span>/<span class="title">klass</span>/<span class="title">Foo.m:I</span></span></span><br><span class="line"><span class="function">   #3 = <span class="title">Class</span>              #20            // <span class="title">com</span>/<span class="title">vonzhou</span>/<span class="title">learn</span>/<span class="title">jvm</span>/<span class="title">klass</span>/<span class="title">Foo</span></span></span><br><span class="line"><span class="function">   #4 = <span class="title">Class</span>              #21            // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span></span></span><br><span class="line"><span class="function">   #5 = <span class="title">Utf8</span>               <span class="title">m</span></span></span><br><span class="line"><span class="function">   #6 = <span class="title">Utf8</span>               <span class="title">I</span></span></span><br><span class="line"><span class="function">   #7 = <span class="title">Utf8</span>               &lt;<span class="title">init</span>&gt;</span></span><br><span class="line"><span class="function">   #8 = <span class="title">Utf8</span>               ()<span class="title">V</span></span></span><br><span class="line"><span class="function">   #9 = <span class="title">Utf8</span>               <span class="title">Code</span></span></span><br><span class="line"><span class="function">  #10 = <span class="title">Utf8</span>               <span class="title">LineNumberTable</span></span></span><br><span class="line"><span class="function">  #11 = <span class="title">Utf8</span>               <span class="title">LocalVariableTable</span></span></span><br><span class="line"><span class="function">  #12 = <span class="title">Utf8</span>               <span class="title">this</span></span></span><br><span class="line"><span class="function">  #13 = <span class="title">Utf8</span>               <span class="title">Lcom</span>/<span class="title">vonzhou</span>/<span class="title">learn</span>/<span class="title">jvm</span>/<span class="title">klass</span>/<span class="title">Foo</span>;</span></span><br><span class="line"><span class="function">  #14 = <span class="title">Utf8</span>               <span class="title">inc</span></span></span><br><span class="line"><span class="function">  #15 = <span class="title">Utf8</span>               ()<span class="title">I</span></span></span><br><span class="line"><span class="function">  #16 = <span class="title">Utf8</span>               <span class="title">SourceFile</span></span></span><br><span class="line"><span class="function">  #17 = <span class="title">Utf8</span>               <span class="title">Foo.java</span></span></span><br><span class="line"><span class="function">  #18 = <span class="title">NameAndType</span>        #7:#8          // "&lt;<span class="title">init</span>&gt;":()<span class="title">V</span></span></span><br><span class="line"><span class="function">  #19 = <span class="title">NameAndType</span>        #5:#6          // <span class="title">m:I</span></span></span><br><span class="line"><span class="function">  #20 = <span class="title">Utf8</span>               <span class="title">com</span>/<span class="title">vonzhou</span>/<span class="title">learn</span>/<span class="title">jvm</span>/<span class="title">klass</span>/<span class="title">Foo</span></span></span><br><span class="line"><span class="function">  #21 = <span class="title">Utf8</span>               <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span></span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line"><span class="function">  <span class="title">public</span> <span class="title">com.vonzhou.learn.jvm.klass.Foo</span>();</span></span><br><span class="line"><span class="function">    <span class="title">descriptor</span>: ()<span class="title">V</span></span></span><br><span class="line"><span class="function">    <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span></span></span><br><span class="line"><span class="function">    <span class="title">Code</span>:</span></span><br><span class="line"><span class="function">      <span class="title">stack</span>=1, <span class="title">locals</span>=1, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">         0: <span class="title">aload_0</span></span></span><br><span class="line"><span class="function">         1: <span class="title">invokespecial</span> #1                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span>."&lt;<span class="title">init</span>&gt;":()<span class="title">V</span></span></span><br><span class="line"><span class="function">         4: <span class="title">return</span></span></span><br><span class="line"><span class="function">      <span class="title">LineNumberTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 3: 0</span></span><br><span class="line"><span class="function">      <span class="title">LocalVariableTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">Start</span>  <span class="title">Length</span>  <span class="title">Slot</span>  <span class="title">Name</span>   <span class="title">Signature</span></span></span><br><span class="line"><span class="function">            0       5     0  <span class="title">this</span>   <span class="title">Lcom</span>/<span class="title">vonzhou</span>/<span class="title">learn</span>/<span class="title">jvm</span>/<span class="title">klass</span>/<span class="title">Foo</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">public</span> <span class="title">int</span> <span class="title">inc</span>();</span></span><br><span class="line"><span class="function">    <span class="title">descriptor</span>: ()<span class="title">I</span></span></span><br><span class="line"><span class="function">    <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span></span></span><br><span class="line"><span class="function">    <span class="title">Code</span>:</span></span><br><span class="line"><span class="function">      <span class="title">stack</span>=2, <span class="title">locals</span>=1, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">         0: <span class="title">aload_0</span></span></span><br><span class="line"><span class="function">         1: <span class="title">getfield</span>      #2                  // <span class="title">Field</span> <span class="title">m:I</span></span></span><br><span class="line"><span class="function">         4: <span class="title">iconst_1</span></span></span><br><span class="line"><span class="function">         5: <span class="title">iadd</span></span></span><br><span class="line"><span class="function">         6: <span class="title">ireturn</span></span></span><br><span class="line"><span class="function">      <span class="title">LineNumberTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 7: 0</span></span><br><span class="line"><span class="function">      <span class="title">LocalVariableTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">Start</span>  <span class="title">Length</span>  <span class="title">Slot</span>  <span class="title">Name</span>   <span class="title">Signature</span></span></span><br><span class="line"><span class="function">            0       7     0  <span class="title">this</span>   <span class="title">Lcom</span>/<span class="title">vonzhou</span>/<span class="title">learn</span>/<span class="title">jvm</span>/<span class="title">klass</span>/<span class="title">Foo</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">SourceFile</span>: "<span class="title">Foo.java</span>"</span></span><br></pre></td></tr></table></figure><p>再次附上没有 -g 的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca fe ba be <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">34</span> <span class="number">20</span> <span class="number">13</span> <span class="number">0</span>a <span class="number">20</span> <span class="number">04</span> <span class="number">20</span> <span class="number">0f</span> <span class="number">09</span> <span class="number">20</span> <span class="number">03</span> <span class="number">20</span> <span class="number">10</span> <span class="number">07</span> <span class="number">20</span> <span class="number">11</span> <span class="number">07</span> <span class="number">20</span> <span class="number">12</span> <span class="number">01</span> <span class="number">20</span> <span class="number">01</span> <span class="number">6</span>d <span class="number">01</span> <span class="number">20</span> <span class="number">01</span> <span class="number">49</span> <span class="number">01</span> <span class="number">20</span> <span class="number">06</span> <span class="number">3</span>c <span class="number">69</span> <span class="number">6</span>e <span class="number">69</span> <span class="number">74</span> <span class="number">3</span>e <span class="number">01</span> <span class="number">20</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> <span class="number">56</span> <span class="number">01</span> <span class="number">20</span> <span class="number">04</span> <span class="number">43</span> <span class="number">6f</span> <span class="number">64</span> <span class="number">65</span> <span class="number">01</span> <span class="number">20</span> <span class="number">0f</span> <span class="number">4</span>c <span class="number">69</span> <span class="number">6</span>e <span class="number">65</span> <span class="number">4</span>e <span class="number">75</span> <span class="number">6</span>d <span class="number">62</span> <span class="number">65</span> <span class="number">72</span> <span class="number">54</span> <span class="number">61</span> <span class="number">62</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">01</span> <span class="number">20</span> <span class="number">03</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">63</span> <span class="number">01</span> <span class="number">20</span> <span class="number">03</span> <span class="number">28</span> <span class="number">29</span> <span class="number">49</span> <span class="number">01</span> <span class="number">20</span> <span class="number">0</span>a <span class="number">53</span> <span class="number">6f</span> <span class="number">75</span> <span class="number">72</span> <span class="number">63</span> <span class="number">65</span> <span class="number">46</span> <span class="number">69</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">01</span> <span class="number">20</span> <span class="number">08</span> <span class="number">46</span> <span class="number">6f</span> <span class="number">6f</span> <span class="number">2</span>e <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">0</span>c <span class="number">20</span> <span class="number">07</span> <span class="number">20</span> <span class="number">08</span> <span class="number">0</span>c <span class="number">20</span> <span class="number">05</span> <span class="number">20</span> <span class="number">06</span> <span class="number">01</span> <span class="number">20</span> <span class="number">1f</span> <span class="number">63</span> <span class="number">6f</span> <span class="number">6</span>d <span class="number">2f</span> <span class="number">76</span> <span class="number">6f</span> <span class="number">6</span>e <span class="number">7</span>a <span class="number">68</span> <span class="number">6f</span> <span class="number">75</span> <span class="number">2f</span> <span class="number">6</span>c <span class="number">65</span> <span class="number">61</span> <span class="number">72</span> <span class="number">6</span>e <span class="number">2f</span> <span class="number">6</span>a <span class="number">76</span> <span class="number">6</span>d <span class="number">2f</span> <span class="number">6</span>b <span class="number">6</span>c <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> <span class="number">2f</span> <span class="number">46</span> <span class="number">6f</span> <span class="number">6f</span> <span class="number">01</span> <span class="number">20</span> <span class="number">10</span> <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span> <span class="number">2f</span> <span class="number">6</span>c <span class="number">61</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">2f</span> <span class="number">4f</span> <span class="number">62</span> <span class="number">6</span>a <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> <span class="number">20</span> <span class="number">21</span> <span class="number">20</span> <span class="number">03</span> <span class="number">20</span> <span class="number">04</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">02</span> <span class="number">20</span> <span class="number">05</span> <span class="number">20</span> <span class="number">06</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">02</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">07</span> <span class="number">20</span> <span class="number">08</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">09</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">1</span>d <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">05</span> <span class="number">2</span>a b7 <span class="number">20</span> <span class="number">01</span> b1 <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">0</span>a <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">06</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">03</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">0</span>b <span class="number">20</span> <span class="number">0</span>c <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">09</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">1f</span> <span class="number">20</span> <span class="number">02</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">07</span> <span class="number">2</span>a b4 <span class="number">20</span> <span class="number">02</span> <span class="number">04</span> <span class="number">60</span> ac <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">0</span>a <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">06</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">07</span> <span class="number">20</span> <span class="number">01</span> <span class="number">20</span> <span class="number">0</span>d <span class="number">20</span> <span class="number">20</span> <span class="number">20</span> <span class="number">02</span> <span class="number">20</span> <span class="number">0</span>e</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">JVM</span>&gt;<span class="title">javac</span>  -<span class="title">d</span> . <span class="title">Foo.java</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">E</span>:\<span class="title">JVM</span>&gt;<span class="title">javap</span> -<span class="title">v</span> <span class="title">com.vonzhou.learn.jvm.klass.Foo</span></span></span><br><span class="line"><span class="function"><span class="title">Classfile</span> /<span class="title">E</span>:/<span class="title">JVM</span>/<span class="title">com</span>/<span class="title">vonzhou</span>/<span class="title">learn</span>/<span class="title">jvm</span>/<span class="title">klass</span>/<span class="title">Foo.class</span></span></span><br><span class="line"><span class="function">  <span class="title">Last</span> <span class="title">modified</span> 2019-5-3; <span class="title">size</span> 291 <span class="title">bytes</span></span></span><br><span class="line"><span class="function">  <span class="title">MD5</span> <span class="title">checksum</span> 45262<span class="title">c23d72e75c78347d2f05b918bee</span></span></span><br><span class="line"><span class="function">  <span class="title">Compiled</span> <span class="title">from</span> "<span class="title">Foo.java</span>"</span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">class</span> <span class="title">com.vonzhou.learn.jvm.klass.Foo</span></span></span><br><span class="line"><span class="function">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="function">  <span class="title">major</span> <span class="title">version</span>: 52</span></span><br><span class="line"><span class="function">  <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="function"><span class="title">Constant</span> <span class="title">pool</span>:</span></span><br><span class="line"><span class="function">   #1 = <span class="title">Methodref</span>          #4.#15         // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span>."&lt;<span class="title">init</span>&gt;":()<span class="title">V</span></span></span><br><span class="line"><span class="function">   #2 = <span class="title">Fieldref</span>           #3.#16         // <span class="title">com</span>/<span class="title">vonzhou</span>/<span class="title">learn</span>/<span class="title">jvm</span>/<span class="title">klass</span>/<span class="title">Foo.m:I</span></span></span><br><span class="line"><span class="function">   #3 = <span class="title">Class</span>              #17            // <span class="title">com</span>/<span class="title">vonzhou</span>/<span class="title">learn</span>/<span class="title">jvm</span>/<span class="title">klass</span>/<span class="title">Foo</span></span></span><br><span class="line"><span class="function">   #4 = <span class="title">Class</span>              #18            // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span></span></span><br><span class="line"><span class="function">   #5 = <span class="title">Utf8</span>               <span class="title">m</span></span></span><br><span class="line"><span class="function">   #6 = <span class="title">Utf8</span>               <span class="title">I</span></span></span><br><span class="line"><span class="function">   #7 = <span class="title">Utf8</span>               &lt;<span class="title">init</span>&gt;</span></span><br><span class="line"><span class="function">   #8 = <span class="title">Utf8</span>               ()<span class="title">V</span></span></span><br><span class="line"><span class="function">   #9 = <span class="title">Utf8</span>               <span class="title">Code</span></span></span><br><span class="line"><span class="function">  #10 = <span class="title">Utf8</span>               <span class="title">LineNumberTable</span></span></span><br><span class="line"><span class="function">  #11 = <span class="title">Utf8</span>               <span class="title">inc</span></span></span><br><span class="line"><span class="function">  #12 = <span class="title">Utf8</span>               ()<span class="title">I</span></span></span><br><span class="line"><span class="function">  #13 = <span class="title">Utf8</span>               <span class="title">SourceFile</span></span></span><br><span class="line"><span class="function">  #14 = <span class="title">Utf8</span>               <span class="title">Foo.java</span></span></span><br><span class="line"><span class="function">  #15 = <span class="title">NameAndType</span>        #7:#8          // "&lt;<span class="title">init</span>&gt;":()<span class="title">V</span></span></span><br><span class="line"><span class="function">  #16 = <span class="title">NameAndType</span>        #5:#6          // <span class="title">m:I</span></span></span><br><span class="line"><span class="function">  #17 = <span class="title">Utf8</span>               <span class="title">com</span>/<span class="title">vonzhou</span>/<span class="title">learn</span>/<span class="title">jvm</span>/<span class="title">klass</span>/<span class="title">Foo</span></span></span><br><span class="line"><span class="function">  #18 = <span class="title">Utf8</span>               <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span></span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line"><span class="function">  <span class="title">public</span> <span class="title">com.vonzhou.learn.jvm.klass.Foo</span>();</span></span><br><span class="line"><span class="function">    <span class="title">descriptor</span>: ()<span class="title">V</span></span></span><br><span class="line"><span class="function">    <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span></span></span><br><span class="line"><span class="function">    <span class="title">Code</span>:</span></span><br><span class="line"><span class="function">      <span class="title">stack</span>=1, <span class="title">locals</span>=1, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">         0: <span class="title">aload_0</span></span></span><br><span class="line"><span class="function">         1: <span class="title">invokespecial</span> #1                  // <span class="title">Method</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span>."&lt;<span class="title">init</span>&gt;":()<span class="title">V</span></span></span><br><span class="line"><span class="function">         4: <span class="title">return</span></span></span><br><span class="line"><span class="function">      <span class="title">LineNumberTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 3: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">public</span> <span class="title">int</span> <span class="title">inc</span>();</span></span><br><span class="line"><span class="function">    <span class="title">descriptor</span>: ()<span class="title">I</span></span></span><br><span class="line"><span class="function">    <span class="title">flags</span>: <span class="title">ACC_PUBLIC</span></span></span><br><span class="line"><span class="function">    <span class="title">Code</span>:</span></span><br><span class="line"><span class="function">      <span class="title">stack</span>=2, <span class="title">locals</span>=1, <span class="title">args_size</span>=1</span></span><br><span class="line"><span class="function">         0: <span class="title">aload_0</span></span></span><br><span class="line"><span class="function">         1: <span class="title">getfield</span>      #2                  // <span class="title">Field</span> <span class="title">m:I</span></span></span><br><span class="line"><span class="function">         4: <span class="title">iconst_1</span></span></span><br><span class="line"><span class="function">         5: <span class="title">iadd</span></span></span><br><span class="line"><span class="function">         6: <span class="title">ireturn</span></span></span><br><span class="line"><span class="function">      <span class="title">LineNumberTable</span>:</span></span><br><span class="line"><span class="function">        <span class="title">line</span> 7: 0</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">SourceFile</span>: "<span class="title">Foo.java</span>"</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解Java虚拟机》周志明，</p><p>另外找到的其他关于Class文件解析的文章有：</p><p><a href="https://www.cnblogs.com/timlong/p/8143839.html" target="_blank" rel="noopener">https://www.cnblogs.com/timlong/p/8143839.html</a></p><p><a href="https://www.cnblogs.com/noteless/p/9540876.html#0" target="_blank" rel="noopener">https://www.cnblogs.com/noteless/p/9540876.html#0</a></p><p><a href="https://www.jianshu.com/p/d0f3e361f92e" target="_blank" rel="noopener">https://www.jianshu.com/p/d0f3e361f92e</a></p><p><a href="https://www.jb51.net/article/116203.htm" target="_blank" rel="noopener">https://www.jb51.net/article/116203.htm</a>（这个有对文中没有详细解释的method方法的属性的解释）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM之Class文件分析详解&quot;&gt;&lt;a href=&quot;#JVM之Class文件分析详解&quot; class=&quot;headerlink&quot; title=&quot;JVM之Class文件分析详解&quot;&gt;&lt;/a&gt;JVM之Class文件分析详解&lt;/h1&gt;&lt;p&gt;逐个字节分析Class文件。了解Class文件内部结构。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot的属性注入和自动配置原理</title>
    <link href="http://yoursite.com/2019/04/17/SpringBoot%E7%9A%84%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%E5%92%8C%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/17/SpringBoot的属性注入和自动配置原理/</id>
    <published>2019-04-17T14:09:28.000Z</published>
    <updated>2020-07-27T09:25:36.636Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot的学习，属性注入和自动配置原理。</p><a id="more"></a><h1 id="1-了解SpringBoot"><a href="#1-了解SpringBoot" class="headerlink" title="1. 了解SpringBoot"></a>1. 了解SpringBoot</h1><p>在这一部分，我们主要了解以下3个问题：</p><ul><li>什么是SpringBoot</li><li>为什么要学习SpringBoot</li><li>SpringBoot的特点</li></ul><h2 id="1-1-什么是SpringBoot"><a href="#1-1-什么是SpringBoot" class="headerlink" title="1.1.什么是SpringBoot"></a>1.1.什么是SpringBoot</h2><p>SpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品:</p><p><img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525484756737.png" alt="1525484756737"></p><p>我们可以看到下面的一段介绍：</p><blockquote><p>Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible.</p></blockquote><p>翻译一下：</p><blockquote><p>用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。</p></blockquote><p>其实人们把Spring Boot 称为搭建程序的<code>脚手架</code>。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。</p><h2 id="1-2-为什么要学习SpringBoot"><a href="#1-2-为什么要学习SpringBoot" class="headerlink" title="1.2.为什么要学习SpringBoot"></a>1.2.为什么要学习SpringBoot</h2><p>java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点：</p><ul><li><p>复杂的配置，</p><p>项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。</p></li><li><p>一个是混乱的依赖管理。</p><p>项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。</p></li></ul><p>而SpringBoot让这一切成为过去！</p><blockquote><p>Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。</p></blockquote><p>我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。</p><h2 id="1-3-SpringBoot的特点"><a href="#1-3-SpringBoot的特点" class="headerlink" title="1.3.SpringBoot的特点"></a>1.3.SpringBoot的特点</h2><p>Spring Boot 主要目标是：</p><ul><li>为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验</li><li>开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。</li><li>提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等</li><li>绝对没有代码生成，也无需 XML 配置。</li></ul><p>更多细节，大家可以到<a href="http://projects.spring.io/spring-boot/" target="_blank" rel="noopener">官网</a>查看。</p><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><p>接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！</p><h2 id="2-1-创建工程"><a href="#2-1-创建工程" class="headerlink" title="2.1.创建工程"></a>2.1.创建工程</h2><p>我们先新建一个空的工程：</p><p><img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525485888078.png" alt="1525485888078"></p><p>工程名为demo：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525485977528.png" alt="1525485977528"></p><p>新建一个model：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525486079389.png" alt="1525486079389"></p><p>使用maven来构建：</p><p><img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525486188374.png" alt="1525486188374"></p><p>然后填写项目坐标：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525486236967.png" alt="1525486236967"></p><p>目录结构：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525486282929.png" alt="1525486282929"></p><p>项目结构：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525486435199.png" alt="1525486435199"></p><h2 id="2-2-添加依赖"><a href="#2-2-添加依赖" class="headerlink" title="2.2.添加依赖"></a>2.2.添加依赖</h2><p>看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？</p><p>别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！</p><h3 id="2-2-1-添加父工程坐标"><a href="#2-2-1-添加父工程坐标" class="headerlink" title="2.2.1.添加父工程坐标"></a>2.2.1.添加父工程坐标</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-2-添加web启动器"><a href="#2-2-2-添加web启动器" class="headerlink" title="2.2.2.添加web启动器"></a>2.2.2.添加web启动器</h3><p>为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为<code>启动器</code>。因为我们是web项目，这里我们引入web启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。</p><p>这个时候，我们会发现项目中多出了大量的依赖：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525486980765.png" alt="1525486980765"></p><p>这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。</p><h3 id="2-2-3-管理jdk版本"><a href="#2-2-3-管理jdk版本" class="headerlink" title="2.2.3.管理jdk版本"></a>2.2.3.管理jdk版本</h3><p>默认情况下，maven工程的jdk版本是1.5，而我们开发使用的是1.8，因此这里我们需要修改jdk版本，只需要简单的添加以下属性即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-4-完整pom"><a href="#2-2-4-完整pom" class="headerlink" title="2.2.4.完整pom"></a>2.2.4.完整pom</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-启动类"><a href="#2-3-启动类" class="headerlink" title="2.3.启动类"></a>2.3.启动类</h2><p>Spring Boot项目通过main函数即可启动，我们需要创建一个启动类：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525487293907.png" alt="1525487293907"></p><p>然后编写main函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-编写controller"><a href="#2-4-编写controller" class="headerlink" title="2.4.编写controller"></a>2.4.编写controller</h2><p>接下来，我们就可以像以前那样开发SpringMVC的项目了！</p><p>我们编写一个controller：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525487465325.png" alt="1525487465325"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, spring boot!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-启动测试"><a href="#2-5-启动测试" class="headerlink" title="2.5.启动测试"></a>2.5.启动测试</h2><p>接下来，我们运行main函数，查看控制台：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525487613365.png" alt="1525487613365"></p><p>并且可以看到监听的端口信息：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525487705460.png" alt="1525487705460"></p><ul><li>1）监听的端口是8080</li><li>2）SpringMVC的映射路径是：/</li><li>3）<code>/hello</code>路径已经映射到了<code>HelloController</code>中的<code>hello()</code>方法</li></ul><p>打开页面访问：<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a></p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525487820824.png" alt="1525487820824"></p><p>测试成功了！</p><h1 id="3-Java配置"><a href="#3-Java配置" class="headerlink" title="3.Java配置"></a>3.Java配置</h1><p>在入门案例中，我们没有任何的配置，就可以实现一个SpringMVC的项目了，快速、高效！</p><p>但是有同学会有疑问，如果没有任何的xml，那么我们如果要配置一个Bean该怎么办？比如我们要配置一个数据库连接池，以前会这么玩：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在该怎么做呢？</p><h2 id="3-1-回顾历史"><a href="#3-1-回顾历史" class="headerlink" title="3.1.回顾历史"></a>3.1.回顾历史</h2><p>事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史：</p><ul><li><p>Spring1.0时代</p><p>在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒</p></li><li><p>Spring2.0时代</p><p>Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。</p></li><li><p>Spring3.0及以后</p><p>3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。</p></li></ul><p>有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。</p><h2 id="3-2-尝试java配置"><a href="#3-2-尝试java配置" class="headerlink" title="3.2.尝试java配置"></a>3.2.尝试java配置</h2><p>java配置主要靠java类和一些注解，比较常用的注解有：</p><ul><li><code>@Configuration</code>：声明一个类作为配置类，代替xml文件</li><li><code>@Bean</code>：声明在方法上，将方法的返回值加入Bean容器，代替<code>&lt;bean&gt;</code>标签</li><li><code>@value</code>：属性注入</li><li><code>@PropertySource</code>：指定外部属性文件，</li></ul><p>我们接下来用java配置来尝试实现连接池配置：</p><p>首先引入Druid连接池依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建一个jdbc.properties文件，编写jdbc属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://127.0.0.1:3306/leyou</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=123</span><br></pre></td></tr></table></figure><p>然后编写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    String url;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>)</span><br><span class="line">    String driverClassName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>@Configuration</code>：声明我们<code>JdbcConfig</code>是一个配置类</li><li><code>@PropertySource</code>：指定属性文件的路径是:<code>classpath:jdbc.properties</code></li><li>通过<code>@Value</code>为属性注入值</li><li>通过@Bean将 <code>dataSource()</code>方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。</li></ul><p>然后我们就可以在任意位置通过<code>@Autowired</code>注入DataSource了！</p><p>我们在<code>HelloController</code>中测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, spring boot!"</span> + dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后Debug运行并查看：</p><p><img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525492528558.png" alt="1525492528558"></p><p>属性注入成功了！</p><h2 id="3-3-SpringBoot的属性注入"><a href="#3-3-SpringBoot的属性注入" class="headerlink" title="3.3.SpringBoot的属性注入"></a>3.3.SpringBoot的属性注入</h2><p>在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。</p><p>在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。</p><p>1）我们新建一个类，用来进行属性注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"jdbc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="comment">// getters 和 setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在类上通过@ConfigurationProperties注解声明当前类为属性读取类</p></li><li><p><code>prefix=&quot;jdbc&quot;</code>读取属性文件中，前缀为jdbc的值。</p></li><li><p>在类上定义各个属性，名称必须与属性文件中<code>jdbc.</code>后面部分一致</p></li><li><p>需要注意的是，这里我们并没有指定属性文件的地址，所以我们需要把jdbc.properties名称改为application.properties，这是SpringBoot默认读取的属性文件名：</p><p><img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525496325572.png" alt="1525496325572"></p></li></ul><p>2）在JdbcConfig中使用这个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(JdbcProperties.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(JdbcProperties jdbc)</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUrl(jdbc.getUrl());</span><br><span class="line">        dataSource.setDriverClassName(jdbc.getDriverClassName());</span><br><span class="line">        dataSource.setUsername(jdbc.getUsername());</span><br><span class="line">        dataSource.setPassword(jdbc.getPassword());</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通过<code>@EnableConfigurationProperties(JdbcProperties.class)</code>来声明要使用<code>JdbcProperties</code>这个类的对象</p></li><li><p>然后你可以通过以下方式注入JdbcProperties：</p><ul><li><p>@Autowired注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcProperties prop;</span><br></pre></td></tr></table></figure></li><li><p>构造函数注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> JdbcProperties prop;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdbcConfig</span><span class="params">(Jdbcproperties prop)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.prop = prop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明有@Bean的方法参数注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Datasource <span class="title">dataSource</span><span class="params">(JdbcProperties prop)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>本例中，我们采用第三种方式。</p><p>3）测试结果：</p><p><img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525492528558.png" alt="1525492528558"></p><p>大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系：</p><p><img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525496543249.png" alt="1525496543249"></p><p>优势：</p><ul><li><p>Relaxed binding：松散绑定</p><ul><li><p>不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。</p></li><li><p>meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。</p></li></ul></li></ul><h2 id="3-4-更优雅的注入"><a href="#3-4-更优雅的注入" class="headerlink" title="3.4.更优雅的注入"></a>3.4.更优雅的注入</h2><p>事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"jdbc"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接把<code>@ConfigurationProperties(prefix = &quot;jdbc&quot;)</code>声明在需要使用的<code>@Bean</code>的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：<strong>该类必须有对应属性的set方法！</strong></p><p>我们将jdbc的url改成：/heima，再次测试：</p><p><img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525497513206.png" alt="1525497513206"></p><h1 id="4-自动配置原理"><a href="#4-自动配置原理" class="headerlink" title="4.自动配置原理"></a>4.自动配置原理</h1><p>使用SpringBoot之后，一个整合了SpringMVC的WEB工程开发，变的无比简单，那些繁杂的配置都消失不见了，这是如何做到的？</p><p>一切魔力的开始，都是从我们的main函数来的，所以我们再次来看下启动类：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525488044650.png" alt="1525488044650"></p><p>我们发现特别的地方有两个：</p><ul><li>注解：@SpringBootApplication</li><li>run方法：SpringApplication.run()</li></ul><p>我们分别来研究这两个部分。</p><h2 id="4-1-了解-SpringBootApplication"><a href="#4-1-了解-SpringBootApplication" class="headerlink" title="4.1.了解@SpringBootApplication"></a>4.1.了解@SpringBootApplication</h2><p>点击进入，查看源码：</p><p><img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525488226710.png" alt="1525488226710"></p><p>这里重点的注解有3个：</p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><h3 id="4-1-1-SpringBootConfiguration"><a href="#4-1-1-SpringBootConfiguration" class="headerlink" title="4.1.1.@SpringBootConfiguration"></a>4.1.1.@SpringBootConfiguration</h3><p>我们继续点击查看源码：</p><p><img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525488518514.png" alt="1525488518514"></p><p>通过这段我们可以看出，在这个注解上面，又有一个<code>@Configuration</code>注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了<code>@Configuration</code>的类，并且读取其中的配置信息。而<code>@SpringBootConfiguration</code>是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。</p><h3 id="4-1-2-EnableAutoConfiguration"><a href="#4-1-2-EnableAutoConfiguration" class="headerlink" title="4.1.2.@EnableAutoConfiguration"></a>4.1.2.@EnableAutoConfiguration</h3><p>关于这个注解，官网上有一段说明：</p><blockquote><p>The second class-level annotation is <code>@EnableAutoConfiguration</code>. This annotation<br>tells Spring Boot to “guess” how you want to configure Spring, based on the jar<br>dependencies that you have added. Since <code>spring-boot-starter-web</code> added Tomcat<br>and Spring MVC, the auto-configuration assumes that you are developing a web<br>application and sets up Spring accordingly.</p></blockquote><p>简单翻译以下：</p><blockquote><p>第二级的注解<code>@EnableAutoConfiguration</code>，告诉SpringBoot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了<code>spring-boot-starter-web</code>，而这个启动器中帮我们添加了<code>tomcat</code>、<code>SpringMVC</code>的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！</p></blockquote><p>总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。</p><p>所以，我们使用SpringBoot构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。除非你不希望使用SpringBoot的默认配置，它也提供了自定义配置的入口。</p><h3 id="4-1-3-ComponentScan"><a href="#4-1-3-ComponentScan" class="headerlink" title="4.1.3.@ComponentScan"></a>4.1.3.@ComponentScan</h3><p>我们跟进源码：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525498265579.png" alt="1525498265579"></p><p>并没有看到什么特殊的地方。我们查看注释：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525498351385.png" alt="1525498351385"></p><p>大概的意思：</p><blockquote><p>配置组件扫描的指令。提供了类似与<code>&lt;context:component-scan&gt;</code>标签的作用</p><p>通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包</p></blockquote><p>而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，<strong>一般启动类会放在一个比较前的包目录中。</strong></p><h2 id="4-2-默认配置原理"><a href="#4-2-默认配置原理" class="headerlink" title="4.2.默认配置原理"></a>4.2.默认配置原理</h2><h3 id="4-2-1默认配置类"><a href="#4-2-1默认配置类" class="headerlink" title="4.2.1默认配置类"></a>4.2.1默认配置类</h3><p>通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了：</p><ul><li>这些默认配置是在哪里定义的呢？</li><li>为何依赖引入就会触发配置呢？</li></ul><p>其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525499397690.png" alt="1525499397690"></p><p>还有：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525499426598.png" alt="1525499426598"></p><p>非常多，几乎涵盖了现在主流的开源框架，例如：</p><ul><li>redis</li><li>jms</li><li>amqp</li><li>jdbc</li><li>jackson</li><li>mongodb</li><li>jpa</li><li>solr</li><li>elasticsearch</li></ul><p>… 等等</p><p>我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525499859426.png" alt="1525499859426"></p><p>打开WebMvcAutoConfiguration：</p><p><img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525500000816.png" alt="1525500000816"></p><p>我们看到这个类上的4个注解：</p><ul><li><p><code>@Configuration</code>：声明这个类是一个配置类</p></li><li><p><code>@ConditionalOnWebApplication(type = Type.SERVLET)</code></p><p>ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是</p></li><li><p><code>@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })</code></p><p>这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！</p></li><li><p><code>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code></p><p>这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！</p></li></ul><p>接着，我们查看该类中定义了什么：</p><p>视图解析器：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525500405278.png" alt="1525500405278"></p><p>处理器适配器（HandlerAdapter）：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525500452517.png" alt="1525500452517"></p><p>还有很多，这里就不一一截图了。</p><h3 id="4-2-2-默认配置属性"><a href="#4-2-2-默认配置属性" class="headerlink" title="4.2.2.默认配置属性"></a>4.2.2.默认配置属性</h3><p>另外，这些默认配置的属性来自哪里呢？</p><p><img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525500697391.png" alt="1525500697391"></p><p>我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。这不正是SpringBoot的属性注入玩法嘛。</p><p>我们查看这两个属性类：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525500810914.png" alt="1525500810914"></p><p>找到了内部资源视图解析器的prefix和suffix属性。</p><p>ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径：</p><p> <img src="/2019/04/17/SpringBoot的属性注入和自动配置原理/1525500921773.png" alt="1525500921773"></p><p>如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。</p><h2 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3.总结"></a>4.3.总结</h2><p>SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个：</p><ul><li>你引入了相关依赖</li><li>你自己没有配置Bean</li></ul><p>1）启动器</p><p>所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。</p><p>因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器。</p><p>2）全局配置</p><p>另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义<code>application.properties</code>文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。</p><p>因此，玩SpringBoot的第二件事情，就是通过<code>application.properties</code>来覆盖默认属性值，形成自定义配置。</p><p>属性文件支持两种格式，application.properties和application.yml</p><p>yml的语法实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc:</span></span><br><span class="line"><span class="attr">  driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">  url:</span> <span class="attr">jdbc:mysql://127.0.0.1:3306/leyou</span></span><br><span class="line"><span class="attr">  username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  password:</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot的学习，属性注入和自动配置原理。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/Spring/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结</title>
    <link href="http://yoursite.com/2019/04/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/17/操作系统总结/</id>
    <published>2019-04-17T08:33:08.000Z</published>
    <updated>2020-07-27T09:25:36.713Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关于操作系统问题的总结。</strong></p><a id="more"></a><h1 id="操作系统总结："><a href="#操作系统总结：" class="headerlink" title="操作系统总结："></a>操作系统总结：</h1><h2 id="1-进程和线程的区别是什么？"><a href="#1-进程和线程的区别是什么？" class="headerlink" title="1.进程和线程的区别是什么？"></a>1.进程和线程的区别是什么？</h2><p>进程是CPU分配资源的最小单元，线程是CPU调度的基本单元、一个进程可以包含多个线程、巴拉巴拉。如果你觉得这个概念在你心里不是特别清楚的话，一定要到网上看一下，最好能够理解为什么有些时候要使用线程不使用进程。因为进程启动的时候cpu需要给他分配资源，对系统压力比进程大，你可以把线程看成是轻量级的进程。</p><p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位<br><strong>在开销方面</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。<br><strong>所处环境</strong>：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）<br><strong>内存分配方面</strong>：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。<br><strong>包含关系</strong>：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><p><strong>何时使用多进程，何时使用多线程？</strong><br>对资源的管理和保护要求高，不限制开销和效率时，使用多进程。<br>要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</p><h2 id="2-进程间通信的方式有什么？线程间通信的方式有什么？"><a href="#2-进程间通信的方式有什么？线程间通信的方式有什么？" class="headerlink" title="2.进程间通信的方式有什么？线程间通信的方式有什么？"></a>2.进程间通信的方式有什么？线程间通信的方式有什么？</h2><p>这也是一个被问烂的问题。进程间通讯可以通过socket，管道，信号，消息，共享内存等多种方式。线程间通信就比较简单了，直接共享变量也行，通过管道也行。</p><p>进程的通信方式：管道、信号量、消息队列、信号、共享内存、套接字</p><p><em>参考博客：<a href="https://blog.csdn.net/biqioso/article/details/80025726" target="_blank" rel="noopener">https://blog.csdn.net/biqioso/article/details/80025726</a></em><br><em>线程间通信 参考博客：<a href="https://blog.csdn.net/qq_32621445/article/details/78635951" target="_blank" rel="noopener">https://blog.csdn.net/qq_32621445/article/details/78635951</a></em></p><h2 id="3-什么是缓存？有哪些缓存的更新算法？"><a href="#3-什么是缓存？有哪些缓存的更新算法？" class="headerlink" title="3.什么是缓存？有哪些缓存的更新算法？"></a>3.什么是缓存？有哪些缓存的更新算法？</h2><p>缓存的更新算法用的最多的应该就是LRU。</p><p>———————————————-还未完成，等待更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关于操作系统问题的总结。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络总结</title>
    <link href="http://yoursite.com/2019/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/16/计算机网络总结/</id>
    <published>2019-04-16T07:08:28.000Z</published>
    <updated>2020-07-27T09:25:36.720Z</updated>
    
    <content type="html"><![CDATA[<p><strong>关于计算机网络的问题总结.</strong></p><a id="more"></a><h1 id="计算机网络总结"><a href="#计算机网络总结" class="headerlink" title="计算机网络总结"></a>计算机网络总结</h1><h2 id="1-OSI，TCP-IP，五层协议的体系结构，以及各层协议"><a href="#1-OSI，TCP-IP，五层协议的体系结构，以及各层协议" class="headerlink" title="1.OSI，TCP/IP，五层协议的体系结构，以及各层协议"></a>1.OSI，TCP/IP，五层协议的体系结构，以及各层协议</h2><p><strong>OSI分层 （7层）：</strong> 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br><strong>TCP/IP分层（4层）：</strong> 网络接口层、 网际层、运输层、 应用层。<br><strong>五层协议 （5层）：</strong> 物理层、数据链路层、网络层、运输层、 应用层。</p><p><strong>每一层的协议如下：</strong><br>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）<br>数据链路层：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p><p><strong>每一层的作用如下：</strong><br>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p><p><strong>OSI将计算机网络体系结构(architecture）划分为以下七层：</strong><br>物理层: 将数据转换为可通过物理介质传送的电子信号 相当于邮局中的搬运工人。<br>数据链路层: 决定访问网络介质的方式。在此层将数据分帧，并处理流控制。本层指定拓扑结构并提供硬件寻址，相当于邮局中的装拆箱工人。<br>网络层: 使用权数据路由经过大型网络 相当于邮局中的排序工人。<br>传输层: 提供终端到终端的可靠连接 相当于公司中跑邮局的送信职员。<br>会话层: 允许用户使用简单易记的名称建立连接 相当于公司中收寄信、写信封与拆信封的秘书。<br>表示层: 协商数据交换格式 相当公司中简报老板、替老板写信的助理。<br>应用层: 用户的应用程序和网络之间的接口老板。</p><h2 id="2-TCP协议中的三次握手，为什么两次握手不行"><a href="#2-TCP协议中的三次握手，为什么两次握手不行" class="headerlink" title="2.TCP协议中的三次握手，为什么两次握手不行"></a>2.TCP协议中的三次握手，为什么两次握手不行</h2><p>建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。<br>（1）<strong>TCP的三次握手过程：</strong> 主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。<br>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种<strong>特殊情况</strong> ，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。<br>（3）采用两次握手不行，原因就是上面说的“失效的连接请求“的特殊情况。</p><h2 id="3-TCP和UDP有什么区别，什么场景使用TCP，什么场景什么UDP，哪些应用层协议使用了TCP，哪些使用了UDP"><a href="#3-TCP和UDP有什么区别，什么场景使用TCP，什么场景什么UDP，哪些应用层协议使用了TCP，哪些使用了UDP" class="headerlink" title="3.TCP和UDP有什么区别，什么场景使用TCP，什么场景什么UDP，哪些应用层协议使用了TCP，哪些使用了UDP"></a>3.TCP和UDP有什么区别，什么场景使用TCP，什么场景什么UDP，哪些应用层协议使用了TCP，哪些使用了UDP</h2><p><strong>TCP和UDP最主要的区别是TCP是可靠传输的，UDP是不可靠传输的</strong> 。所以如果我们的发送消息之类的场景，因为你要确保用户的消息不会丢失，需要使用TCP协议。如果你是在进行视频聊天或者看直播，那你可以使用UDP协议，因为即使几个画面丢失了，对用户来说影响也不是很大。</p><p><strong>TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。</strong><br>TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。<br>TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。</p><p>TCP对应的协议和UDP对应的协议<br><strong>TCP对应的协议：</strong><br>（1） FTP：定义了文件传输协议，使用21端口。<br>（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。<br>（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。<br>（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。<br>（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。<br><strong>UDP对应的协议：</strong><br>（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。<br>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。<br>（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</p><h2 id="4-TCP三次握手和四次挥手的全过程"><a href="#4-TCP三次握手和四次挥手的全过程" class="headerlink" title="4.TCP三次握手和四次挥手的全过程"></a>4.TCP三次握手和四次挥手的全过程</h2><p>运输连接有三个阶段，即：连接建立、数据传送和连接释放。</p><p>TCP建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个TCP报文段。详见计算机网络（第七版谢希仁）238，240，218，219页。说是三次握手其实是不准确的，具体情况是一次握手过程中交换了三个报文，而并不是进行了三次握手，这有点像两个人见面进行一次握手时，他们的手上摇晃了三次，但这并非进行了三次握手。RFC937文档中有这样的描述：“three way（three message） handshake”。handshake使用的是单数而不是复数，表明只是一次握手。准确的译名应该是“三报文握手”。</p><p><strong>三次握手(三报文握手)：</strong></p><p>一个易于理解的图：</p><p><img src="/2019/04/16/计算机网络总结/20180618232834260.png" alt="20180618232834260"></p><p>详细的图：</p><p><img src="/2019/04/16/计算机网络总结/1641067-8d52ca990ffbee0a.png" alt="img"></p><p>第一次握手：客户端发送SYN = 0[同步]包(seq[序号] = x)到服务器，并进入<strong>SYN_SEND</strong> 状态，等待服务器确认；<br>第二次握手：服务器收到SYN包，必须确认客户的SYN[同步]（ACK = 1，ack = x + 1），同时自己也发送一个SYN包（SYN=1，seq=y），即SYN + ACK包，此时服务器进入<strong>SYN_RECV</strong> 状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ACK = 1，seq = x + 1, ack = y + 1)，此包发送完毕，客户端和服务器进入<strong>ESTABLISHED</strong> 状态，完成三次握手。<br>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p><p><strong>四次挥手（四报文握手）：</strong></p><p><img src="/2019/04/16/计算机网络总结/1641067-5ed8bf6c24244b4c.webp" alt="img"></p><p>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次挥手”。<br>第一次挥手：主动关闭方发送一个FIN包（FIN = 1，seq = u），同时进入<strong>FIN-WAIT-1</strong> 阶段，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。<br>第二次挥手：被动关闭方收到FIN包后，发送一个ACK（ACK = 1， seq = v， ack = u + 1）给对方，服务器为<strong>CLOSE-WAIT</strong> 状态，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。<br>第三次挥手：被动关闭方发送一个FIN（FIN = 1， ACK = 1， seq = w， ack = u + 1），用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了，客户端进行到<strong>FIN-WAIT-2</strong> 阶段，服务器B进行到<strong>LAST-ACK</strong> 阶段。<br>第四次挥手：主动关闭方收到FIN后，发送一个ACK（ACK = 1， seq = u + 1， ack = w + 1）给被动关闭方，确认序号为收到序号+1，客户端进到<strong>TIME-WAIT</strong>  状态，服务端关闭，在等待2MSL后，客户端关闭，至此，完成四次挥手。</p><p><strong>注意：</strong> </p><p>在<strong>TIME-WAIT</strong> 状态，必须等待2MSL时间有两个理由。</p><p>第一，为了保证A发送的最后一个ACK报文段能够到达B。因为这个ACK报文段有可能丢失，如果在LAST-ACK状态的B收不到对方发送的FIN + ACK 报文段的确认，B会超时重传这个FIN + ACK 报文段，而 A就能在2MSL时间内收到这个重传的FIN + ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A 和 B都正常进入到CLOSED状态。</p><p>第二，防止“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中小时。这样就就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p><h2 id="5-什么是窗口滑动协议，什么是快速重传，什么是拥塞避免，什么是慢启动？"><a href="#5-什么是窗口滑动协议，什么是快速重传，什么是拥塞避免，什么是慢启动？" class="headerlink" title="5.什么是窗口滑动协议，什么是快速重传，什么是拥塞避免，什么是慢启动？"></a>5.什么是窗口滑动协议，什么是快速重传，什么是拥塞避免，什么是慢启动？</h2><p><strong>滑动窗口协议：</strong> 属于TCP协议中的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发送一个分组就停下来等待确认，所以该协议可以加速数据的传输，提高网络吞吐量。<br>滑动窗口是接受数据端使用的窗口大小，用来告知发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的。</p><p>网络中的链路容量和交换结点中的缓存和处理机都有着工作的极限，当网络的需求超过它们的工作极限时，就出现了拥塞。拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。常用的方法就是：</p><ol><li>慢开始、拥塞避免</li><li>快重传、快恢复</li></ol><p><strong>慢开始算法：</strong>先让拥塞窗口cwnd=1，然后每经过一个传输轮次（RTT），拥塞窗口 cwnd 就加倍，直到 cwnd = ssthresh（慢开始门限）<br><strong>拥塞避免算法：</strong>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。<br><strong>快重传：</strong>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器到期<br><strong>快恢复：</strong>把慢开始门限ssthresh减半，把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。<br><em>参考博客：<a href="https://www.cnblogs.com/losbyday/p/5847041.html" target="_blank" rel="noopener">https://www.cnblogs.com/losbyday/p/5847041.html</a></em><br><em>参考博客：<a href="https://blog.csdn.net/qq_37924084/article/details/78409096" target="_blank" rel="noopener">https://blog.csdn.net/qq_37924084/article/details/78409096</a></em></p><h2 id="6-当你输入域名访问一个网站的时候，背后的过程是什么？"><a href="#6-当你输入域名访问一个网站的时候，背后的过程是什么？" class="headerlink" title="6.当你输入域名访问一个网站的时候，背后的过程是什么？"></a>6.当你输入域名访问一个网站的时候，背后的过程是什么？</h2><p>这个问题是比较开放的，你可以回答的内容有很多，但是你如果回答得越详细肯定是越好的。第一步就是域名解析，域名解析的话你可以说一下域名缓存在哪些地方，然后如果你域名在本地没有缓存的话，是如何通过DNS来进行域名解析的，如果你的DNS服务器上没有保存那个域名，那你的DNS服务器将如何处理来得到这个域名的ip。第二步就是说一下TCP连接的三次握手的过程。其他拓展内容有很多可以说，看你知识储备。例如你可以说通过CDN来进行访问加速。也可以说目前网站基本上都是前后端分离的，访问的时候会先访问反向代理服务器进行负载均衡之类的。</p><h2 id="7-在浏览器中输入www-baidu-com后执行的全部过程"><a href="#7-在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="7.在浏览器中输入www.baidu.com后执行的全部过程"></a>7.在浏览器中输入<a href="http://www.baidu.com后执行的全部过程" target="_blank" rel="noopener">www.baidu.com后执行的全部过程</a></h2><p>1、客户端浏览器通过DNS解析到<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.181.27.48，然后通过TCP进行封装数据包，输入到网络层。<br>2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。<br>3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。<br>4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p><h2 id="8-什么是https协议？https协议用到了哪种密钥？"><a href="#8-什么是https协议？https协议用到了哪种密钥？" class="headerlink" title="8.什么是https协议？https协议用到了哪种密钥？"></a>8.什么是https协议？https协议用到了哪种密钥？</h2><p>https是在http上面套了一层ssl，用来实现安全连接。用到的密钥有对称密钥和非对称密钥。目前基本上大一点的网站，都会使用https，这里面涉及的知识点也不是很多，但是过程相对来说会复杂一点，感兴趣的话可以去看一下。基本上就是有数字证书，然后把对称密钥作为消息内容，通过非对称密钥来进行传输。之后双方的通信就通过对称密钥来进行解密就行了。<br><em>参考博客：<a href="https://www.cnblogs.com/zxj015/p/6530766.html" target="_blank" rel="noopener">https://www.cnblogs.com/zxj015/p/6530766.html</a></em></p><h2 id="9-什么是socket？"><a href="#9-什么是socket？" class="headerlink" title="9.什么是socket？"></a>9.什么是socket？</h2><p>socket是用来进行网络通信的。<br>TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样。TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。</p><p>为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了称为套接字 (Socket)的接口，区分不同应用程序进程间的网络通信和连接。</p><p>实际上socket是对TCP/IP协议的封装，它的出现只是使得程序员更方便地使用TCP/IP协议栈而已。socket本身并不是协议，它是应用层与TCP/IP协议族通信的中间软件抽象层，是一组调用接口</p><h2 id="10-什么是IO，什么是NIO，什么是AIO，什么是netty框架？"><a href="#10-什么是IO，什么是NIO，什么是AIO，什么是netty框架？" class="headerlink" title="10.什么是IO，什么是NIO，什么是AIO，什么是netty框架？"></a>10.什么是IO，什么是NIO，什么是AIO，什么是netty框架？</h2><p><strong>BIO</strong>：同步阻塞式IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。<br><strong>NIO</strong>：同步非阻塞式IO，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。<br><strong>AIO(NIO.2)</strong>：异步非阻塞式IO，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。<br><strong>Netty</strong>：Netty是一款异步的事件驱动的网络应用框架和工具，用于快速开发可维护的高性能、高扩展性协议服务器和客户端。也就是说，Netty是一个NIO客户端/服务器框架，支持快速、简单地开发网络应用，如协议服务器和客户端。它极大简化了网络编程，如TCP和UDP套接字服务器。</p><h2 id="11-ARP是地址解析协议，简单语言解释一下工作原理"><a href="#11-ARP是地址解析协议，简单语言解释一下工作原理" class="headerlink" title="11.ARP是地址解析协议，简单语言解释一下工作原理"></a>11.ARP是地址解析协议，简单语言解释一下工作原理</h2><ol><li>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</li><li>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。</li><li>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</li><li>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。<br>广播发送ARP请求，单播发送ARP响应。</li></ol><h2 id="13-从用户在浏览器输入域名，到浏览器显示出页面的过程"><a href="#13-从用户在浏览器输入域名，到浏览器显示出页面的过程" class="headerlink" title="13.从用户在浏览器输入域名，到浏览器显示出页面的过程"></a>13.从用户在浏览器输入域名，到浏览器显示出页面的过程</h2><p><a href="https://blog.csdn.net/qq_22313585/article/details/78926141" target="_blank" rel="noopener">https://blog.csdn.net/qq_22313585/article/details/78926141</a>这篇文章写的比较详细</p><p>同时感谢朋友的博客提供的问题：<a href="https://lzh0108.site/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/#more" target="_blank" rel="noopener">https://lzh0108.site/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/#more</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;关于计算机网络的问题总结.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux(CentOS下)更改终端命令行颜色及网络配置</title>
    <link href="http://yoursite.com/2019/04/12/Linux-CentOS%E4%B8%8B-%E6%9B%B4%E6%94%B9%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%A2%9C%E8%89%B2%E5%8F%8A%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/04/12/Linux-CentOS下-更改终端命令行颜色及网络配置/</id>
    <published>2019-04-12T01:38:27.000Z</published>
    <updated>2020-07-27T09:25:36.573Z</updated>
    
    <content type="html"><![CDATA[<p>﻿<strong>测试环境：CentOS 7</strong></p><p>修改CentOS命令行颜色以及配置网路总结。</p><a id="more"></a><h1 id="1-修改CentOS命令行颜色"><a href="#1-修改CentOS命令行颜色" class="headerlink" title="1. 修改CentOS命令行颜色"></a>1. 修改CentOS命令行颜色</h1><h2 id="1-1-用户命令行颜色修改："><a href="#1-1-用户命令行颜色修改：" class="headerlink" title="1.1. 用户命令行颜色修改："></a>1.1. 用户命令行颜色修改：</h2><p>进入用户家目录，输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al</span><br></pre></td></tr></table></figure><p><img src="/2019/04/12/Linux-CentOS下-更改终端命令行颜色及网络配置/20190412083032360.png" alt="linux截图"><br>然后，用vim或者vi编辑器打开.bash_profile文件，在文件最下方添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># PS1</span><br><span class="line">PS1=&apos;\[\e[32;40m\][\u@\h\w]$&apos;</span><br></pre></td></tr></table></figure><p>修改完输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><p>即可，这种方法可为每个用户定制登录颜色</p><h2 id="1-2-全用户命令行颜色修改："><a href="#1-2-全用户命令行颜色修改：" class="headerlink" title="1.2. 全用户命令行颜色修改："></a>1.2. 全用户命令行颜色修改：</h2><p>在root用户下登录，输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/bashrc</span><br></pre></td></tr></table></figure><p>接下来，修改方式相同，等于说只是换个目录打开全局配置文件修改即可，注意这个文件前面没有“.”。<br>修改完输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/bashrc</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 也可以在 /etc/profile中输入 PS1=”\e[1;32m\u\e[m\e[1;33m@\e[m\e[1;35m\h\e[m:\w\$”，但是此时的效果只会自动在登陆用户上产生，而使用su命令切换到root用户时，命令提示符还是普通颜色，此时需要再输入一遍 source /etc/bashrc ，才能使root用户的命令提示符改变颜色。而将内容输入在 /etc/bashrc中的话，任何用户的命令提示符颜色都做了修改。</p><h1 id="2-CentOS7网络配置"><a href="#2-CentOS7网络配置" class="headerlink" title="2. CentOS7网络配置"></a>2. CentOS7网络配置</h1><h2 id="2-1-修改ip地址"><a href="#2-1-修改ip地址" class="headerlink" title="2.1. 修改ip地址"></a>2.1. 修改ip地址</h2><p>编辑 <strong>/etc/sysconfig/network-scripts/</strong> ifcfg-eth33（具体名字按照具体网卡名来定）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static #设置为静态ip（网卡获得ip地址的方式，默认为dhcp，表示自动获取）</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=5c609e8c-9a0c-4346-a2d7-825b5f890bca</span><br><span class="line">DEVICE=ens33 #网卡对应的设备别名</span><br><span class="line">ONBOOT=yes #系统启动时是否激活此设备</span><br><span class="line">IPADDR=192.168.1.192 #设置ip地址</span><br><span class="line">NETMASK=255.255.255.0 #设置子网掩码 本配置也可以用 PREFIX=24 代替</span><br><span class="line">GATEWAY=192.168.1.1 #设置网关</span><br><span class="line">DNS1=8.8.8.8 #设置DNS地址，在这里设置后会同步到/etc/resolv.conf 文件中</span><br></pre></td></tr></table></figure><p>接下来输入命令重启网卡：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><p>centos7的新增网卡重启方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>配置文件中配置项的值（如static）不区分大小写，但是配置项的名字（如DNS1）区分大小写。小心出错。</p><h2 id="2-2-修改dns地址（在CentOS-7包括已知CentOS-6-7及以上不需设置此项）"><a href="#2-2-修改dns地址（在CentOS-7包括已知CentOS-6-7及以上不需设置此项）" class="headerlink" title="2.2. 修改dns地址（在CentOS 7包括已知CentOS 6.7及以上不需设置此项）"></a>2.2. 修改dns地址（在CentOS 7包括已知CentOS 6.7及以上不需设置此项）</h2><p>编辑/etc/resolv.conf<br>修改文件内容如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>在 <strong>/etc/sysconfig/network-scripts/</strong> ifcfg-eth33 中如果已经设置了ip地址，那么就不用设置此处，linux会自动完成同步。<br>直接修改/etc/resolv.conf这个文件是没用的，网络服务重启以后会根据 <strong>/etc/sysconfig /network-scripts/</strong> ifcfg-eth33来重载配置，如果ifcfg-eth0没有配置DNS，那么resolv.conf会被冲掉，重新变成空值。</p><p>常用dns地址</p><ol><li><strong>114.114.114.114</strong><br>114.114.114.114是国内移动、电信和联通通用的DNS，手机和电脑端都可以使用，干净无广告，解析成功率相对来说更高，国内用户使用的比较多，而且速度相对快、稳定，是国内用户上网常用的DNS</li><li><strong>8.8.8.8</strong><br>8.8.8.8是GOOGLE公司提供的DNS，该地址是全球通用的，相对来说，更适合国外以及访问国外网站的用户使用</li><li>223.5.5.5 阿里 </li><li>223.6.6.6 阿里 </li><li>180.76.76.76 百度</li></ol><h1 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h1><p><strong>另外附加常用配置软件位置：</strong><br>DNS配置文件：cat /etc/resolv.conf<br>设置主机和IP绑定信息：cat /etc/hosts<br>设置主机名：cat /etc/hostname</p><p><strong>防火墙操作：</strong></p><p>关闭防火墙并设置开机不启动<br>查看防火墙状态：systemctl status firewalld.service<br>关闭：systemctl stop firewalld<br>开启：systemctl start firewalld<br>开机自动关闭：systemctl disable firewalld<br>开机自动启动：systemctl enable firewalld</p><p><strong>查看开机是否启动：</strong><br>chkconfig –list|grep （要查询的应用）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;﻿&lt;strong&gt;测试环境：CentOS 7&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改CentOS命令行颜色以及配置网路总结。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
