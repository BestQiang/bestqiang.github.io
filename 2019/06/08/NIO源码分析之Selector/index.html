<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon2.ico?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="NIO源码分析之SelectorNIO的Selector源码第一句话就是 A multiplexor of {@link SelectableChannel} objects. 即 SelectableChannel对象的多路复用器。这很清楚的说明了Selector的作用。 这篇文章主要从以下几个点对Selector进行分析：  选择器（Selector） 可选择通道（SelectableChan">
<meta name="keywords" content="NIO">
<meta property="og:type" content="article">
<meta property="og:title" content="NIO源码分析之Selector">
<meta property="og:url" content="http://yoursite.com/2019/06/08/NIO源码分析之Selector/index.html">
<meta property="og:site_name" content="我就是BestQiang">
<meta property="og:description" content="NIO源码分析之SelectorNIO的Selector源码第一句话就是 A multiplexor of {@link SelectableChannel} objects. 即 SelectableChannel对象的多路复用器。这很清楚的说明了Selector的作用。 这篇文章主要从以下几个点对Selector进行分析：  选择器（Selector） 可选择通道（SelectableChan">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/06/08/NIO源码分析之Selector/20151214194029453">
<meta property="og:image" content="http://yoursite.com/2019/06/08/NIO源码分析之Selector/1559911406587.png">
<meta property="og:image" content="http://yoursite.com/2019/06/08/NIO源码分析之Selector/1559911644365.png">
<meta property="og:image" content="http://yoursite.com/2019/06/08/NIO源码分析之Selector/1559911657130.png">
<meta property="og:image" content="http://yoursite.com/2019/06/08/NIO源码分析之Selector/1559913710363.png">
<meta property="og:image" content="http://yoursite.com/2019/06/08/NIO源码分析之Selector/1559913853013.png">
<meta property="og:image" content="http://yoursite.com/2019/06/08/NIO源码分析之Selector/1559912425948.png">
<meta property="og:image" content="http://yoursite.com/2019/06/08/NIO源码分析之Selector/1559912485036.png">
<meta property="og:image" content="http://yoursite.com/2019/06/08/NIO源码分析之Selector/1559912629829.png">
<meta property="og:image" content="http://yoursite.com/2019/06/08/NIO源码分析之Selector/1559959788470.png">
<meta property="og:image" content="http://yoursite.com/2019/06/08/NIO源码分析之Selector/1559960109410.png">
<meta property="og:image" content="http://yoursite.com/2019/06/08/NIO源码分析之Selector/1559961179277.png">
<meta property="og:image" content="http://yoursite.com/2019/06/08/NIO源码分析之Selector/1559959631484.png">
<meta property="og:updated_time" content="2020-07-27T09:25:36.615Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NIO源码分析之Selector">
<meta name="twitter:description" content="NIO源码分析之SelectorNIO的Selector源码第一句话就是 A multiplexor of {@link SelectableChannel} objects. 即 SelectableChannel对象的多路复用器。这很清楚的说明了Selector的作用。 这篇文章主要从以下几个点对Selector进行分析：  选择器（Selector） 可选择通道（SelectableChan">
<meta name="twitter:image" content="http://yoursite.com/2019/06/08/NIO源码分析之Selector/20151214194029453">



  <link rel="alternate" href="/atom.xml" title="我就是BestQiang" type="application/atom+xml">




  <link rel="canonical" href="http://yoursite.com/2019/06/08/NIO源码分析之Selector/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>NIO源码分析之Selector | 我就是BestQiang</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
<a href="https://github.com/BestQiang" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">我就是BestQiang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">活着就是为了改变世界，难道还有其他原因吗？</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/08/NIO源码分析之Selector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BestQiang">
      <meta itemprop="description" content="技术的进步来自于不懈的追求!">
      <meta itemprop="image" content="/uploads/Hermione.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我就是BestQiang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">NIO源码分析之Selector

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-08 08:18:30" itemprop="dateCreated datePublished" datetime="2019-06-08T08:18:30+08:00">2019-06-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-07-27 17:25:36" itemprop="dateModified" datetime="2020-07-27T17:25:36+08:00">2020-07-27</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NIO/" itemprop="url" rel="index"><span itemprop="name">NIO</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/06/08/NIO源码分析之Selector/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/06/08/NIO源码分析之Selector/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/06/08/NIO源码分析之Selector/" class="leancloud_visitors" data-flag-title="NIO源码分析之Selector">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">31k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">57 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="NIO源码分析之Selector"><a href="#NIO源码分析之Selector" class="headerlink" title="NIO源码分析之Selector"></a>NIO源码分析之Selector</h1><p>NIO的Selector源码第一句话就是 A multiplexor of {@link SelectableChannel} objects.</p>
<p>即 SelectableChannel对象的多路复用器。这很清楚的说明了Selector的作用。</p>
<p>这篇文章主要从以下几个点对Selector进行分析：</p>
<ul>
<li>选择器（Selector）</li>
<li>可选择通道（SelectableChannel）</li>
<li>选择键（SelectionKey）</li>
<li>Selector完整实例</li>
</ul>
<a id="more"></a>
<h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><p>Selector选择器类管理着一个被注册的通道集合的信息和它们的就绪状态。通道是和选择器一起被注册的，并且使用选择器来更新通道的就绪状态。当这么做的时候，可以选择将被激发的线程挂起，直到有就绪的的通道。</p>
<p>下面是使用Selector管理多个channel的结构图： </p>
<p><img src="/2019/06/08/NIO源码分析之Selector/20151214194029453" alt="Selector图"></p>
<ul>
<li>Selector的创建</li>
</ul>
<p>A selector may be created by invoking the open method of this class, which will use the system’s default selector provider to create a new selector. A selector may also be created by invoking the openSelector method of a custom selector provider. A selector remains open until it is closed via its close method. </p>
<p>可以通过调用此类的open方法来创建选择器，该方法将使用系统的默认选择器提供程序来创建新的选择器。 还可以通过调用自定义选择器提供程序的openSelector方法来创建选择器。 选择器保持打开状态，直到通过其关闭方法关闭。</p>
<p>Selector可以调用静态方法open()来创建Selector</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector Selector=Selector.open()；</span><br></pre></td></tr></table></figure>
<p>openSelector() 是通过系统的默认获取</p>
<p><img src="/2019/06/08/NIO源码分析之Selector/1559911406587.png" alt="1559911406587"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java.nio.channels.spi.SelectorProvider public static SelectorProvider provider()</span><br><span class="line">Returns the system-wide default selector provider for this invocation of the Java virtual machine.</span><br><span class="line">The first invocation of this method locates the default provider object as follows:</span><br><span class="line">If the system property java.nio.channels.spi.SelectorProvider is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</span><br><span class="line">If a provider class has been installed in a jar file that is visible to the system class loader, and that jar file contains a provider-configuration file named java.nio.channels.spi.SelectorProvider in the resource directory META-INF/services, then the first class name specified in that file is taken. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</span><br><span class="line">Finally, if no provider has been specified by any of the above means then the system-default provider class is instantiated and the result is returned.</span><br><span class="line">Subsequent invocations of this method return the provider that was returned by the first invocation.</span><br><span class="line"></span><br><span class="line">java.nio.channels.spi.SelectorProvider public static SelectorProvider provider（）</span><br><span class="line">返回此Java虚拟机调用的系统范围默认选择器提供程序。</span><br><span class="line">第一次调用此方法将按如下方式定位默认提供程序对象：</span><br><span class="line">如果定义了系统属性java.nio.channels.spi.SelectorProvider，那么它将被视为具体提供程序类的完全限定名称。该类被加载并实例化;如果此过程失败，则抛出未指定的错误。</span><br><span class="line">如果提供程序类已安装在对系统类加载器可见的jar文件中，并且该jar文件在资源目录META-INF / services中包含名为java.nio.channels.spi.SelectorProvider的提供程序配置文件，然后获取该文件中指定的第一个类名。该类被加载并实例化;如果此过程失败，则抛出未指定的错误。</span><br><span class="line">最后，如果没有通过上述任何方式指定提供程序，则实例化系统缺省提供程序类并返回结果。</span><br><span class="line">此方法的后续调用将返回第一次调用返回的提供程序。</span><br></pre></td></tr></table></figure>
<p><img src="/2019/06/08/NIO源码分析之Selector/1559911644365.png" alt="1559911644365"></p>
<p><img src="/2019/06/08/NIO源码分析之Selector/1559911657130.png" alt="1559911657130">为provider的类。</p>
<p>由以上的源码可见它加了锁，是线程安全的</p>
<h1 id="SelectableChannel"><a href="#SelectableChannel" class="headerlink" title="SelectableChannel"></a>SelectableChannel</h1><ul>
<li><p>SelectableChannel这个抽象类提供了实现通道的可选择性所需要的公共方法。它是所有支持就绪检查的通道类的父类。因为FileChannel类没有继承SelectableChannel因此是不是可选通道，而所有socket通道都是可选择的，包括从管道(Pipe)对象的中获得的通道。SelectableChannel可以被注册到Selector对象上，同时可以指定对那个选择器而言，那种操作是感兴趣的。一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。</p>
</li>
<li><p>源码上对它的介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">A channel that can be multiplexed via a Selector.</span><br><span class="line">In order to be used with a selector, an instance of this class must first be registered via the register method. This method returns a new SelectionKey object that represents the channel&apos;s registration with the selector.</span><br><span class="line">Once registered with a selector, a channel remains registered until it is deregistered. This involves deallocating whatever resources were allocated to the channel by the selector.</span><br><span class="line">A channel cannot be deregistered directly; instead, the key representing its registration must be cancelled. Cancelling a key requests that the channel be deregistered during the selector&apos;s next selection operation. A key may be cancelled explicitly by invoking its cancel method. All of a channel&apos;s keys are cancelled implicitly when the channel is closed, whether by invoking its close method or by interrupting a thread blocked in an I/O operation upon the channel.</span><br><span class="line">If the selector itself is closed then the channel will be deregistered, and the key representing its registration will be invalidated, without further delay.</span><br><span class="line">A channel may be registered at most once with any particular selector.</span><br><span class="line">Whether or not a channel is registered with one or more selectors may be determined by invoking the isRegistered method.</span><br><span class="line">Selectable channels are safe for use by multiple concurrent threads.</span><br><span class="line"></span><br><span class="line">可以通过选择器进行多路复用的通道。</span><br><span class="line">为了与选择器一起使用，必须首先通过register方法注册该类的实例。此方法返回一个新的SelectionKey对象，该对象表示通道与选择器的注册。</span><br><span class="line">一旦注册选择器，通道将保持注册状态，直到它被注销。这涉及解除分配选择器分配给通道的任何资源。</span><br><span class="line">渠道不能直接注销;相反，必须取消代表其注册的密钥。取消密钥请求在选择器的下一个选择操作期间取消注册该通道。可以通过调用其cancel方法显式取消密钥。当通道关闭时，无论是通过调用其close方法还是通过中断在通道上的I / O操作中阻塞的线程，所有通道的键都会被隐式取消。</span><br><span class="line">如果选择器本身已关闭，则将取消注册该通道，并且表示其注册的密钥将无效，而不会有进一步的延迟。</span><br><span class="line">一个频道最多可以与任何特定选择器一起注册一次。</span><br><span class="line">可以通过调用isRegistered方法来确定是否向一个或多个选择器注册了频道。</span><br><span class="line">多个并发线程可以安全地使用可选择的通道。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>SelectableChannel中有两个个方法为register，但是其实是一个方法<img src="/2019/06/08/NIO源码分析之Selector/1559913710363.png" alt="1559913710363"></p>
<p><img src="/2019/06/08/NIO源码分析之Selector/1559913853013.png" alt="1559913853013"></p>
<p>因为底层实现都是一样的，只不过第一个方法调用时第三个参数设置为null。</p>
</li>
</ul>
<p>它的抽象类<strong>AbstractSelectableChannel</strong>实现了这个抽象方法，注释为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">使用给定的选择器注册此通道，返回选择键。</span><br><span class="line">此方法首先验证此通道是否已打开，以及给定的初始兴趣集是否有效。</span><br><span class="line">如果此通道已在给定选择器中注册，则在将其兴趣设置为给定值后，将返回表示该注册的选择键。</span><br><span class="line">否则，此通道尚未在给定的选择器中注册，因此在保持适当的锁定时调用选择器的register方法。返回后，生成的密钥将添加到此通道的密钥集中。</span><br><span class="line"></span><br><span class="line">具体说明：</span><br><span class="line">在SelectableChannel类中注册</span><br><span class="line">PARAMS：</span><br><span class="line">sel  - 要注册此通道的选择器</span><br><span class="line">ops  - 为结果密钥设置的兴趣</span><br><span class="line">att  - 生成密钥的附件;可能是<span class="keyword">null</span></span><br><span class="line">返回：</span><br><span class="line">表示使用给定选择器注册此通道的键</span><br><span class="line">抛出：</span><br><span class="line">ClosedSelectorException  - 如果选择器已关闭</span><br><span class="line">IllegalBlockingModeException  - 如果此通道处于阻塞模式</span><br><span class="line">IllegalSelectorException  - 如果此通道不是由与给定选择器相同的提供程序创建的</span><br><span class="line">CancelledKeyException  - 如果此通道当前已在给定选择器中注册，但相应的键已被取消</span><br><span class="line">IllegalArgumentException  - 如果ops set中的某个位与此通道支持的操作不对应，即，如果set＆~validOps（）！= <span class="number">0</span></span><br><span class="line">ClosedChannelException  - 如果此通道已关闭</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers this channel with the given selector, returning a selection key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;  This method first verifies that this channel is open and that the</span></span><br><span class="line"><span class="comment">     * given initial interest set is valid.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If this channel is already registered with the given selector then</span></span><br><span class="line"><span class="comment">     * the selection key representing that registration is returned after</span></span><br><span class="line"><span class="comment">     * setting its interest set to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; Otherwise this channel has not yet been registered with the given</span></span><br><span class="line"><span class="comment">     * selector, so the &#123;<span class="doctag">@link</span> AbstractSelector#register register&#125; method of</span></span><br><span class="line"><span class="comment">     * the selector is invoked while holding the appropriate locks.  The</span></span><br><span class="line"><span class="comment">     * resulting key is added to this channel's key set before being returned.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  ClosedSelectorException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalBlockingModeException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalSelectorException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  CancelledKeyException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Object att)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClosedChannelException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (regLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">            <span class="keyword">if</span> ((ops &amp; ~validOps()) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            <span class="keyword">if</span> (blocking)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</span><br><span class="line">            SelectionKey k = findKey(sel);</span><br><span class="line">            <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line">                k.attach(att);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// New registration</span></span><br><span class="line">                <span class="keyword">synchronized</span> (keyLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">                    k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att);</span><br><span class="line">                    addKey(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>要实现Selector管理Channel，需要将channel注册到相应的Selector上，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key= channel.register(selector,SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>
<p>通过调用通道的register()方法会将它注册到一个选择器上。与Selector一起使用时，<strong>Channel必须处于非阻塞模式</strong>下，否则将抛出IllegalBlockingModeException异常，这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式，而套接字通道都可以。另外通道一旦被注册，将不能再回到阻塞状态，此时若调用通道的configureBlocking(true)将抛出BlockingModeException异常。</p>
<p>register()方法的第二个参数是“interest集合”，表示选择器所关心的通道操作，它实际上是一个表示选择器在检查通道就绪状态时需要关心的操作的比特掩码。比如一个选择器对通道的read和write操作感兴趣，那么选择器在检查该通道时，只会检查通道的read和write操作是否已经处在就绪状态。<br>它有以下四种操作类型：</p>
<ol>
<li><p><strong>Connect 连接</strong></p>
</li>
<li><p><strong>Accept 接受</strong></p>
</li>
<li><p><strong>Read 读</strong></p>
</li>
<li><p><strong>Write 写</strong></p>
</li>
</ol>
<p>需要注意并非所有的操作在所有的可选择通道上都能被支持，比如ServerSocketChannel支持Accept，而SocketChannel中不支持。我们可以通过通道上的validOps()方法来获取特定通道下所有支持的操作集合。</p>
<p>JAVA中定义了四个常量来表示这四种操作类型：</p>
<ol>
<li><strong>SelectionKey.OP_CONNECT</strong></li>
<li><strong>SelectionKey.OP_ACCEPT</strong></li>
<li><strong>SelectionKey.OP_READ</strong></li>
<li><strong>SelectionKey.OP_WRITE</strong></li>
</ol>
<p>如果Selector对通道的多操作类型感兴趣，可以用“位或”操作符来实现：</p>
<p><strong>int interestSet=SelectionKey.OP_READ|SelectionKey.OP_WRITE;</strong><br>当通道触发了某个操作之后，表示该通道的某个操作已经就绪，可以被操作。因此，某个SocketChannel成功连接到另一个服务器称为“连接就绪”(OP_CONNECT)。一个ServerSocketChannel准备好接收新进入的连接称为“接收就绪”（OP_ACCEPT）。一个有数据可读的通道可以说是“读就绪”(OP_READ)。等待写数据的通道可以说是“写就绪”(OP_WRITE)。</p>
<p>我们注意到register（）方法会返回一个SelectionKey对象，我们称之为键对象。下面会对键对象详细说明。</p>
<ul>
<li><p>ServerSocketChannel</p>
<p>源码上的介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">A selectable channel for stream-oriented listening sockets.</span><br><span class="line">A server-socket channel is created by invoking the open method of this class. It is not possible to create a channel for an arbitrary, pre-existing ServerSocket. A newly-created server-socket channel is open but not yet bound. An attempt to invoke the accept method of an unbound server-socket channel will cause a NotYetBoundException to be thrown. A server-socket channel can be bound by invoking one of the bind methods defined by this class.</span><br><span class="line">Socket options are configured using the setOption method. Server-socket channels support the following options:</span><br><span class="line">Option Name</span><br><span class="line">Description</span><br><span class="line">SO_RCVBUF</span><br><span class="line">The size of the socket receive buffer</span><br><span class="line">SO_REUSEADDR</span><br><span class="line">Re-use address</span><br><span class="line">Additional (implementation specific) options may also be supported.</span><br><span class="line">Server-socket channels are safe for use by multiple concurrent threads.</span><br><span class="line"></span><br><span class="line">面向流的侦听套接字的可选通道。</span><br><span class="line">通过调用此类的open方法创建服务器套接字通道。 无法为任意预先存在的ServerSocket创建通道。 新创建的服务器套接字通道已打开但尚未绑定。 尝试调用未绑定的服务器套接字通道的accept方法将导致抛出NotYetBoundException。 可以通过调用此类定义的绑定方法之一来绑定服务器套接字通道。</span><br><span class="line">使用setOption方法配置套接字选项。 服务器套接字通道支持以下选项：</span><br><span class="line">选项名称</span><br><span class="line">描述</span><br><span class="line">SO_RCVBUF</span><br><span class="line">套接字接收缓冲区的大小</span><br><span class="line">SO_REUSEADDR</span><br><span class="line">重复使用地址</span><br><span class="line">还可以支持其他（特定于实现的）选项。</span><br><span class="line">服务器套接字通道可供多个并发线程使用。</span><br></pre></td></tr></table></figure>
<p><img src="/2019/06/08/NIO源码分析之Selector/1559912425948.png" alt="1559912425948">ServerSocketChannel继承了AbstractSelectableChannel</p>
<p><img src="/2019/06/08/NIO源码分析之Selector/1559912485036.png" alt="1559912485036">AbstractSelectableChannel继承了SelectableChannel,所以，ServerSocketChannel注册到Selector上</p>
</li>
<li><p>SocketChannel</p>
<p>源码上的介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">A selectable channel for stream-oriented connecting sockets.</span><br><span class="line">A socket channel is created by invoking one of the open methods of this class. It is not possible to create a channel for an arbitrary, pre-existing socket. A newly-created socket channel is open but not yet connected. An attempt to invoke an I/O operation upon an unconnected channel will cause a NotYetConnectedException to be thrown. A socket channel can be connected by invoking its connect method; once connected, a socket channel remains connected until it is closed. Whether or not a socket channel is connected may be determined by invoking its isConnected method.</span><br><span class="line">Socket channels support non-blocking connection: A socket channel may be created and the process of establishing the link to the remote socket may be initiated via the connect method for later completion by the finishConnect method. Whether or not a connection operation is in progress may be determined by invoking the isConnectionPending method.</span><br><span class="line">Socket channels support asynchronous shutdown, which is similar to the asynchronous close operation specified in the Channel class. If the input side of a socket is shut down by one thread while another thread is blocked in a read operation on the socket&apos;s channel, then the read operation in the blocked thread will complete without reading any bytes and will return -1. If the output side of a socket is shut down by one thread while another thread is blocked in a write operation on the socket&apos;s channel, then the blocked thread will receive an AsynchronousCloseException.</span><br><span class="line">Socket options are configured using the setOption method. Socket channels support the following options:</span><br><span class="line">Option Name</span><br><span class="line">Description</span><br><span class="line">SO_SNDBUF</span><br><span class="line">The size of the socket send buffer</span><br><span class="line">SO_RCVBUF</span><br><span class="line">The size of the socket receive buffer</span><br><span class="line">SO_KEEPALIVE</span><br><span class="line">Keep connection alive</span><br><span class="line">SO_REUSEADDR</span><br><span class="line">Re-use address</span><br><span class="line">SO_LINGER</span><br><span class="line">Linger on close if data is present (when configured in blocking mode only)</span><br><span class="line">TCP_NODELAY</span><br><span class="line">Disable the Nagle algorithm</span><br><span class="line">Additional (implementation specific) options may also be supported.</span><br><span class="line">Socket channels are safe for use by multiple concurrent threads. They support concurrent reading and writing, though at most one thread may be reading and at most one thread may be writing at any given time. The connect and finishConnect methods are mutually synchronized against each other, and an attempt to initiate a read or write operation while an invocation of one of these methods is in progress will block until that invocation is complete.</span><br><span class="line"></span><br><span class="line">用于面向流的连接套接字的可选通道。</span><br><span class="line">通过调用此类的一个打开方法来创建套接字通道。无法为任意预先存在的套接字创建通道。新创建的套接字通道已打开但尚未连接。尝试在未连接的通道上调用I / O操作将导致抛出NotYetConnectedException。可以通过调用connect方法连接套接字通道;连接后，插座通道保持连接状态，直到它关闭。是否连接套接字通道可以通过调用其isConnected方法来确定。</span><br><span class="line">套接字通道支持非阻塞连接：可以创建套接字通道，并且可以通过connect方法启动建立到远程套接字的链接的过程，以便稍后通过finishConnect方法完成。可以通过调用isConnectionPending方法来确定连接操作是否正在进行。</span><br><span class="line">套接字通道支持异步关闭，这类似于Channel类中指定的异步关闭操作。如果套接字的输入端被一个线程关闭而另一个线程在套接字通道上的读操作中被阻塞，那么被阻塞线程中的读操作将完成而不读取任何字节并返回-1。如果套接字的输出端被一个线程关闭而另一个线程在套接字通道上的写操作中被阻塞，则被阻塞的线程将收到AsynchronousCloseException。</span><br><span class="line">使用setOption方法配置套接字选项。套接字通道支持以下选项：</span><br><span class="line">选项名称</span><br><span class="line">描述</span><br><span class="line">SO_SNDBUF</span><br><span class="line">套接字发送缓冲区的大小</span><br><span class="line">SO_RCVBUF</span><br><span class="line">套接字接收缓冲区的大小</span><br><span class="line">SO_KEEPALIVE</span><br><span class="line">保持连接活着</span><br><span class="line">SO_REUSEADDR</span><br><span class="line">重复使用地址</span><br><span class="line">SO_LINGER</span><br><span class="line">如果存在数据则关闭（仅在阻止模式下配置时）</span><br><span class="line">TCP_NODELAY</span><br><span class="line">禁用Nagle算法</span><br><span class="line">还可以支持其他（特定于实现的）选项。</span><br><span class="line">套接字通道可以安全地由多个并发线程使用。它们支持并发读写，但最多只有一个线程可能正在读取，并且最多一个线程可能在任何给定时间写入。 connect和finishConnect方法彼此相互同步，并且在调用其中一个方法时尝试启动读取或写入操作将阻塞，直到该调用完成。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2019/06/08/NIO源码分析之Selector/1559912629829.png" alt="1559912629829"></p>
<p>SocketChannel 继承了AbstractSelectableChannel，同ServerSocketChannel一样，可以注册到Selector。</p>
<h1 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h1><p>选择键封装了特定的通道与特定的选择器的注册关系。选择键对象被SelectableChannel.register()返回并提供一个表示这种注册关系的标记。选择键包含了两个比特集(以整数的形式进行编码)，指示了该注册关系所关心的通道操作，以及通道已经准备好的操作。</p>
<p>源码中这样说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A token representing the registration of a SelectableChannel with a Selector.</span><br><span class="line">A selection key is created each time a channel is registered with a selector. A key remains valid until it is cancelled by invoking its cancel method, by closing its channel, or by closing its selector. Cancelling a key does not immediately remove it from its selector; it is instead added to the selector&apos;s cancelled-key set for removal during the next selection operation. The validity of a key may be tested by invoking its isValid method. </span><br><span class="line">A selection key contains two operation sets represented as integer values. Each bit of an operation set denotes a category of selectable operations that are supported by the key&apos;s channel.</span><br><span class="line">The interest set determines which operation categories will be tested for readiness the next time one of the selector&apos;s selection methods is invoked. The interest set is initialized with the value given when the key is created; it may later be changed via the interestOps(int) method.</span><br><span class="line">The ready set identifies the operation categories for which the key&apos;s channel has been detected to be ready by the key&apos;s selector. The ready set is initialized to zero when the key is created; it may later be updated by the selector during a selection operation, but it cannot be updated directly.</span><br><span class="line">That a selection key&apos;s ready set indicates that its channel is ready for some operation category is a hint, but not a guarantee, that an operation in such a category may be performed by a thread without causing the thread to block. A ready set is most likely to be accurate immediately after the completion of a selection operation. It is likely to be made inaccurate by external events and by I/O operations that are invoked upon the corresponding channel.</span><br><span class="line">This class defines all known operation-set bits, but precisely which bits are supported by a given channel depends upon the type of the channel. Each subclass of SelectableChannel defines an validOps() method which returns a set identifying just those operations that are supported by the channel. An attempt to set or test an operation-set bit that is not supported by a key&apos;s channel will result in an appropriate run-time exception.</span><br><span class="line">It is often necessary to associate some application-specific data with a selection key, for example an object that represents the state of a higher-level protocol and handles readiness notifications in order to implement that protocol. Selection keys therefore support the attachment of a single arbitrary object to a key. An object can be attached via the attach method and then later retrieved via the attachment method.</span><br><span class="line">Selection keys are safe for use by multiple concurrent threads. The operations of reading and writing the interest set will, in general, be synchronized with certain operations of the selector. Exactly how this synchronization is performed is implementation-dependent: In a naive implementation, reading or writing the interest set may block indefinitely if a selection operation is already in progress; in a high-performance implementation, reading or writing the interest set may block briefly, if at all. In any case, a selection operation will always use the interest-set value that was current at the moment that the operation began.</span><br><span class="line"></span><br><span class="line">表示SelectableChannel与Selector注册的标记。</span><br><span class="line">每次向选择器注册通道时，都会创建一个选择键。密钥保持有效，直到通过调用其取消方法，关闭其通道或关闭其选择器来取消密钥。取消密钥不会立即将其从选择器中删除;而是将其添加到选择器的已取消键集中，以便在下一个选择操作期间将其删除。可以通过调用其isValid方法来测试密钥的有效性。</span><br><span class="line">选择键包含表示为整数值的两个操作集。操作集的每个位表示密钥通道支持的可选操作的类别。</span><br><span class="line">- 兴趣集确定下次调用选择器的一个选择方法时将测试哪些操作类别的准备情况。利息集初始化为创建密钥时给定的值;稍后可以通过interestOps（int）方法进行更改。</span><br><span class="line">就绪集合通过键的选择器识别检测到键的通道准备就绪的操作类别。创建密钥时，就绪集初始化为零;稍后可以在选择操作期间由选择器更新，但不能直接更新。</span><br><span class="line">- 选择键的就绪集指示其通道已准备好用于某些操作类别是提示但不保证这样的类别中的操作可由线程执行而不会导致线程阻塞。在完成选择操作之后，就绪设置最有可能是准确的。外部事件和在相应通道上调用的I / O操作可能会使其不准确。</span><br><span class="line">该类定义了所有已知的操作集位，但是精确地由给定通道支持哪些位取决于通道的类型。 SelectableChannel的每个子类定义一个validOps（）方法，该方法返回一个集合，该集合仅标识通道支持的那些操作。尝试设置或测试密钥通道不支持的操作设置位将导致适当的运行时异常。</span><br><span class="line">通常需要将一些特定于应用程序的数据与选择键相关联，例如，表示更高级别协议状态的对象，并处理准备就绪通知以实现该协议。因此，选择键支持将单个任意对象附加到键。可以通过attach方法附加对象，然后通过附加方法检索。</span><br><span class="line">选择键可安全地供多个并发线程使用。通常，读取和写入兴趣集的操作将与选择器的某些操作同步。具体如何执行此同步依赖于实现：在一个简单的实现中，如果选择操作已在进行中，则读取或写入兴趣集可能会无限期地阻塞;在高性能实现中，如果有的话，读取或写入兴趣集可能会暂时阻止。在任何情况下，选择操作将始终使用操作开始时当前的兴趣设定值。</span><br></pre></td></tr></table></figure>
<p>下图格式较为清晰：</p>
<p><img src="/2019/06/08/NIO源码分析之Selector/1559959788470.png" alt="1559959788470"></p>
<p><img src="/2019/06/08/NIO源码分析之Selector/1559960109410.png" alt="1559960109410"></p>
<p>可见interestOps()  和 readyOps()都是返回的int类型，其实他们返回的是上面OP_READ等四个常量的 “|”。</p>
<p>判断集合中是否有某一个常量，可以使用“&amp;”来判断，如 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT</span><br></pre></td></tr></table></figure>
<p>返回值为true则代表存在。</p>
<ul>
<li><h3 id="该对象可以获取以下四种属性："><a href="#该对象可以获取以下四种属性：" class="headerlink" title="该对象可以获取以下四种属性："></a><strong>该对象可以获取以下四种属性：</strong></h3><ul>
<li>interest集合（其实是int类型，上面解释过了）</li>
<li>ready集合（其实是int类型，上面解释过了）</li>
<li>Channel</li>
<li>Selector</li>
</ul>
</li>
</ul>
<p>interest集合是Selector感兴趣的集合，用于指示选择器对通道关心的操作，可通过SelectionKey对象的interestOps()获取。最初，该兴趣集合是通道被注册到Selector时传进来的值。该集合不会被选择器改变，但是可通过interestOps()改变。</p>
<p><img src="/2019/06/08/NIO源码分析之Selector/1559961179277.png" alt="1559961179277"></p>
<p>我们可以通过以下方法来判断Selector是否对Channel的某种事件感兴趣：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet=selectionKey.interestOps();</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br></pre></td></tr></table></figure>
<p><strong>ready</strong> 集合是通道已经就绪的操作的集合，表示一个通道准备好要执行的操作了,可通过SelctionKey对象的readyOps()来获取相关通道已经就绪的操作。它是interest集合的子集，并且表示了interest集合中从上次调用select()以后已经就绪的那些操作。（比如选择器对通道的ready,write操作感兴趣，而某时刻通道的read操作已经准备就绪可以被选择器获知了，前一种就是interest集合，后一种则是ready集合。）。JAVA中定义以下几个方法用来检查这些操作是否就绪：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int readSet=selectionKey.readOps();</span></span><br><span class="line">selectionKey.isAcceptable();<span class="comment">//等价于selectionKey.readyOps()&amp;SelectionKey.OP_ACCEPT</span></span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>
<p>需要注意的是，通过相关的选择键的readyOps()方法返回的就绪状态指示只是一个提示，底层的通道在任何时候都会不断改变，而其他线程也可能在通道上执行操作并影响到它的就绪状态。另外，我们不能直接修改ready集合。</p>
<p><strong>取出SelectionKey所关联的Selector和Channel</strong><br>通过SelectionKey访问对应的Selector和Channel：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel channel =selectionKey.channel();</span><br><span class="line">Selector selector=selectionKey.selector();</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>关于取消SelectionKey对象的那点事</strong></p>
<p>我们可以通过SelectionKey对象的cancel()方法来取消特定的注册关系。</p>
<p><img src="/2019/06/08/NIO源码分析之Selector/1559959631484.png" alt="1559959631484"></p>
<p>该方法调用之后，该SelectionKey对象将会被”拷贝”至已取消键的集合中，该键此时已经失效，但是该注册关系并不会立刻终结。在下一次select()时，已取消键的集合中的元素会被清除，相应的注册关系也真正终结。</p>
</li>
<li><p><strong>为SelectionKey绑定附加对象</strong></p>
</li>
</ul>
<p>可以将一个或者多个附加对象绑定到SelectionKey上，以便容易的识别给定的通道。通常有两种方式： </p>
<ol>
<li><p>在注册的时候直接绑定： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key=channel.register(selector,SelectionKey.OP_READ,theObject);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>在绑定完成之后附加： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);<span class="comment">//绑定</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>绑定之后，可通过对应的SelectionKey取出该对象:<br>selectionKey.attachment();。<br>如果要取消该对象，则可以通过该种方式:<br>selectionKey.attach(null).</p>
<p>需要注意的是如果附加的对象不再使用，一定要人为清除，因为垃圾回收器不会回收该对象，若不清除的话会成内存泄漏。</p>
<p>一个单独的通道可被注册到多个选择器中，有些时候我们需要通过isRegistered（）方法来检查一个通道是否已经被注册到任何一个选择器上。 通常来说，我们并不会这么做。</p>
<ul>
<li>通过Selector选择通道</li>
</ul>
<p>我们知道选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中。接下来我们简单的了解一下Selector维护的三种类型SelectionKey集合：</p>
<p>我们知道选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中。接下来我们简单的了解一下</p>
<h3 id="Selector维护的三种类型SelectionKey集合：（重点）"><a href="#Selector维护的三种类型SelectionKey集合：（重点）" class="headerlink" title="Selector维护的三种类型SelectionKey集合：（重点）"></a><strong>Selector维护的三种类型SelectionKey集合</strong>：（重点）</h3><p>源码中已经说明了一切：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">A multiplexor of SelectableChannel objects.</span><br><span class="line">A selector may be created by invoking the open method of this class, which will use the system&apos;s default selector provider to create a new selector. A selector may also be created by invoking the openSelector method of a custom selector provider. A selector remains open until it is closed via its close method. </span><br><span class="line">A selectable channel&apos;s registration with a selector is represented by a SelectionKey object. A selector maintains three sets of selection keys:</span><br><span class="line">The key set contains the keys representing the current channel registrations of this selector. This set is returned by the keys method.</span><br><span class="line">The selected-key set is the set of keys such that each key&apos;s channel was detected to be ready for at least one of the operations identified in the key&apos;s interest set during a prior selection operation. This set is returned by the selectedKeys method. The selected-key set is always a subset of the key set.</span><br><span class="line">The cancelled-key set is the set of keys that have been cancelled but whose channels have not yet been deregistered. This set is not directly accessible. The cancelled-key set is always a subset of the key set.</span><br><span class="line">All three sets are empty in a newly-created selector.</span><br><span class="line">A key is added to a selector&apos;s key set as a side effect of registering a channel via the channel&apos;s register method. Cancelled keys are removed from the key set during selection operations. The key set itself is not directly modifiable.</span><br><span class="line">A key is added to its selector&apos;s cancelled-key set when it is cancelled, whether by closing its channel or by invoking its cancel method. Cancelling a key will cause its channel to be deregistered during the next selection operation, at which time the key will removed from all of the selector&apos;s key sets. </span><br><span class="line">Keys are added to the selected-key set by selection operations. A key may be removed directly from the selected-key set by invoking the set&apos;s remove method or by invoking the remove method of an iterator obtained from the set. Keys are never removed from the selected-key set in any other way; they are not, in particular, removed as a side effect of selection operations. Keys may not be added directly to the selected-key set.</span><br><span class="line"></span><br><span class="line">SelectableChannel对象的多路复用器。</span><br><span class="line">- 可以通过调用此类的open方法来创建选择器，该方法将使用系统的默认选择器提供程序来创建新的选择器。还可以通过调用自定义选择器提供程序的openSelector方法来创建选择器。选择器保持打开状态，直到通过其关闭方法关闭。</span><br><span class="line">可选择通道的选择器注册由SelectionKey对象表示。选择器维护三组选择键：</span><br><span class="line">重点： 密钥集包含表示此选择器的当前通道注册的键。该方法由keys方法返回。</span><br><span class="line">重点： 所选择的密钥集是一组密钥，使得检测到每个密钥的信道准备好用于在先前选择操作期间在密钥的兴趣集中识别的至少一个操作。这个集由selectedKeys方法返回。选定键集始终是键集的子集。</span><br><span class="line">重点： 取消密钥集是已取消但其通道尚未取消注册的密钥集。此套装无法直接访问。取消密钥集始终是密钥集的子集。</span><br><span class="line">在新创建的选择器中，所有三个组都是空的。</span><br><span class="line">将一个键添加到选择器的键集中，作为通过通道的寄存器方法注册通道的副作用。在选择操作期间，取消的密钥将从密钥集中删除。密钥集本身不能直接修改。</span><br><span class="line">无论是通过关闭其通道还是通过调用其cancel方法，都会在取消选择器的取消键集时添加一个键。取消密钥将导致其通道在下一个选择操作期间取消注册，此时密钥将从所有选择器的密钥集中删除。</span><br><span class="line">通过选择操作将键添加到选定键集。可以通过调用set的remove方法或通过调用从set中获取的迭代器的remove方法，直接从selected-key集中删除键。密钥永远不会以任何其他方式从选定密钥集中删除;特别是，它们不会作为选择操作的副作用而被删除。密钥可能无法直接添加到选定密钥集。</span><br></pre></td></tr></table></figure>
<ul>
<li>密钥集（key set）包含表示此选择器的当前通道注册的键。该方法由keys方法返回。</li>
<li>所选择的密钥集（selected-key set）是一组密钥，使得检测到每个密钥的信道准备好用于在先前选择操作期间在密钥的兴趣集中识别的至少一个操作。这个集由selectedKeys方法返回。选定键集始终是键集的子集。</li>
<li>取消密钥集（ cancelled-key set）是已取消但其通道尚未取消注册的密钥集。此套装无法直接访问。取消密钥集始终是密钥集的子集。</li>
</ul>
<p>在刚初始化的Selector对象中，这三个集合都是空的。通过Selector的select（）方法可以选择已经准备就绪的通道（这些通道包含你感兴趣的的事件）。比如你对读就绪的通道感兴趣，那么select（）方法就会返回读事件已经就绪的那些通道。下面是Selector几个重载的select()方法：<br>select():阻塞到至少有一个通道在你注册的事件上就绪了。<br>select(long timeout)：和select()一样，但最长阻塞事件为timeout毫秒。<br>selectNow():非阻塞，只要有通道就绪就立刻返回。</p>
<p>select()方法返回的int值表示有多少通道已经就绪,是自上次调用select()方法后有多少通道变成就绪状态。之前在select（）调用时进入就绪的通道不会在本次调用中被记入，而在前一次select（）调用进入就绪但现在已经不在处于就绪的通道也不会被记入。例如：首次调用select()方法，如果有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p>
<p>一旦调用select()方法，并且返回值不为0时，则可以通过调用Selector的selectedKeys()方法来访问已选择键集合。如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys=selector.selectedKeys();</span><br></pre></td></tr></table></figure>
<p>进而可以放到和某SelectionKey关联的Selector和Channel。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于Selector执行选择的过程（重点）"><a href="#关于Selector执行选择的过程（重点）" class="headerlink" title="关于Selector执行选择的过程（重点）"></a>关于Selector执行选择的过程（重点）</h3><p>我们知道调用select（）方法进行通道，现在我们再来深入一下选择的过程，也就是select（）执行过程。当select（）被调用时将执行以下几步：</p>
<ol>
<li><p>首先检查已取消键集合，也就是通过cancle()取消的键。如果该集合不为空，则清空该集合里的键，同时该集合中每个取消的键也将从已注册键集合和已选择键集合中移除。（<strong>注意：</strong>一个键被取消时，并不会立刻从集合中移除，而是将该键“拷贝”至已取消键集合中，这种取消策略就是我们常提到的“延迟取消”。）</p>
</li>
<li><p>再次检查已注册键集合（准确说是该集合中每个键的interest集合）。系统底层会依次询问每个已经注册的通道是否准备好选择器所感兴趣的某种操作，一旦发现某个通道已经就绪了，则会首先判断该通道是否已经存在在已选择键集合当中，如果已经存在，则更新该通道在已注册键集合中对应的键的ready集合，如果不存在，则首先清空该通道的对应的键的ready集合，然后重设ready集合，最后将该键存至已注册键集合中。这里需要明白，当更新ready集合时，在<strong>上次select（）中已经就绪的操作不会被删除</strong>，也就是ready集合中的元素是累积的，比如在第一次的selector对某个通道的read和write操作感兴趣，在第一次执行select（）时，该通道的read操作就绪，此时该通道对应的键中的ready集合存有read元素，在第二次执行select()时，该通道的write操作也就绪了，此时该通道对应的ready集合中将同时有read和write元素。</p>
</li>
</ol>
<h3 id="深入已注册键集合的管理（重点）"><a href="#深入已注册键集合的管理（重点）" class="headerlink" title="深入已注册键集合的管理（重点）"></a>深入已注册键集合的管理（重点）</h3><p>由上面贴出的源码可以知道。通过选择操作将键添加到选定键集。可以通过调用set的remove方法或通过调用从set中获取的迭代器的remove方法，直接从selected-key集中删除键。密钥永远不会以任何其他方式从选定密钥集中删除;特别是，它们不会作为选择操作的副作用而被删除。密钥可能无法直接添加到选定密钥集。</p>
<p>首先要记住：选择器不会主动删除被添加到已选择键集合中的键，而且被添加到已选择键集合中的键的ready集合只能被设置，而不能被清理。如果我们希望清空已选择键集合中某个键的ready集合该怎么办？我们知道一个键在新加入已选择键集合之前会首先置空该键的ready集合，这样的话我们可以人为的将某个键从已注册键集合中移除最终实现置空某个键的ready集合。被移除的键如果在下一次的select（）中再次就绪，它将会重新被添加到已选择的键的集合中。这就是为什么要在每次迭代的末尾调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyIterator.remove()</span><br></pre></td></tr></table></figure>
<h3 id="停止选择"><a href="#停止选择" class="headerlink" title="停止选择"></a>停止选择</h3><p>选择器执行选择的过程，系统底层会依次询问每个通道是否已经就绪，这个过程可能会造成调用线程进入阻塞状态,那么我们有以下三种方式可以唤醒在select（）方法中阻塞的线程。</p>
<ol>
<li><p>通过调用Selector对象的wakeup（）方法让处在阻塞状态的select()方法立刻返回 </p>
<p>该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中的选择操作，那么下一次对select()方法的一次调用将立即返回。</p>
</li>
<li><p>通过close（）方法关闭Selector</p>
<p>该方法使得任何一个在选择操作中阻塞的线程都被唤醒（类似wakeup（）），同时使得注册到该Selector的所有Channel被注销，所有的键将被取消，但是Channel本身并不会关闭。</p>
</li>
<li><p>调用interrupt()</p>
<p>调用该方法会使睡眠的线程抛出InterruptException异常，捕获该异常并在调用wakeup()</p>
</li>
</ol>
<h1 id="Selector完整实例"><a href="#Selector完整实例" class="headerlink" title="Selector完整实例"></a>Selector完整实例</h1><p>这里我们结合ServerSocketChannel和Selector构建简单的服务器，下面是完整的代码示例。<br>服务端代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerSocketChannelTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer byteBuffer;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port = <span class="number">8998</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> remoteClientNum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerSocketChannelTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initChannel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        socketChannel = ServerSocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        socketChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        System.out.println(<span class="string">"listener on port:"</span> + port);</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        byteBuffer = ByteBuffer.allocateDirect(size);</span><br><span class="line">        byteBuffer.order(ByteOrder.BIG_ENDIAN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">listener</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = selector.select();</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; ite = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (ite.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = ite.next();</span><br><span class="line">                <span class="comment">//a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">                    SocketChannel channel = server.accept();</span><br><span class="line">                    registerChannel(selector, channel, SelectionKey.OP_READ);</span><br><span class="line">                    remoteClientNum++;</span><br><span class="line">                    System.out.println(<span class="string">"online client num="</span>+remoteClientNum);</span><br><span class="line">                    replyClient(channel);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//a channel is ready for reading</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    readDataFromSocket(key);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ite.remove();<span class="comment">//must</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">readDataFromSocket</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        <span class="keyword">while</span> ((count = socketChannel.read(byteBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            byteBuffer.flip(); <span class="comment">// Make buffer readable</span></span><br><span class="line">            <span class="comment">// Send the data; don't assume it goes all at once</span></span><br><span class="line">            <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">                socketChannel.write(byteBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">            byteBuffer.clear(); <span class="comment">// Empty buffer</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            socketChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replyClient</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        byteBuffer.put(<span class="string">"hello client!\r\n"</span>.getBytes());</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        channel.write(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerChannel</span><span class="params">(Selector selector, SocketChannel channel, <span class="keyword">int</span> ops)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        channel.register(selector, ops);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> ServerSocketChannelTest().listener();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannelTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer byteBuffer;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8998</span>));</span><br><span class="line">        byteBuffer = ByteBuffer.allocate(size);</span><br><span class="line">        byteBuffer.order(ByteOrder.BIG_ENDIAN);</span><br><span class="line">        receive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count;</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            <span class="keyword">while</span> ((count = socketChannel.read(byteBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) byteBuffer.get());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//send("send data to server\r\n".getBytes());</span></span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        byteBuffer.put(data);</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SocketChannelTest().connectServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文参考了：<a href="https://blog.csdn.net/dd864140130/article/details/50299687" target="_blank" rel="noopener">https://blog.csdn.net/dd864140130/article/details/50299687</a>，修正了其中的错误，并以源代码为依据，重新梳理了整个Selector。整个过程花费时间长，收获也很多，特别是对Selector，SelectorKey有了更深一个层次的了解。</p>

      
    </div>

    

    
    
    
	<div>
  
    <div>

    <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>

</div>

  
	</div>

    

    
      
    
    
      <div>
        <div id="reward-container">
  <div>钱不钱的不重要，重要的是文章读了有收获，您说是吧？</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.png" alt="BestQiang 微信支付">
        <p>微信支付</p>
      </div>
    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.png" alt="BestQiang 支付宝">
        <p>支付宝</p>
      </div>
    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/NIO/" rel="tag"><i class="fa fa-tag"></i> NIO</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
            
            
              <div>
                
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];;
</script>

              </div>
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/07/NIO源码分析之Buffer/" rel="next" title="NIO源码分析之Buffer">
                <i class="fa fa-chevron-left"></i> NIO源码分析之Buffer
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/19/J2EE基础知识总结/" rel="prev" title="J2EE基础知识总结">
                J2EE基础知识总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/Hermione.jpg" alt="BestQiang">
            
              <p class="site-author-name" itemprop="name">BestQiang</p>
              <div class="site-description motion-element" itemprop="description">技术的进步来自于不懈的追求!</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/BestQiang" title="GitHub &rarr; https://github.com/BestQiang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/qq_29951485" title="CSDN &rarr; https://blog.csdn.net/qq_29951485" rel="noopener" target="_blank"><i class="fa fa-fw fa-heartbeat"></i>CSDN</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#NIO源码分析之Selector"><span class="nav-text">NIO源码分析之Selector</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Selector"><span class="nav-text">Selector</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SelectableChannel"><span class="nav-text">SelectableChannel</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SelectionKey"><span class="nav-text">SelectionKey</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#该对象可以获取以下四种属性："><span class="nav-text">该对象可以获取以下四种属性：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Selector维护的三种类型SelectionKey集合：（重点）"><span class="nav-text">Selector维护的三种类型SelectionKey集合：（重点）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于Selector执行选择的过程（重点）"><span class="nav-text">关于Selector执行选择的过程（重点）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深入已注册键集合的管理（重点）"><span class="nav-text">深入已注册键集合的管理（重点）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#停止选择"><span class="nav-text">停止选择</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#Selector完整实例"><span class="nav-text">Selector完整实例</span></a></li></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BestQiang</span>

  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">9:33</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  

  
</div>









        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'AKC9sihabckQ6D8LK6tGoXuA-gzGzoHsz',
    appKey: 'EEHjF9YRs6istjqzdeIXKHem',
    placeholder: 'Just go go',
    avatar: 'wavatar',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn'
  });
</script>




  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 --> <script type="text/javascript" src="/js/src/love.js"></script>